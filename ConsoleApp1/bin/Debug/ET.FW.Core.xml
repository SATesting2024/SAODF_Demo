<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ET.FW.Core</name>
    </assembly>
    <members>
        <member name="T:ET.FW.Core.Common.AppExitDisposer">
            <summary>
            Disposes the registered IDisposable objects on Application.Exit();
            The dispose method must be invoked from the main programm.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.AppExitDisposer.Instance">
            <summary>
            Gets the instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="T:ET.FW.Core.Common.DefaultNameAttribute">
            <summary>
            Attribute for the default name an entity.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.DefaultNameAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The default name of the entity.</param>
        </member>
        <member name="P:ET.FW.Core.Common.DefaultNameAttribute.Name">
            <summary>
            Gets or sets the name of the Entity.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.TypedValuesAttribute">
            <summary>
            Attribute defined values for property
            </summary>
            <remarks>
            Attribute for parametrizable property
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.TypedValuesAttribute.#ctor(System.Type,System.Object[])">
            <summary>
            The Constructor
            </summary>
            <param name="type">Type of values</param>
            <param name="values">The Ntg Variant to support.</param>
        </member>
        <member name="P:ET.FW.Core.Common.TypedValuesAttribute.Type">
            <summary>
            Type of values
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.TypedValuesAttribute.Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.ParameterAttribute">
            <summary>
            Attribute marks property as parameter
            </summary>
            <remarks>
            Attribute for parametrizable classes
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Common.ServiceDependencyAttribute">
            <summary>
            An attribute for service dependency.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ServiceDependencyAttribute.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="dependencyType">The type of the service dependency</param>
        </member>
        <member name="M:ET.FW.Core.Common.ServiceDependencyAttribute.#ctor(System.Type,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="dependencyType">The type of the service dependency</param>
            <param name="name">The name of the service dependency</param>
        </member>
        <member name="P:ET.FW.Core.Common.ServiceDependencyAttribute.DependencyType">
            <summary>
            Gets or sets the type of the dependency.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ServiceDependencyAttribute.Name">
            <summary>
            Gets or sets the name of the dependency.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ServiceDependencyAttribute.PropertyWithServiceName">
            <summary>
            Property, i.e. Param in testbench.xml, where the name
            of the serivce is stored. Can be used to uniquely reference a
            service, which cannot be uniquely referenced by the Interface.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ServiceDependencyAttribute.Optional">
            <summary>
            If set to TRUE, the Service is not necessarily required but,
            if defined in testbench.xml, it is used and must be started before
            initializing the class holding this attribute
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Bcd">
            <summary>
            Helper class for BCD (Binary Coded Decimal) decoding
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Bcd.Bcd2Byte(System.Byte)">
            <summary>
            Convert byte from BCD to binary
            </summary>
            <param name="bcdValue">BCD coded value</param>
            <returns>binary value</returns>
        </member>
        <member name="T:ET.FW.Core.Common.EndPointInformations">
            <summary>
            The class provides the health check informations for clients
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.State">
            <summary>
            Application State, online offline, idle etc
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.ProdcutVersion">
            <summary>
            ETFramework version.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.AddonsVersion">
            <summary>
             ETF plugin versions.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.ActiveProfile">
            <summary>
            Active profile used.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.ActiveBuses">
            <summary>
            Active buses.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.DatabaseFilesArxmlDbc">
            <summary>
            Arxml files or DBC files.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.ETF_Starter_Status">
            <summary>
            Rest api starter project status.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.EndPointInformations.MemoryStatus">
            <summary>
            Memory status disk full or not.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.EndPointInformations.ApplicationState">
            <summary>
            Global Framework state (as seen by the user)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Undefined">
            <summary>
            State not set
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Idle">
            <summary>
            Idle state after startup (no trace DB open)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.OpeningYamDB">
            <summary>
            Opening Yam DB file for reading
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.ClosingYamDB">
            <summary>
            Closing Yam DB file
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Offline">
            <summary>
            Offline state with trace DB opened (viewer mode)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.InitOnlineEnvironment">
            <summary>
            Initialize online environment (initialize hardware)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Online">
            <summary>
            Online mode: Hardware is active and monitored, no test plan active
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.DeinitOnlineEnvironment">
            <summary>
            Shutting down online environment (stop hardware)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.StartingTest">
            <summary>
            Loading and starting test set
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Running">
            <summary>
            Executing test
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.StoppingTest">
            <summary>
            Shutting down testplan execution
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.InitOfflineEnvironment">
            <summary>
            Initializing offline environment for import
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Importing">
            <summary>
            Importing file
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.DeinitOfflineEnvironment">
            <summary>
            Shutting down offline environment
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.ShuttingDown">
            <summary>
            Shutting down framework
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EndPointInformations.ApplicationState.Disposed">
            <summary>
            Framework is disposed
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.FileOperations">
            <summary>
            File Operations
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.FileOperations.FileCopyResults">
            <summary>
            File Copy Failed condiotins
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.FileOperations.FileCopyResults.FilesCopySuccess">
            <summary>
            Files Copy Success
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.FileOperations.FileCopyResults.DirectoryDoestNotExist">
            <summary>
            Directory Doest Not Exist
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.FileOperations.FileCopyResults.FilesNotCopied">
            <summary>
            Files Not Copied
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FileOperations.CopyFiles(System.String,System.String,System.String@,System.String)">
            <summary>
            Copy File
            </summary>
            <param name="sourcePath">source Path</param>
            <param name="targetPath">target Path</param>
            <param name="resultMsg">Copy result message</param>
            <param name="excludeFile">excluded file for copying</param>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.ETFWInfoHelper">
            <summary>
            This helper class supports the test developer with some useful ETFW informations like file locations, versions etc..
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ETFWInfoHelper.GetProgramAssembliesInfos(System.String)">
            <summary>
            Returns information about all assemblies stored in the bin folder.
            </summary>
            <param name="pattern">regex to compress the output result</param>
            <returns>dictionary with filenames containing a dictionary with info attributes</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ETFWInfoHelper.GetRuntimeAssembliesInfo(System.String)">
            <summary>
            Returns information about all assemblies loaded into ETFW at the moment.
            </summary>
            <param name="pattern">regex to compress the output result</param>
            <returns>dictionary with filenames containing a dictionary with info attributes</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.ByteExtensions">
            <summary>
            Extendion methodes for <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteExtensions.GetString(System.Byte[])">
            <summary>
            Converts the numeric value of each element of a specified array of bytes to its equivalent hexadecimal string representation.
            </summary>
            <param name="data">An array of bytes.</param>
            <returns>A string of hexadecimal values.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteExtensions.ToANSIString(System.Byte[])">
            <summary>
            Decodes all the bytes in the specified byte array into a string using the operating system's current ANSI code page.
            </summary>
            <param name="data">The byte array containing the sequence of bytes to decode.</param>
            <returns>A String containing the results of decoding the specified sequence of bytes.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteExtensions.ToHexString(System.Byte[])">
            <summary>
            Converts the numeric value of each element of a specified array of bytes to its equivalent hexadecimal string representation.
            </summary>
            <param name="data">An array of bytes.</param>
            <returns>A string of hexadecimal pairs separated by hyphens, where each pair represents the corresponding element in value; for example, "7F-2C-4A-00".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteExtensions.ToBase64String(System.Byte[])">
            <summary>
            Converts an array of 8-bit unsigned integers to its equivalent string representation that is encoded with base-64 digits.
            </summary>
            <param name="data">An array of 8-bit unsigned integers.</param>
            <returns>The string representation, in base 64, of the contents of data.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.ClassAttributes">
            <summary>
            Helper class for handling of class attributes
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ClassAttributes.TryReadAttributes``1(System.Type,System.Collections.Generic.List{``0}@)">
            <summary>
            Helper to read certain attributes from a class.
            </summary>
            <typeparam name="T">The AttributeType to read</typeparam>
            <param name="type">The Type whose Attributes shall be read</param>
            <param name="attributes">out: the found Attributes matching the given AttributeType</param>
            <returns>TRUE, if at least one attribute of AttributeType was found, FALSE otherwise.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.CompareHelper">
            <summary>
            Helper class for compare functionality
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.CompareHelper.SpecialCompare(System.Object,System.String)">
            <summary>
            Comparing the given object to the compare instruction by analyzing the object with reflection.
            There is a special syntax for the compare instruction:
            <para/>
             &lt;Propertyname&gt;>="&lt;Value&gt;"; ...; &lt;Propertyname&gt;.&lt;PropertyName&gt;="&lt;Value&gt;"
            <para/>
            Example: X="1"; Y="4"; Size.Width="200"
             =&gt; This instruction would check whether the property 'X' has the value '1' 
               and the property 'Y' has the value '4' and the property 'Width' of the property 
               'Size' has the value '200'. The value will be compared by reflection.
            <para/>
            It is also possible to compare the result of ToString() with an regular expression:
            Example: ToString()="&lt;Regular expression&gt;"
            </summary>
            <param name="target">The object to analyze.</param>
            <param name="specialCompareInstruction">The compare instruction containing the string values of the properties to compare.
            For example X="1"; Y="4"; Size.Width="200"</param>
            <returns>Result of comparism</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.CompareHelper.CompareElement(System.Object,System.String)">
            <summary>
            Comparing the given object to the compare instruction by analyzing the object with reflection.
            </summary>
            <param name="target">The object to analyze and compare.</param>
            <param name="instruction">The compare instruction containing the string values of the properties to compare.</param>
            <returns>Result of comparism</returns>
            <exception cref="T:System.FormatException">Thrown when the compare instruction doesn't match the wanted syntax.</exception>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.CompareHelper.CompareReflection(System.Object,System.String,System.String)">
            <summary>
            Comparing the given object to the compare instruction by analyzing the object with reflection.
            </summary>
            <param name="target">The object to analyze and compare.</param>
            <param name="propertyName">The name of the property to compare.</param>
            <param name="value">The expected value of the property to compare.</param>
            <returns>Result of comparism</returns>
            <exception cref="T:System.FormatException">Thrown when the compare instruction doesn't match the wanted syntax.</exception>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.CompareHelper.CompareRegex(System.Object,System.String)">
            <summary>
            Compares the target by comparing the result of the Tostring method with the regular expression.
            </summary>
            <param name="target">The object to analyze and compare.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>Result of comparism</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.ConvertHelper">
            <summary>
            Helper class for convert methodes with CultureInfo.InvariantCulture
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.TryParse(System.String,System.Double@)">
            <summary>
            Try parse string to Double
            </summary>
            <param name="s">the string</param>
            <param name="value">double value</param>
            <returns>true if parsing is success</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ParseDouble(System.String)">
            <summary>
            parse string to double
            </summary>
            <param name="s">the string</param>
            <returns>double value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ToString(System.Double)">
            <summary>
            Double to string
            </summary>
            <param name="value">the value</param>
            <returns>the string of double value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ToString(System.Double,System.String)">
            <summary>
            Double to string
            </summary>
            <param name="value">the value</param>
            <param name="format">format string</param>
            <returns>the string of double value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.TryParse(System.String,System.Single@)">
            <summary>
            Try parse string to Float
            </summary>
            <param name="s">the string</param>
            <param name="value">float value</param>
            <returns>true if parsing is success</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ParseFloat(System.String)">
            <summary>
            parse string to float
            </summary>
            <param name="s">the string</param>
            <returns>float value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ToString(System.Single)">
            <summary>
            Float to string
            </summary>
            <param name="value">the value</param>
            <returns>the string of float value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.ToString(System.Single,System.String)">
            <summary>
            Float to string
            </summary>
            <param name="value">the value</param>
            <param name="format">format string</param>
            <returns>the string of float value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.GetDecimalPlaceCount(System.Single)">
            <summary>
            Gets count of decimal places
            </summary>
            <param name="value">Float value</param>
            <returns>Count of decimal places</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.GetDecimalPlaceCount(System.Double)">
            <summary>
            Gets count of decimal places
            </summary>
            <param name="value">Double value</param>
            <returns>Count of decimal places</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ConvertHelper.GetDecimalPlaceCount(System.Decimal)">
            <summary>
            Gets count of decimal places
            </summary>
            <param name="value">The value</param>
            <returns>Count of decimal places</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.DirectoryHelper">
            <summary>
            Helper(s) for handling directories
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DirectoryHelper.AssureDirectoryExists(System.String)">
            <summary>
            Assure, the given directory does exist.<para></para>
            If it does not already exist, it becomes created, if possible.
            </summary>
            <param name="directory">The directory whose existance shall be assured.</param>
            <returns>TRUE if the directory exists, FALSE if it does not exist and could not be created.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.DllClassDictionary">
            <summary>
            Provides static methods to search classes which implement a special interface or are derived from a special base class.
            Classes are searched in all assemblies of the bin folder which match selectable file name masks.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassDictionary.ReadDlls(System.String,System.String[],System.Type[],System.Boolean)">
            <summary>
            Reads the DLLs in the searchPath matching one of the masks, filter the exported (not abstract) types with the interface, 
            stores class fullname and type int the classDict. 
            The returned outer dictionary holds an inner dictionary per given searchInterface.
            Inner dictionary holds all types which implement the searchInterface, key is the full class name (including namespace).
            </summary>
            <param name="searchPath">The search path.</param>
            <param name="masks">The file name masks.</param>
            <param name="searchInterfaces">The search interfaces.</param>
            <param name="includeAbstractClasses">if set to <c>true</c> the dll read will also include abstract classes.</param>
            <returns>Dictionary of dictionaries of classes with seachInterfaces</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassDictionary.GetTypeDictionary``1(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.Dictionary{System.String,System.Type}})">
            <summary>
            Get dictionary for matching type from dictionary of type dictionaries. 
            </summary>
            <typeparam name="T">Class type of dictionary to search.</typeparam>
            <param name="classDicts">Dictionary of type dictionary as returned by ReadDlls() method</param>
            <returns>Type dictionary for the type parameter, empty dictionary if no matching entry was found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassDictionary.ReadDlls``1(System.String[],System.Boolean,System.Boolean)">
            <summary>
            Reads the DLLs in bin directory matching one of the masks.
            Returns a dictionary containing all exported types derived from or implementing type parameter T. 
            Key of dictionary values is full class name (including namespaces).
            </summary>
            <typeparam name="T">The type to search for in the assembly/assemblies.</typeparam>
            <param name="masks">The file masks as string array, for example "ET.FW.Hal.Instruments.*.dll"</param>
            <param name="includeAbstractClasses">Flag, whether to include abstract types</param>
            <param name="isTestPlan">Optional Parameter to identify the testplans </param>
            <returns>Dictionary containing all found types as values, keys are the full type names.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassDictionary.ReadDlls(System.String,System.String[],System.Type,System.Collections.Generic.Dictionary{System.String,System.Type},System.Boolean,System.Boolean)">
            <summary>
            Reads the DLLs in the searchPath matching one of the masks, filter the exported (not abstract) types with the interface, stores class fullname and type int the classDict.
            </summary>
            <param name="searchPath">The search path.</param>
            <param name="masks">The masks.</param>
            <param name="searchInterface">The search interface.</param>
            <param name="classDict">The class dict.</param>
            <param name="includeAbstractClasses">if set to <c>true</c> the dll read will also include abstract classes.</param>
            <param name="isTestPlan">Identifies the </param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassDictionary.GetDllNames(System.String,System.String[])">
            <summary>
            Get DLL names in search path
            </summary>
            <param name="searchPath">Path ot search DLLs</param>
            <param name="masks">Masks of DLL name</param>
            <returns>List of DLL names with full path</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.DllClassList`1">
            <summary>
            Collection scans one or more assemblies for classes derived of a type.
            All found types are stored and can be instantiated on demand.
            Class supports multiple types with identical class names. This types must be accessed using namespaces.
            </summary>
            <remarks>
            Classes are extracted from the assembly/assemblies.
            Classes can be searched with full namespace or without namespace.
            Internal key for class access is class name without namespaces.
            </remarks>
            <typeparam name="T"> The type to search for in the assembly/assemblies.</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Create a new instance of the DllClassList class for all assemblies of given search path matching the given file name mask.
            </summary>
            <param name="path">The path to search in</param>
            <param name="mask">The file mask for example "ET.FW.Hal.Instruments.*.dll"</param>
            <param name="includeAbstractTypes">Flag, whether to include abstract types</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.#ctor(System.String,System.String[],System.Boolean)">
            <summary>
            Create a new instance of the DllClassList class for all assemblies of given search path matching the given file name masks.
            </summary>
            <param name="path">The path to search in</param>
            <param name="masks">The file masks as string array, for example "ET.FW.Hal.Instruments.*.dll"</param>
            <param name="includeAbstractTypes">Flag, whether to include abstract types</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.GetFileNames(System.String,System.String[])">
            <summary>
            Returns filenames of all files inside a directory which match at least one of the given masks.
            </summary>
            <param name="path">The path to get the files.</param>
            <param name="masks">The file mask to search.</param>
            <returns>A list with the found files.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.#ctor(System.String)">
            <summary>
            Construct class list for single assembly.
            Tries to load the given filename. If this file cannot be found, the file is
            searched within the Assemblies-path.
            </summary>
            <param name="filename">The filename to load"</param>
            <remarks>Includes abstract classes for backward compability.</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.#ctor(System.String,System.Boolean)">
            <summary>
            Construct class list for single assembly.
            Tries to load the given filename. If this file cannot be found, the file is
            searched within the Assemblies-path.
            </summary>
            <param name="filename">The filename to load</param>
            <param name="includeAbstractTypes">Flag, whether to include abstract types</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.ReadDlls(System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>
            Initialize list of Classes.
            All public classes of Classes assembly which are derived from Type T are stored.
            </summary>
            <param name="filenames">A array with the file names.</param>
            <param name="includeAbstractTypes">Flag, whether to include abstract types</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.CurrentDomain_AssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary>
            Occurs when the resolution of an assembly fails. 
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="args">The event data.</param>
            <returns>The assembly that resolves the type, assembly, or resource; or <c>null</c> if the assembly cannot be resolved.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.CreateInstance(System.String,System.Object[])">
            <summary>
            Create and initialize object with the given parameters
            </summary>
            <param name="className">The class name.</param>
            <param name="paras">Construction parameters</param>
            <returns>
            Then newly constructed object, null if no instance can be created.
            </returns>
            <remarks>This method uses reflection to dynamically construct an object of the class type.</remarks>
        </member>
        <member name="F:ET.FW.Core.Common.Helpers.DllClassList`1.classes">
            <summary>
            Collection to hold all types, key is the type name (without namespace)
            Name might not be unique, so for each name there is a list of types.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.AddType(System.Type)">
            <summary>
            Adds the type to collection, avoid duplicate type entries.
            </summary>
            <param name="type">The type to add</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.GetType(System.String)">
            <summary>
            Search and return type for given class name
            </summary>
            <param name="className">Name of class to search. Name can be unqualified class e.g. 'Toellner' name or can contain complete namespace 'ET.FW.Hal.Instruments.Toellner'</param>
            <returns>Type for given name, null if not found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DllClassList`1.Clear">
            <summary>
            Clears this instance
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.DllClassList`1.IsEmpty">
            <summary>
            Check if this instance holds no types
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.DllClassList`1.Types">
            <summary>
            Gets all types from this collection.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.EnumHelper`1">
            <summary>
            Enum Helper to get Names, Descriptions and Userstrings of defined Enum
            </summary>
            <typeparam name="T">Enum type</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.Attributes">
            <summary>
            Internal dictionary containing information of all enum values
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.Type">
            <summary>
            Type of Enum
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.EnumValues">
            <summary>
            Get the enum values when you know the enum name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.Values">
            <summary>
            Values of enum
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.Names">
            <summary>
            Create dictionary of enum names, key is enum value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.Descriptions">
            <summary>
            Create dictionary of enum descriptions, key is enum value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumHelper`1.UserStrings">
            <summary>
            Gets all user strings of the enumeration as dictionary, key is enum value.
            User string is declarded via attribute <see cref="T:ET.FW.Core.Common.StringValueAttribute"/>. If this attribute is not given, enum name is used.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.#cctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Helpers.EnumHelper`1"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.AddWithName(System.String)">
            <summary>
            Adds new entry from enum name
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.AddWithValue(`0)">
            <summary>
            Adds new entryy from enum value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Add(`0,System.String)">
            <summary>
            Adds new entry
            </summary>
            <param name="value">Enum value</param>
            <param name="name">Enum name</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Name(`0)">
            <summary>
            Returns a name string for the given enum.
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>Property name of enum value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.SafeName(`0)">
            <summary>
            Returns a name string for the given enum.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>Property name of enum value</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Description(`0)">
            <summary>
            Returns a Description for the given enum.
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>Description of enum value, if exists, otherwise the property name </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.SafeDescription(`0)">
            <summary>
            Returns a Description for the given enum.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>Description of enum value, if exists, otherwise the property name </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.UserString(`0)">
            <summary>
            Returns user string for the given enum.
            User string is declarded via attribute <see cref="T:ET.FW.Core.Common.StringValueAttribute"/>. If this attribute is not given, enum name is used.
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>user string of enum value, if exists, otherwise the property name </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.SafeUserString(`0)">
            <summary>
            Returns a string for the given enum.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>user string of enum value, if exists, otherwise the property name </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.TryGetValueFromUserString(System.String,`0@)">
            <summary>
            Searches enum value, with matching user string
            </summary>
            <param name="userString">User string to search</param>
            <param name="value">Matching enum value, if user string was found</param>
            <returns>true, if user string was found.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.GetValueFromUserString(System.String)">
            <summary>
            Searches enum value, with matching user string
            </summary>
            <param name="userString">User string to search</param>
            <returns>Matching enum value, if user string was found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Value(System.String)">
            <summary>
            Returns a value for the given enum name.
            </summary>
            <param name="enumName">Name of the enum.</param>
            <returns>value of enum wiht property name</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Contains(System.String)">
            <summary>
            Determines whether [contains] [the specified enum name].
            </summary>
            <param name="enumName">Name of the enum.</param>
            <returns>
            	<c>true</c> if [contains] [the specified enum name]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumHelper`1.Contains(`0)">
            <summary>
            Determines whether [contains] [the specified enum value].
            </summary>
            <param name="enumValue">Value of the enum.</param>
            <returns>
            	<c>true</c> if [contains] [the specified enum value]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.EnumAttributes">
            <summary>
            Enum Attributes
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumAttributes.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Helpers.EnumAttributes"/> struct.
            </summary>
            <param name="name">The enum name.</param>
            <param name="description">The description (declared via attribute <see cref="T:System.ComponentModel.DescriptionAttribute"/>)</param>
            <param name="userString">The user string.(declarded via attribute <see cref="T:ET.FW.Core.Common.StringValueAttribute"/>)</param>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumAttributes.Name">
            <summary>
            Name of enum value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumAttributes.Description">
            <summary>
            Description of enum value (declared via attribute <see cref="T:System.ComponentModel.DescriptionAttribute"/>)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumAttributes.UserString">
            <summary>
            User string of enum value
            User string is declarded via attribute <see cref="T:ET.FW.Core.Common.StringValueAttribute"/>. If this attribute is not given, enum name is used.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.EnumIndexes`1">
            <summary>
            Enum names
            </summary>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.EnumIndexes`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Helpers.EnumIndexes`1"/> class.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.EnumIndexes`1.Item(`0)">
            <summary>
            Gets or sets the <see cref="T:System.Int32" /> with the specified enum value.
            </summary>
            <param name="enumValue">The enum value.</param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.FloatHelper">
            <summary>
            Helper class for Floating operations
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.FloatHelper.AreEqual(System.Double,System.Double)">
            <summary>
            Checks if Floating numbers are equal upto 5 precision points
            </summary>
            <param name="number1">Left Operand</param>
            <param name="number2">Right Operand</param>
            <returns>True if numbers are equal else false</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.FloatHelper.AreNotEqual(System.Double,System.Double)">
            <summary>
            Checks if Floating numbers are not equal upto 5 precision points
            </summary>
            <param name="number1">Left Operand</param>
            <param name="number2">Right Operand</param>
            <returns>True if numbers are not equal else false</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.FloatHelper.AreEqual(System.Double,System.Double,System.Byte)">
            <summary>
            Checks if Floating numbers are equal upto given precision points 
            </summary>
            <param name="number1"></param>
            <param name="number2">Right Operand</param>
            <param name="precision">Desired precision digits for compare</param>
            <returns>True if numbers are equal else false</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.FloatHelper.AreNotEqual(System.Double,System.Double,System.Byte)">
            <summary>
            Checks if Floating numbers are not equal upto given precision points
            </summary>
            <param name="number1">Left Operand</param>
            <param name="number2">Right Operand</param>
            <param name="precision">Desired precision digits for compare</param>
            <returns>True if numbers are not equal else false</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.IniFileHelper">
            <summary>
            Create a New INI file to store or load data
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Helpers.IniFileHelper.Path">
            <summary>
            FilePath
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.IniFileHelper.#ctor(System.String)">
            <summary>
            INIFile Constructor.
            </summary>
            <PARAM name="iniPath"></PARAM>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.IniFileHelper.IniWriteValue(System.String,System.String,System.String)">
            <summary>
            Write Data to the INI File
            </summary>
            <PARAM name="section"></PARAM>
            Section name
            <PARAM name="key"></PARAM>
            Key Name
            <PARAM name="value"></PARAM>
            Value Name
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.IniFileHelper.IniReadValue(System.String,System.String)">
            <summary>
            Read Data Value From the Ini File
            </summary>
            <PARAM name="section"></PARAM>
            <PARAM name="key"></PARAM>
            <PARAM></PARAM>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.LinkHelper">
            <summary>
            Static helper-class for handling links
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.LinkHelper.OpenLink(System.String)">
            <summary>
            Open the given link in the default-browser
            </summary>
            <param name="url">the url to open</param>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.RawString">
            <summary>
            Raw string class wrapping an xml string to serialize and deserialize
            without escaping xml special characters.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Helpers.RawString.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.RawString.GetSchema">
            <summary>
            This method is reserved and should not be used. When implementing the IXmlSerializable interface,
             you should return null (Nothing in Visual Basic) from this method, and instead, 
            if specifying a custom schema is required, apply the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
            <returns>
            An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of 
            the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 
            method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.RawString.ReadXml(System.Xml.XmlReader)">
            <summary>
            Generates an object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" /> stream from which the object is deserialized.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.RawString.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Converts an object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized.</param>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.StringHelper">
            <summary>
            String helper
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.StringHelper.ReplaceNewLine(System.String)">
            <summary>
            Replaces "\n" as Environment.NewLine
            </summary>
            <param name="text">The text</param>
            <returns>The new text</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.StringHelper.CompareValues(System.String,System.String)">
            <summary>
            Comparing the data values of the two messages
            </summary>
            <param name="leftMsgData">Left Messsage Data</param>
            <param name="rightMsgData">Right Messsage Data</param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.XPathHelper">
            <summary>
            Helper class for XPath
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XPathHelper.Combine(System.String,System.String)">
            <summary>
            combine paths
            </summary>
            <param name="xpath1"></param>
            <param name="xpath2"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XPathHelper.AddAttribute(System.String,System.String,System.String)">
            <summary>
            Add attribute
            </summary>
            <param name="xpath"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XPathHelper.GetPathNodes(System.String)">
            <summary>
            List of PathNodes
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.ByteArrayHelper">
            <summary>
            Helper methodes for Byte Array
            </summary>
            <remarks>
            It should be preferred to use .net Framework classes BitConverter, ASCIIEncoing, UTF8Encoding, etc. directly
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ParseUTCDateTimeFromTicks(System.Byte[],System.Int32)">
            <summary>
            Parse Datetime as UTC in byte array from start index to length
            </summary>
            <param name="data">The data.</param>
            <param name="startIndex">The start index.</param>
            <returns>the utc datetime</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ParseEtDateTimeFromBinary(System.Byte[],System.Int32)">
            <summary>
            Parse Datetime in byte array from start index to length
            </summary>
            <param name="data">The data.</param>
            <param name="startIndex">The start index.</param>
            <returns>the datetime</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ParseASCIIString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse ASCII string in byte array from start index to length
            </summary>
            <param name="data">The data.</param>
            <param name="startIndex">The start index.</param>
            <param name="length">The length.</param>
            <returns>the ascii string</returns>
            <remarks>
            Consider using ASCIIEncoding.GetString() method instead
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ParseUTF8String(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse UTF8 string in byte array from start index to length
            </summary>
            <param name="data">The data.</param>
            <param name="startIndex">The start index.</param>
            <param name="length">The length.</param>
            <returns>the string</returns>
            <remarks>
            Consider using UTF8Encoding.GetString() method instead
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.GetByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get byte data from start index to length
            </summary>
            <param name="data">The data.</param>
            <param name="startIndex">The start index.</param>
            <param name="length">The length.</param>
            <returns>the extracted array</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ASCIIStringToByteArray(System.String)">
            <summary>
            Convert ASCII string to byte array
            </summary>
            <param name="str">the string tp convert</param>
            <returns>the byte array</returns>
            <remarks>Consider using ASCIIEncoding.GetBytes() method instead</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.UnicodeStringToByteArray(System.String)">
            <summary>
            Convert Unicode string to byte array
            </summary>
            <param name="str">the string tp convert</param>
            <returns>the byte array</returns>
            <remarks>Consider using ASCIIEncoding.GetBytes() method instead</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ByteArrayToASCIIString(System.Byte[])">
            <summary>
            Convert byte array to ASCII string
            </summary>
            <param name="arr">array to convert</param>
            <returns>the ascii string</returns>
            <remarks>Consider using ASCIIEncoding.GetString() method instead</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.UTF8StringToByteArray(System.String)">
            <summary>
            Convert unicode string to byte array
            </summary>
            <param name="str">string to convert</param>
            <returns>the byte array</returns>
            <remarks>Consider using UTF8Encoding.GetBytes() method instead</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ByteArrayToUTF8String(System.Byte[])">
            <summary>
            Convert byte array to unicode string
            </summary>
            <param name="arr">array to convert</param>
            <returns>the UTF8 string</returns>
            <remarks>Consider using UTF8Encoding.GetString() method instead</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.#cctor">
            <summary>
            Initializes the <see cref="T:ET.FW.Core.Common.Helpers.ByteArrayHelper"/> class:
            Init Hex string table.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.HexDataString(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates textual representation of byte array values.
            </summary>
            <param name="data">Source byte array</param>
            <param name="startPos">The starting position within data.</param>
            <param name="length">The number of bytes within data to convert.</param>
            <param name="withSpace">Flag to insert space between bytes</param>
            <returns>String with hex bytes with or without spaces</returns>
            <remarks>
            Consider using BitConverter.ToString() (Difference: Bitconverter uses '-' as separator between bytes, chars are uppercase)
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.HexDataString(System.Byte[],System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates textual representation of byte array values.
            </summary>
            <param name="data">Source byte array</param>
            <param name="startPos">The starting position within data.</param>
            <param name="length">The number of bytes within data to convert.</param>
            <param name="withSpace">Flag to insert space between bytes</param>
            <returns>String with hex bytes with or without spaces</returns>
            <remarks>
            Consider using BitConverter.ToString() (Difference: Bitconverter uses '-' as separator between bytes, chars are uppercase)
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.HexDataString(System.Byte[],System.Boolean)">
            <summary>
            Creates textual representation of byte array values
            </summary>
            <param name="data">Source byte array</param>
            <param name="withComma">Flag to insert comma between bytes</param>
            <returns>String with hex bytes with or without comma</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.DezimalDataString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts Data stored in a bytearray to a String of Decimal number
            </summary>
            <param name="data">Bytearray with data</param>
            <param name="startPos">The Startposition</param>
            <param name="length">The Length</param>
            <returns>
            String with decimal number
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.HexStringToData(System.String)">
            <summary>
            Converts a hex string (e.g. "96A3") to an array of bytes (e.g. 96 A3).
            </summary>
            <param name="hexString">The hex string.</param>
            <returns>the converted data array </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.BytesToLong(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Converts a byte array to a long value.
            </summary>
            <param name="data">The data in byte array format.</param>
            <param name="start">The start index.</param>
            <param name="count">The amount of bytes to use.</param>
            <param name="isLittleEndian">if set to <c>true</c> bytes are in little endian order, else in big endian order.</param>
            <returns>The converted value</returns>
            <remarks>
            'count' is currently limited to 8 bytes.
            Consider using BitConverter.ToUInt32()
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.BytesToLong(System.Byte[],System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Converts a byte array to a long value.
            </summary>
            <param name="data">The data in byte array format.</param>
            <param name="start">The start index.</param>
            <param name="count">The amount of bytes to use.</param>
            <param name="isLittleEndian">if set to <c>true</c> bytes are in little endian order, else in big endian order.</param>
            <returns>The converted value</returns>
            <remarks>
            'count' is currently limited to 8 bytes.
            Consider using BitConverter.ToUInt32()
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.GetUint64ToByteArray(System.UInt64,System.Int32,System.Int32)">
            <summary>
            Get Byte array for uint 64
            </summary>
            <param name="num">Number to be converted</param>
            <param name="startIndex">Start Index</param>
            <param name="length">Length</param>
            <returns>Byte Array</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.IsZero(System.Byte[])">
            <summary>
            Check if byte array is complete zero
            </summary>
            <param name="value">byte array</param>
            <returns>true, if all byte array values are zero</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.Equals(System.Byte[],System.Byte[])">
            <summary>
            Compares a byte array with other byte byte array .
            </summary>
            <param name="b1">The b1.</param>
            <param name="b2">The b2.</param>
            <returns>true if equal</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.SetBit(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="self"></param>
            <param name="index"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ToggleBit(System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="self"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.GetBit(System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="self"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.StringToDecimalData(System.String)">
            <summary>
            
            </summary>
            <param name="hexString"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.ConvertBytesToUshort(System.Byte,System.Byte)">
            <summary>
            Converts bytes ushort
            </summary>
            <param name="firstByte">First Byte</param>
            <param name="secByte">Second Byte</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.HexToDouble(System.String,System.Boolean)">
            <summary>
            hexadecimal to double conversion 
            </summary>
            <param name="hexVal"></param>
            <param name="isLittleEndian">whether is little Endian</param>
            <returns>double</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.ByteArrayHelper.StringToHex(System.String,System.Boolean)">
            <summary>
            String to hexadecimal conversion
            </summary>
            <param name="value">string value</param>
            <param name="isLittleEndian">whether is little Endian</param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.DateTimeHelper">
            <summary>
            Helper for DateTime
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Helpers.DateTimeHelper.UTC_UnixStartTime">
            <summary>
            Unix start time (UTC-Kind)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Helpers.DateTimeHelper.ET_UnixStartTime">
            <summary>
            Unix start time (ET-Kind)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.UTC_ToCSharpTime(System.Int64)">
            <summary>
            UTC-Ticks from 01.01.1970 to datetime
            </summary>
            <param name="ticks">100 ns</param>
            <returns>The Timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.ET_ToCSharpTime(System.Int64)">
            <summary>
            ET-Ticks from 01.01.1970 to datetime
            </summary>
            <param name="ticks">The ticks</param>
            <returns>The timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.SetCorrectionTicks(System.Int64)">
            <summary>
            Set Correction ticks
            </summary>
            <param name="ticks">The ticks</param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.CorrectTimestamp(System.DateTime)">
            <summary>
            Corrects timestamp with correction ticks
            </summary>
            <param name="timestamp">The timestamp</param>
            <returns>Correted Timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.DateTimeString(System.DateTime,System.Int64)">
            <summary>
            Convert DateTime to string
            </summary>
            <param name="dateTime">The datetime</param>
            <param name="us">Micro seconds</param>
            <returns>dd.mm.yyyy hh:mm:ss.fff</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.DateTimeString(System.DateTime)">
            <summary>
            Convert DateTime to string
            </summary>
            <param name="dateTime">The datetime</param>
            <returns>dd.mm.yyyy hh:mm:ss.ffffff</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.DateTimeStringMs(System.DateTime)">
            <summary>
            Convert DateTime to string
            </summary>
            <param name="dateTime">The datetime</param>
            <returns>dd.mm.yyyy hh:mm:ss.fff</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.FullDateTimeString(System.DateTime)">
            <summary>
            Convert DateTime to string
            </summary>
            <param name="dateTime">The datetime</param>
            <returns>dd.mm.yyyy hh:mm:ss.fffffff</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.ToFilenameStringLong(System.DateTime)">
            <summary>
            Convert for the filename string.
            </summary>
            <param name="dateTime">The date time.</param>
            <returns>Datetime string with format "_yyyy-MM-dd_HH-mm-ss-fff"</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.ToFilenameString_HH_mm(System.DateTime)">
            <summary>
            Convert for the filename string
            </summary>
            <param name="dateTime">The date time.</param>
            <returns>Datetime string with format "_yyyy-MM-dd_HH-mm"</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.ToFilenameString_HH_mm_ss(System.DateTime)">
            <summary>
            Convert for the filename string
            </summary>
            <param name="dateTime">The date time.</param>
            <returns>Datetime string with format "_yyyy-MM-dd_HH-mm-ss"</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.YearString(System.DateTime)">
            <summary>
            Returns the Year string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Year string.</param>
            <returns>A string that represents the Year with format "yyyy".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.MonthString(System.DateTime)">
            <summary>
            Returns the Month string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Month string.</param>
            <returns>A string that represents the Month with format "MM".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.DayString(System.DateTime)">
            <summary>
            Returns the Day string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Day string.</param>
            <returns>A string that represents the Day with format "dd".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.HourString(System.DateTime)">
            <summary>
            Returns the Hour string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Hour string.</param>
            <returns>A string that represents the Hour with format "HH".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.MinuteString(System.DateTime)">
            <summary>
            Returns the Minute string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Minute string.</param>
            <returns>A string that represents the Minute with format "mm".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.SecondString(System.DateTime)">
            <summary>
            Returns the Second string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the Second string.</param>
            <returns>A string that represents the Second with format "ss".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.TenNanoSecondString(System.DateTime)">
            <summary>
            Returns the 10-nanoseconds string from the given DateTime value.
            </summary>
            <param name="dateTime">The DateTime value to get the 10-nanoseconds string.</param>
            <returns>A string that represents the nanoseconds in format "ffffff".</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.FloorTicks(System.DateTime)">
            <summary>
            Returns Floor Ticks of the given DateTime-value.
            </summary>
            <param name="dateTime">The DateTime-value to return the Ticks.</param>
            <returns>The Floor Ticks of the given DateTime-value.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.CeilingTicks(System.DateTime)">
            <summary>
            Returns Ceiling Ticks of the given DateTime-value.
            </summary>
            <param name="dateTime">The DateTime-value to return the Ticks.</param>
            <returns>The Ceiling Ticks of the given DateTime-value..</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.FormattedString(System.TimeSpan)">
            <summary>
            Get formatted string for timespan
            </summary>
            <param name="timeSpan">The timespan</param>
            <returns>Formatted string as '0d 00h 00m 00.000000 s'</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.DateTimeHelper.FormattedTimeDelta(System.DateTime,System.DateTime)">
            <summary>
            Formatted time delta
            </summary>
            <param name="timestamp">The timestamp</param>
            <param name="referenceTime">Reference timestamp</param>
            <returns>Formatted string of time delta. If reference timestamp is MinValue, it returns a empty string</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Helpers.XmlHelper">
            <summary>
            Helper for XML
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.CreateDocument">
            <summary>
            Create new xml document with default declaration
            </summary>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.CreateNode(System.Xml.XmlNode,System.String)">
            <summary>
            Create node in parent
            </summary>
            <param name="parent">parent node</param>
            <param name="name">node name</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.CreateNode(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            create node in parent with value
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.AddNodeAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Add attribute with value to node
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="attrValue"></param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.GetNodeValue(System.Xml.XmlElement)">
            <summary>
            Get node value
            </summary>
            <param name="node">node</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.SetNodeValue(System.Xml.XmlElement,System.String)">
            <summary>
            Set value of node
            </summary>
            <param name="node"></param>
            <param name="value"></param>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.FindNodes(System.Xml.XmlElement,System.String)">
            <summary>
            Find all nodes by name in parent node
            </summary>
            <param name="parent">parent node</param>
            <param name="name">node name</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.FindFirstNode(System.Xml.XmlElement,System.String)">
            <summary>
            Find first node by name in parent node
            </summary>
            <param name="parent">parent node</param>
            <param name="name">node name</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.FindNodes(System.Xml.XmlElement,System.String,System.String,System.String)">
            <summary>
            Find all nodes by name and attribute
            </summary>
            <param name="root"></param>
            <param name="name"></param>
            <param name="attributeName"></param>
            <param name="attributeValue"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Helpers.XmlHelper.FindLastNode(System.Xml.XmlElement,System.String)">
            <summary>
            
            </summary>
            <param name="root"></param>
            <param name="xpath"></param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.ETQueue`1">
            <summary>
            ET queue is a queue system of queues with items of T.
            It buffers the queues of items with count of MaxItemsPerQueue.
            The maximal count queues can be also limited with MaxQueues.
            Locking by enqueue item is minimized, during dequeuing the first queue to dequeue the items.
            </summary>
            <typeparam name="T">The type of item</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.ETQueue`1.MaxItemsPerQueue">
            <summary>
            Max items per queue
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETQueue`1.MaxQueues">
            <summary>
            Max queues of items
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETQueue`1.#ctor(System.Int32,System.Int32)">
            <summary>
            The constructor
            </summary>
            <param name="maxItemsPerQueue">Max items per queue</param>
            <param name="maxQueues">Max queues</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETQueue`1.Enqueue(`0)">
            <summary>
            Enqueue item
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="P:ET.FW.Core.Common.ETQueue`1.Count">
            <summary>
            Count of all items
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETQueue`1.Dequeue">
            <summary>
            Get current queue
            </summary>
            <returns>Current queue</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETQueue`1.WaitUntilEmpty">
            <summary>
            Blocks the caller thread, until queue is empty
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETQueue`1.Dispose">
            <summary>
            Shutdown this object:
            - Set disposed flag
            - Clear all queues and items
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.CommonErrorCodes">
            <summary>
            Enum for the CommonErrorCodes<para></para>
            CommonErrorCodes range from 1 to 255.<para></para>
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.MessageCorrupt">
            <summary>
            Message is corrupt, HW signalled errors in message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.MessageIncomplete">
            <summary>
            Message not complete
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.DestinationNotSet">
            <summary>
            Destination is not set
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.SourceNotSet">
            <summary>
            Source is not set
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.NoProtocol">
            <summary>
            No protocol
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.NoCatalog">
            <summary>
            No catalog
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.ExceptionOccured">
            <summary>
            An exception occured
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.WrongMessageType">
            <summary>
            Wrong message-type
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.WrongHwTimestamp">
            <summary>
            Wrong Hardware Timestamp
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.CommonErrorCodes.WrongValue">
            <summary>
            Wrong Value
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.CommonErrorDecoder">
            <summary>
            Decoder for common errors, i.e. errors in the value-range (0, 256)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.CommonErrorDecoder.Instance">
            <summary>
            The singleton-instance
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.CommonErrorDecoder.DecodeError(ET.FW.Core.Common.FrameworkError)">
            <summary>
            Fills the DefaultDescription of the given error.<para></para>
            Returns, whether the errorcode of the given error is known and the DefaultDescription
            could be set.<para></para>
            If DefaultDescription is already set, it is overwritten.
            </summary>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.CommonErrorDecoder.CreateCommonFrameworkError(ET.FW.Core.Common.CommonErrorCodes,System.String)">
            <summary>
            Creates a new FrameworkError for the given CommonErrorCode.<para></para>
            Returns the new created FrameworkError or null, if the given errorCode is not valid.
            </summary>
            <param name="errorCode">The CommonErrorCode for which a new FrameworkError shall be created.</param>
            <param name="additionalInfo">Additional Informations</param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.ComponentModelExtensions">
            <summary>
            Extensions to the ComponentModel namespace of .net
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ComponentModelExtensions.NotifyChanged``1(System.ComponentModel.PropertyChangedEventHandler,System.ComponentModel.INotifyPropertyChanged,``0@,``0,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Helper method to invoke a PropertyChanged event with equalization and setting of the internal value.
            </summary>
            <example>
            public object SelectedTreeItem
            {
               get { return selectedTreeItem; }
               set { PropertyChanged.NotifyChanged(this, ref selectedTreeItem, value, () => SelectedTreeItem); }
            }
            private object selectedTreeItem;
            </example>
            <typeparam name="TValue">Type of the property</typeparam>
            <param name="eventHandler">PropertyChangedEventHandler of the class</param>
            <param name="obj">Owner of changed property</param>
            <param name="propValue">internal property value</param>
            <param name="newValue">new value</param>
            <param name="propertyExpr">the access to the property as expression</param>
        </member>
        <member name="M:ET.FW.Core.Common.ComponentModelExtensions.NotifyChanged``1(System.ComponentModel.PropertyChangedEventHandler,System.ComponentModel.INotifyPropertyChanged,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Helper method to invoke a PropertyChanged event.
            </summary>
            <remarks>
            Method uses reflection to extract the property name from the given expression
            </remarks>
            <example>
            PropertyChanged.NotifyChanged(this, () => Presence);
            </example>
            <typeparam name="TValue">Type of the property</typeparam>
            <param name="eventHandler">PropertyChangedEventHandler of the class</param>
            <param name="obj">Owner of changed property</param>
            <param name="propertyExpr">the access to the property as expression</param>
        </member>
        <member name="M:ET.FW.Core.Common.ComponentModelExtensions.GetPropertySymbol``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Internal helper method to extract the Property Name as string.
            </summary>
            <typeparam name="TValue">Type of the property</typeparam>
            <param name="propertyExpr">the access to the property as expression</param>
            <returns>The name of the member as string</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ComponentModelExtensions.NotifyChanged(System.ComponentModel.PropertyChangedEventHandler,System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>
            Helper method to invoke a PropertyChanged event.
            </summary>
            <remarks>
            Method avoids the use of reflection to get the property name. Take care to update parameter value if property name is changed!
            </remarks>
            <example>
            PropertyChanged.NotifyChanged(this, "Presence");
            </example>
            <param name="eventHandler">PropertyChangedEventHandler of the class</param>
            <param name="obj">Owner of changed property</param>
            <param name="propertyName">ame of changed property</param>
        </member>
        <member name="T:ET.FW.Core.Common.DecimalHexTypeConverter">
            <summary>
            Provides a way to convert int values to hexadecimal representation.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.DecimalHexTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to
            the type of this converter, using the specified context.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="sourceType">A System.Type that represents the type you want to convert from.</param>
            <returns>true if this converter can perform the conversion; otherwise, false.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.DecimalHexTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type,
            using the specified context.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="destinationType">A System.Type that represents the type you want to convert to.</param>
            <returns>true if this converter can perform the conversion; otherwise, false.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.DecimalHexTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified
            context and culture information.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="culture">A System.Globalization.CultureInfo. If null is passed, the current culture is assumed.</param>
            <param name="value">The System.Object to convert.</param>
            <param name="destinationType">The System.Type to convert the value parameter to.</param>
            <returns>An System.Object that represents the converted value.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.DecimalHexTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="culture">The System.Globalization.CultureInfo to use as the current culture.</param>
            <param name="value"> The System.Object to convert.</param>
            <returns>An System.Object that represents the converted value.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.DisposabledList`1">
            <summary>
            List with IDisposable interface
            </summary>
            <typeparam name="T">Type of imtem</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.DisposabledList`1.Dispose">
            <summary>
            Dispose list
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.EnumExtensions">
            <summary>
            Helper class for enum extensions.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.GetName``1(``0)">
            <summary>
            Gets the enum name.
            </summary>
            <param name="value">The enum value.</param>
            <returns>The name string of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.SafeGetName``1(``0)">
            <summary>
            Safe gets the enum name.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="value">The enum value.</param>
            <returns>The name string of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.TryGetName``1(``0,System.String@)">
            <summary>
            Gets the enum name.
            </summary>
            <param name="value">The enum value.</param>
            <param name="name">The name string of the enum value</param>
            <returns>true if value is a valid enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.GetDescription``1(``0)">
            <summary>
            Gets the enum description attribute.
            </summary>
            <param name="value">The enum value.</param>
            <returns>The description string of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.SafeGetDescription``1(``0)">
            <summary>
            Safe gets the enum description attribute.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="value">The enum value.</param>
            <returns>The description string of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.TryGetDescription``1(``0,System.String@)">
            <summary>
            Gets the enum description attribute.
            </summary>
            <param name="value">The enum value.</param>
            <param name="description">The description string of the enum value</param>
            <returns>true if value is a valid enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.GetStringValue``1(``0)">
            <summary>
            Gets the StringValue attribute of the enum.
            </summary>
            <param name="value">The enum value.</param>
            <returns>The StringValue of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.SafeGetStringValue``1(``0)">
            <summary>
            Safe gets the StringValue attribute of the enum.
            If value is an invalid enum value, the value number as string will be returned
            </summary>
            <param name="value">The enum value.</param>
            <returns>The StringValue of the enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.TryGetStringValue``1(``0,System.String@)">
            <summary>
            Gets the StringValue attribute of the enum.
            </summary>
            <param name="value">The enum value.</param>
            <param name="stringValue">The StringValue of the enum value</param>
            <returns>true if value is a valid enum value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.TestOne``1(``0,``0)">
            <summary>
            Checks the bit field of two Enums for bits in both variables
            True if at least one bit matches
            </summary>
            <param name="state">the value</param>
            <param name="test">the pattern to test</param>
            <returns>True if at least one bit matches</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.EnumExtensions.TestAll``1(``0,``0)">
            <summary>
            Checks the bit field of two Enums for bits in both variables
            True if all bits in the pattern are set in the value
            </summary>
            <param name="state">the value</param>
            <param name="test">the pattern to test</param>
            <returns>True if all bits in the pattern are set in the value</returns>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="T:ET.FW.Core.Common.EnviromentState">
            <summary>
            The current state of the Enviroment
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.Online">
            <summary>
            Environment is online
            Enviroment has loaded and instantiate all configuration and is connected to Hardware
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.OfflineIdle">
            <summary>
            Environment is shut down
            Enviroment has no configuration and it is not connected to any Hardware
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.OfflineTrace">
            <summary>
            Offline environment is active (for import)
            Enviroment has loaded a configuration and instantiated all classes to handle the input off a trace file
            It is not connected to any Hardware
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.ChangingToOnline">
            <summary>
            Enviroment is in an unknown state. The target is the Online Mode
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.ChangingToOfflineIdle">
            <summary>
            Enviroment is in an unknown state. The target is the OfflineIdle Mode
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.EnviromentState.ChangingToOfflineTrace">
            <summary>
            Enviroment is in an unknown state. The target is the OfflineTrace Mode
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.ETList`1">
            <summary>
            ETList implementiert die IList-Interface und unterteilt die Items in mehreren Sublists,
            um Liste mit groen Datenmengen besser in kleinen segmentierten Speicher unterzubringen,
            mglichst ohne OutOfMemoryExcption auszulsen
            </summary>
            <typeparam name="T">Type of item</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the System.Collections.Generic.List class
            that contains elements copied from the specified collection and has sufficient
            capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
        </member>
        <member name="P:ET.FW.Core.Common.ETList`1.SublistMaxItem">
            <summary>
            Max item per sublist, default = 1000 items
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.GetListIndex(System.Int32,System.Int32@)">
            <summary>
            Gets the indexes of sublist and item index in sublist
            </summary>
            <param name="index">global index of item</param>
            <param name="itemIndex">Local index of item in the sublist</param>
            <returns>Index of sublist</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Insert(System.Int32,System.Int32,`0)">
            <summary>
            Inserts items to sublist with listIndex and itemIndex
            </summary>
            <param name="listIndex">Index of sublist</param>
            <param name="itemIndex">Local index of item in the sublist</param>
            <param name="item">The item</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.IndexOf(`0)">
            <summary>
            Bestimmt den Index eines bestimmten Elements in der System.Collections.Generic.IList.
            </summary>
            <param name="item">Das im System.Collections.Generic.IList zu suchende Objekt.</param>
            <returns>
            Der Index von item, wenn das Element in der Liste gefunden wird, andernfalls -1.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts item at index
            </summary>
            <param name="index">The index of item</param>
            <param name="item">The item</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.RemoveAt(System.Int32)">
            <summary>
            Remove item at index
            </summary>
            <param name="index">The index of item</param>
        </member>
        <member name="P:ET.FW.Core.Common.ETList`1.Item(System.Int32)">
            <summary>
            Get item at index
            </summary>
            <param name="index">The index of item</param>
            <returns>The item</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Add(`0)">
            <summary>
            Add item at the end of list
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Clear">
            <summary>
            Clear all items
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Contains(`0)">
            <summary>
            is item contain in list
            </summary>
            <param name="item">The item</param>
            <returns>True if item contains in list</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy all items to array
            </summary>
            <param name="array">Array to copy to</param>
            <param name="arrayIndex">First index of array to copy to</param>
        </member>
        <member name="P:ET.FW.Core.Common.ETList`1.Count">
            <summary>
            Count of items
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETList`1.IsReadOnly">
            <summary>
            Is read only
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.Remove(`0)">
            <summary>
            Remove item
            </summary>
            <param name="item">The item</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.GetEnumerator">
            <summary>
            Gets Enumerator
            </summary>
            <returns>The Enumerator</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets Enumerator
            </summary>
            <returns>The Enumerator</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.TrimExcess">
            <summary>
            Legt die Kapazitt auf die Anzahl der tatschlich in der List befindlichen Elemente fest, sofern diese Anzahl unter dem Schwellenwert liegt.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Entfernt einen Bereich von Elementen aus der List.
            </summary>
            <param name="index">The first index of range</param>
            <param name="count">Count of item</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETList`1.RemoveRange(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Entfernt einen Bereich von Elementen aus der List.
            </summary>
            <param name="listIndex">Start index of sublist</param>
            <param name="itemIndex">Start index of item in sublist</param>
            <param name="count">Count of item</param>
        </member>
        <member name="T:ET.FW.Core.Common.Evaluate.Evaluator">
            <summary>
            Class to build up and compile an assembly that
            does evaluate something the user can give as expression.<para></para>
            It is recommended to create an instance if the same evaluation shall be performed
            several times, as the static-methods require more time - a new Evaluator is created for each call.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.#ctor(ET.FW.Core.Common.Evaluate.EvaluatorItem[])">
            <summary>
            The Constructor
            </summary>
            <param name="items">The items describing the evaluation.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.#ctor(System.Type,System.Type,System.String,System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="inputType">Type of the input value.</param>
            <param name="returnType">Type of the return value.</param>
            <param name="expression">The expression.</param>
            <param name="name">The name, which has to be passed to the instance-methods to adress the function.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.#ctor(System.Type,System.String,System.String)">
            <summary>
            The Constructor with default inputType == Int64.
            </summary>
            <param name="returnType">Type of the return value.</param>
            <param name="expression">The expression.</param>
            <param name="name">The name, which has to be passed to the instance-methods to adress the function.</param>
            <remarks>
            The type of the input value is set to int.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.#ctor(ET.FW.Core.Common.Evaluate.EvaluatorItem)">
            <summary>
            The Constructor
            </summary>
            <param name="item">The item describing the evaluation.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.ConstructEvaluator(ET.FW.Core.Common.Evaluate.EvaluatorItem[])">
            <summary>
            Constructs the evaluator, i.e. builds up SourceCode with a function for each item and compiles the code,
            so the function(s) can be used.
            </summary>
            <param name="items">The items describing the evaluation. For each item one function is created.</param>
            <exception cref="T:System.Exception">An Exception which might be thrown for several reasons: No items passed, items with invalid contents,...</exception>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateDouble(System.String,System.Double)">
            <summary>
            Evaluates the double.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a double</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateInt(System.String,System.Double)">
            <summary>
            Evaluates the int.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a int64</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateString(System.String,System.Double)">
            <summary>
            Evaluates the string.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a string</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateBool(System.String,System.Double)">
            <summary>
            Evaluates the bool.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a bool</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.Evaluate(System.String,System.Double)">
            <summary>
            Evaluates the specified function name.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a object</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateOtoO(System.String,System.Object)">
            <summary>
            Evaluates the specified function name.<para></para>
            This Evaluate-method is for all inputs not being an int or double.
            </summary>
            <param name="name">The name of the function used.</param>
            <param name="x">The value which is evaluated.</param>
            <returns>a object</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateDouble(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to double
            </summary>
            <param name="name">The name.</param>
            <param name="x">The x.</param>
            <returns>a double</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateInt(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to Int64
            </summary>
            <param name="name">The name.</param>
            <param name="x">The x.</param>
            <returns>a int64</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateString(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to string
            </summary>
            <param name="name">The name.</param>
            <param name="x">The x.</param>
            <returns>a string</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateBool(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to bool
            </summary>
            <param name="name">The name.</param>
            <param name="x">The x.</param>
            <returns>a bool</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.Evaluate(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to unspecified object
            </summary>
            <param name="name">The name.</param>
            <param name="x">The x.</param>
            <returns>a object</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateToDouble(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to double
            </summary>
            <param name="code">The code, i.e. the expression.</param>
            <param name="x">The x.</param>
            <returns>a double</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateToInteger(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to Int64
            </summary>
            <param name="code">The code, i.e. the expression.</param>
            <param name="x">The x.</param>
            <returns>a int64</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateToString(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to string
            </summary>
            <param name="code">The code, i.e. the expression.</param>
            <param name="x">The x.</param>
            <returns>
            a string
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateToBool(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to bool
            </summary>
            <param name="code">The code, i.e. the expression.</param>
            <param name="x">The x.</param>
            <returns>a bool </returns>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.Evaluator.EvaluateToObject(System.String,System.Int64)">
            <summary>
            Evaluate Int64 to object
            </summary>
            <param name="code">The code, i.e. the expression.</param>
            <param name="x">The x.</param>
            <returns>a object</returns>
        </member>
        <member name="T:ET.FW.Core.Common.Evaluate.EvaluatorItem">
            <summary>
            EvaluatorItem is describing one function of the evaluator,
            i.e. the type of the input, the type of the returned object, the expression of the evaluation an
            the name to address the function in the evaluator created with the item.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.ReturnType">
            <summary>
            The Type the evaluation-function (i.e. the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression"/>) created for this item returns.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Name">
            <summary>
            The Name which is later used to address the function created for this item.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression">
            <summary>
            The expression, i.e. the code-snippet which is the content of the function.<para></para>
            The Expression must process an "x"-variable of the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.InputType"/> and return a value 
            of the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.ReturnType"/>.<para></para>
            For Example for an expression checking, whether the input equals 0:<para></para>
            InputType = typeof(int);<para></para>
            ReturnType = typeof(bool);<para></para>
            Expression = "x == 0";<para></para>
            Name = "IsZero";<para></para>
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.InputType">
            <summary>
            The Type of the object passed to the evaluation-function (i.e. the Type of the x in the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression"/>).
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.EvaluatorItem.#ctor(System.Type,System.Type,System.String,System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="inputType">The Type of the object passed to the evaluation-function (i.e. the Type of the x in the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression"/>).</param>
            <param name="returnType">The Type the evaluation-function (i.e. the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression"/>) created for this item returns.</param>
            <param name="expression">The expression.</param>
            <param name="name">The Name which is later used to address the function created for this item.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Evaluate.EvaluatorItem.#ctor(System.Type,System.String,System.String)">
            <summary>
            The Constructor for an Int64-input.
            </summary>
            <param name="returnType">The Type the evaluation-function (i.e. the <see cref="P:ET.FW.Core.Common.Evaluate.EvaluatorItem.Expression"/>) created for this item returns.</param>
            <param name="expression">The expression.</param>
            <param name="name">The Name which is later used to address the function created for this item.</param>
            <remarks>
            The type of the input value is set to int by default.
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Common.FileReadWrapper">
            <summary>
            File wrapper implementation for files which exist in the file system
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FileReadWrapper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.FileReadWrapper"/> class.
            </summary>
            <param name="fullPath">The full path to an existing file.</param>
        </member>
        <member name="P:ET.FW.Core.Common.FileReadWrapper.Content">
            <summary>
            Gets the content as readable stream.
            </summary>
            <remarks>
            A new stream instance is created on each access, caller should dispose stream after usage
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Common.FileReadWrapper.FullPath">
            <summary>
            Gets the full path of the file (if available)
            </summary>
            <value>
            The full path if available, otherwise null
            </value>
        </member>
        <member name="P:ET.FW.Core.Common.FileReadWrapper.Name">
            <summary>
            Gets the file name including extension.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FileReadWrapper.Exists">
            <summary>
            Flag indicates if file exists
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FileReadWrapper.FileAvailable">
            <summary>
            Flag indicates if file is available for file operations (e.g. FALSE for files inside ZIP-archive)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FileReadWrapper.CopyTo(System.String)">
            <summary>
            Copies the wrapped file to the given path
            </summary>
            <param name="destinationPath">The destination path (including file name)</param>
            <returns>TRUE on success</returns>
            <remarks>If the destination directory does not exist, it is created</remarks>
        </member>
        <member name="T:ET.FW.Core.Common.FrameworkError">
            <summary>
            Object which represents an error<para></para>
            Cannot be serialized.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.#ctor">
            <summary>
            Constructor of a Framework error
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.#ctor(System.UInt32)">
            <summary>
            Constructor of a frameworrk error
            </summary>
            <param name="kind">error number</param>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.#ctor(System.UInt32,System.String)">
            <summary>
            Constructor with kind (which is the error number) and additional info
            </summary>
            <param name="kind">The Kind of the error.</param>
            <param name="additionalInfo">Extended textual description of the error</param>
        </member>
        <member name="P:ET.FW.Core.Common.FrameworkError.ErrorKind">
            <summary>
            The kind of the error.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FrameworkError.AdditionalInfo">
            <summary>
            The textual description of the error which should be filled with some extended informations like measured values.<para></para>
            Intended to be serialized in derived classes.<para></para>
            ErrorDescription maybe null or empty, if not set, so use string.IsNullOrEmpty to determine, whether it is empty.<para></para>
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FrameworkError.ErrorDescription">
            <summary>
            Property which should be filled with a description
            according to the errrorkind.<para></para>
            Intended not be be serialized in derived classes.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FrameworkError.SubErrors">
            <summary>
            Errors being part of this error.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.Clone">
            <summary>
            Clones this FrameworkError and all SubErrors.
            </summary>
            <returns>the cloned object</returns>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.ToString">
            <summary>
            ToString(). Description without childrens' descriptions
            </summary>
            <returns>description of this error with additional information</returns>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.ToFullString">
            <summary>
            ToFullString(). Description with childrens' descriptions
            </summary>
            <returns>String with all the errors and sub-errrors in a "tree" by usings tabs and newlines</returns>
        </member>
        <member name="M:ET.FW.Core.Common.FrameworkError.ToFullString(System.Int32)">
            <summary>
            ToFullString(). Description with childrens' descriptions
            </summary>
            <param name="recursion">recursion in suberrors</param>
            <returns>String with all the errors and sub-errrors in a "tree" by usings tabs and newlines</returns>
        </member>
        <member name="T:ET.FW.Core.Common.FreeDiskSpaceGuard">
            <summary>
            This class offers a guard observing the free space on a disk.<para></para>
            Additionally it offers some static helper-methods.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.FreeDiskSpaceGuard.NodeAppSettingsDiskSpaceAtStartGB">
            <summary>
            Name of the AppSettings node with the DiskSpaceAtStartGB-value
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.FreeDiskSpaceGuard.NodeAppSettingsAutoOfflineMB">
            <summary>
            Name of the AppSettings node with the AutoOfflineMB-value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.DiskSpaceAtStartGB">
            <summary>
            The setting for the recommended available disk space when going online.<para></para>
            0 or less means: check is disabled.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.AutoOfflineMB">
            <summary>
            The minimum-level of required disk-space. If online and the disk where the trace is written to has less available space, 
            the system automatically triggers to go offline.<para></para>
            0 or less to disable.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.GetDriveInfo(System.String)">
            <summary>
            Returns DriveInfo of the disk the path belongs to.<para></para>
            UNC-paths are not supported.
            </summary>
            <param name="pathToCheck">The path or disk-id (like c:) to check.</param>
            <returns>The found drive-info. If null would be returned, an exception is thrown.</returns>
            <exception cref="T:System.ArgumentException">Thrown if path is null or empty or does not start with a drive-letter followed by ':' or the drive is not ready or not existing.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown if the required Drive-informations cannot be accessed due to missing authorizations.</exception>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.GetFreeDiskGB(System.String)">
            <summary>
            Returns the free disk space in GB of the disk the path belongs to.<para></para>
            UNC-paths are not supported.
            </summary>
            <param name="pathToCheck">The path or disk-id (like c:) to check.</param>
            <returns>The available space in gb.</returns>
            <exception cref="T:System.ArgumentException">Thrown if path is null or empty or does not start with a drive-letter followed by ':' or the drive is not ready or not existing.</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown if the required Drive-informations cannot be accessed due to missing authorizations.</exception>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.Path">
            <summary>
            The path passed when creating this guard.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.WarnOnLessMBThan">
            <summary>
            The warning-level.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.#ctor(System.String,System.TimeSpan,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.FreeDiskSpaceGuard"/> class.
            </summary>
            <param name="path">The path whose drive shall be observed..</param>
            <param name="refreshInterval">The refresh interval.</param>
            <param name="warnOnLessMBThan">The warn on less mb than.</param>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.DidRaiseError">
            <summary>
            Set to TRUE of the warning level has been reached and the event has been raised.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.RaiseError">
            <summary>
            Inform the warning-level has been reached.
            </summary>
        </member>
        <member name="E:ET.FW.Core.Common.FreeDiskSpaceGuard.ReachedWarningLevel">
            <summary>
            This event becomes raised, if the warning-level has been reached, i.e. 
            less disk-space than the defined waring-level is available.<para></para>
            The guard stops itself, after this event has been raised. <para></para>
            DidRaiseError is set to true.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.ObservingProc">
            <summary>
            The Thread-procedure doing the observation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.Start">
            <summary>
            Start object
            </summary>
            <returns>
              <c>true</c>, if successful
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.FreeDiskSpaceGuard.Stop">
            <summary>
            Stop object
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.FreeDiskSpaceGuard.IsRunning">
            <summary>
            Indicates if the object is started and still runs
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.ETString">
            <summary>
            String helper
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.IsNullOrEmpty(ET.FW.Core.Common.ETString)">
            <summary>
            is ETString null or empty
            </summary>
            <param name="value">The ETString object to check.</param>
            <returns><c>true</c> if the ETString object is null or Empty; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Implicit(System.String)~ET.FW.Core.Common.ETString">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:ET.FW.Core.Common.ETString"/>.
            </summary>
            <param name="value">the string value</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Implicit(System.Int32)~ET.FW.Core.Common.ETString">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Int32"/> to <see cref="T:ET.FW.Core.Common.ETString"/>.
            </summary>
            <param name="value">A int value to convert to string.</param>
            <returns>A string that represents the int.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Implicit(ET.FW.Core.Common.ETString)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:ET.FW.Core.Common.ETString"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="value">the etstring</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,ET.FW.Core.Common.ETString)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The first ETString object.</param>
            <param name="b">The second ETString object.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Boolean)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A bool value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Byte)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A byte value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Char)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A char value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Char[])">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A char[] value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Decimal)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A decimal value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Double)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A double value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Int16)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A short value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Int32)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A int value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Int64)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A long value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Object)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">A object value</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.SByte)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.Single)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.String)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.UInt16)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.UInt32)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.op_Addition(ET.FW.Core.Common.ETString,System.UInt64)">
            <summary>
            Implements the operator +.<para></para>
            Please regard: The returned EtString is a, internally a += is performed.
            </summary>
            <param name="a">The ETString object.</param>
            <param name="b">The second value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="P:ET.FW.Core.Common.ETString.Builder">
            <summary>
            String builder, that builds the ETString
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETString.Length">
            <summary>
            Length of string
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.ETString"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.ETString"/> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.GetHashCode">
            <summary>
            Serves as a hash function for the ETString type. 
            </summary>
            <returns>A hash code for the current ETString object.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Equals(System.String,System.StringComparison)">
            <summary>
            Determines whether this string and a specified String object have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.
            </summary>
            <param name="value">The string to compare to this instance.</param>
            <param name="comparisonType">One of the enumeration values that specifies how the strings will be compared.</param>
            <returns><c>true</c> if the value of the value parameter is the same as this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Remove(System.Int32)">
            <summary>
            Deletes all the characters from this string beginning at a specified position and continuing through the last position.
            </summary>
            <param name="startIndex">The zero-based position to begin deleting characters.</param>
            <returns>A new string that is equivalent to this string except for the removed characters.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Remove(System.Int32,System.Int32)">
            <summary>
            Deletes a specified number of characters from this instance beginning at a specified position.
            </summary>
            <param name="startIndex">The zero-based position to begin deleting characters.</param>
            <param name="count">The number of characters to delete.</param>
            <returns>A new string that is equivalent to this instance except for the removed characters.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Replace(System.String,System.String)">
            <summary>
            Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.
            </summary>
            <param name="oldValue">The string to be replaced.</param>
            <param name="newValue">The string to replace all occurrences of <c>oldValue</c>.</param>
            <returns>A string that is equivalent to the current string except that all instances of <c>oldValue</c> are replaced with <c>newValue</c>.</returns>
            <remarks>
            If <c>newValue</c> is <c>null</c>, all occurrences of <c>oldValue</c> are removed.<para/>
            This method performs an ordinal (case-sensitive and culture-insensitive) search to find <c>oldValue</c>.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Replace(System.Char,System.Char)">
            <summary>
            Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.
            </summary>
            <param name="oldChar">The Unicode character to be replaced.</param>
            <param name="newChar">The Unicode character to replace all occurrences of <c>oldChar</c>.</param>
            <returns>A string that is equivalent to this instance except that all instances of <c>oldChar</c> are replaced with <c>newChar</c>.</returns>
            <remarks>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <c>oldChar</c>.</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position.
            </summary>
            <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
            <returns>A string that is equivalent to the substring that begins at <c>startIndex</c> in this instance, or <c>Empty</c> if <c>startIndex</c> is equal to the length of this instance.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Substring(System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.
            </summary>
            <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>
            A string that is equivalent to the substring of length <c>length</c> that begins at <c>startIndex</c> in this instance, 
            or <c>Empty</c> if <c>startIndex</c> is equal to the length of this instance and <c>length</c> is zero.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.StartsWith(System.String)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string.
            </summary>
            <param name="value">The string to compare.</param>
            <returns><c>true</c> if value matches the beginning of this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.StartsWith(System.String,System.StringComparison)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.
            </summary>
            <param name="value">The string to compare.</param>
            <param name="comparisonType">One of the enumeration values that determines how this string and <c>value</c> are compared.</param>
            <returns><c>true</c> if value matches the beginning of this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.
            </summary>
            <param name="value">The string to compare.</param>
            <param name="ignoreCase"><c>true</c> to ignore case during the comparison; otherwise, <c>false</c>.</param>
            <param name="culture">Cultural information that determines how this string and value are compared. If culture is <c>null</c>, the current culture is used.</param>
            <returns><c>true</c> if value matches the beginning of this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Contains(System.String)">
            <summary>
            Returns a value indicating whether the specified String object occurs within this string.
            </summary>
            <param name="value">The string to seek.</param>
            <returns><c>true</c> if the value parameter occurs within this string, or if value is the empty string (""); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.EndsWith(System.String)">
            <summary>
            Determines whether the end of this string instance matches the specified string.
            </summary>
            <param name="value">The string to compare to the substring at the end of this instance.</param>
            <returns><c>true</c> if value matches the end of this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.EndsWith(System.String,System.StringComparison)">
            <summary>
            Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.
            </summary>
            <param name="value">The string to compare to the substring at the end of this instance.</param>
            <param name="comparisonType">One of the enumeration values that determines how this string and value are compared.</param>
            <returns><c>true</c> if value matches the end of this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Determines whether the end of this string instance matches the specified string when compared using the specified culture.
            </summary>
            <param name="value">The string to compare to the substring at the end of this instance.</param>
            <param name="ignoreCase"><c>true</c> to ignore case during the comparison; otherwise, <c>false</c>.</param>
            <param name="culture">Cultural information that determines how this string and value are compared. If culture is <c>null</c>, the current culture is used.</param>
            <returns><c>true</c> if value matches the beginning of this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Trim">
            <summary>
            Removes all leading and trailing white-space characters from the current ETString object.
            </summary>
            <returns>The string that remains after all white-space characters are removed from the start and end of the current ETString.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Trim(System.Char[])">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified in an array from the current ETString object.
            </summary>
            <param name="trimChars">An array of Unicode characters to remove, or <c>null</c>.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars parameter 
            are removed from the start and end of the current ETString. If trimChars is <c>null</c> or 
            an empty array, white-space characters are removed instead.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.TrimEnd(System.Char[])">
            <summary>
            Removes all trailing occurrences of a set of characters specified in an array from the current ETString object.
            </summary>
            <param name="trimChars">An array of Unicode characters to remove, or <c>null</c>.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars parameter 
            are removed from the start and end of the current ETString. If trimChars is <c>null</c> or 
            an empty array, white-space characters are removed instead.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.TrimStart(System.Char[])">
            <summary>
            Removes all leading occurrences of a set of characters specified in an array from the current ETString object.
            </summary>
            <param name="trimChars">An array of Unicode characters to remove, or <c>null</c>.</param>
            <returns>
            The string that remains after all occurrences of the characters in the trimChars parameter 
            are removed from the start and end of the current ETString. If trimChars is <c>null</c> or 
            an empty array, white-space characters are removed instead.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToUpper">
            <summary>
            Returns a copy of this string converted to uppercase.
            </summary>
            <returns>The uppercase equivalent of the current string.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToUpper(System.Globalization.CultureInfo)">
            <summary>
            Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.
            </summary>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <returns>The uppercase equivalent of the current string.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToUpperInvariant">
            <summary>
            Returns a copy of this ETString object converted to uppercase using the casing rules of the invariant culture.
            </summary>
            <returns>The uppercase equivalent of the current string.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToLower">
            <summary>
            Returns a copy of this string converted to lowercase.
            </summary>
            <returns>A string in lowercase.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToLower(System.Globalization.CultureInfo)">
            <summary>
            Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.
            </summary>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <returns>The lowercase equivalent of the current string.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.ToLowerInvariant">
            <summary>
            Returns a copy of this ETString object converted to lowercase using the casing rules of the invariant culture.
            </summary>
            <returns>The lowercase equivalent of the current string.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Equals(System.String)">
            <summary>
            Determines whether this instance and another specified <see cref="T:String"/> object have the same value.
            </summary>
            <param name="other">The string to compare to this instance.</param>
            <returns><c>true</c> if the value of the value parameter is the same as this string; otherwise, <c>false</c>.</returns>
        </member>
        <member name="F:ET.FW.Core.Common.ETString.disposed">
            <summary>
            Flag is set when this object is disposed
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Dispose(System.Boolean)">
            <summary>
            Dispose method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ET.FW.Core.Common.ETString.Dispose">
            <summary>
            Dispose finialize method.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.IErrorDecoder">
            <summary>
            Interface for ErrorDecoders, filling the ErrorDescription of
            FrameworkErrors.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IErrorDecoder.DecodeError(ET.FW.Core.Common.FrameworkError)">
            <summary>
            Fills the ErrorDescription of the given error according to
            the set Errorkind. Returns FALSE if the error could not be decoded.
            </summary>
            <param name="error">The error to decode</param>
            <returns>Returns FALSE if the error could not be decoded.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IFileReadWrapper">
            <summary>
            Interface for read access to files which might be zipped
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IFileReadWrapper.Content">
            <summary>
            Gets the file content as readable stream.
            </summary>
            <remarks>
            A new stream instance is created on each access, caller should dispose stream after usage
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Common.IFileReadWrapper.FullPath">
            <summary>
            Gets the full path of the file (if available)
            </summary>
            <value>
            The full path if available, otherwise null
            </value>
        </member>
        <member name="P:ET.FW.Core.Common.IFileReadWrapper.Name">
            <summary>
            Gets the file name including extension.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IFileReadWrapper.Exists">
            <summary>
            Flag indicates if file exists
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IFileReadWrapper.FileAvailable">
            <summary>
            Flag indicates if file is available for file operations (e.g. FALSE for files inside ZIP-archive)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IFileReadWrapper.CopyTo(System.String)">
            <summary>
            Copies the wrapped file to the given path
            </summary>
            <param name="destinationPath">The destination path (including file name)</param>
            <returns>TRUE on success</returns>
            <remarks>If the destination directory does not exist, it is created</remarks>
        </member>
        <member name="T:ET.FW.Core.Common.IInvalidable">
            <summary>
            Interface for invalid object
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IInvalidable.IsInvalid">
            <summary>
            Is object invalid
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.IObservableStartable">
            <summary>
            Interface for startable objects with observable running state
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IObservableStartable.IsRunning">
            <summary>
            Observable running state, which indicates whether this instance is started and still running.
            </summary>
            <value>
            TRUE if object is running
            </value>
        </member>
        <member name="T:ET.FW.Core.Common.IPAddressTypeConverter">
            <summary>
            Type converter for IPAddress data type (used e.g. for parameter parsing)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IPAddressTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to
            the type of this converter, using the specified context.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="sourceType">A System.Type that represents the type you want to convert from.</param>
            <returns>true if this converter can perform the conversion; otherwise, false.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IPAddressTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type,
            using the specified context.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="destinationType">A System.Type that represents the type you want to convert to.</param>
            <returns>true if this converter can perform the conversion; otherwise, false.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IPAddressTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified
            context and culture information.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="culture">A System.Globalization.CultureInfo. If null is passed, the current culture is assumed.</param>
            <param name="value">The System.Object to convert.</param>
            <param name="destinationType">The System.Type to convert the value parameter to.</param>
            <returns>An System.Object that represents the converted value.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IPAddressTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An System.ComponentModel.ITypeDescriptorContext that provides a format context.</param>
            <param name="culture">The System.Globalization.CultureInfo to use as the current culture.</param>
            <param name="value"> The System.Object to convert.</param>
            <returns>An System.Object that represents the converted value.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IPExtension">
            <summary>
            Extension Method for IP
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IPExtension.ConvertIPTOMACAddress(System.String)">
            <summary>
            Convert IP TO MAC
            </summary>
            <param name="ipAddress">Ip Address</param>
            <returns>Mac in Byte Array</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1">
            <summary>
            Read only collection of named objects which can be accessed by names
            </summary>
            <typeparam name="T">type of the objects to collect (needs the INamedObject interface)</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
            <value>
            The number of elements contained in the collection.
            </value>
        </member>
        <member name="P:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the collection.</exception>
        </member>
        <member name="M:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the collection
            </summary>
            <param name="item">The object to locate in the collection.</param>
            <returns>The index of item if found in the collection; otherwise, -1.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.Contains(System.String)">
            <summary>
            Check if object with given name is already stored in collection
            </summary>
            <param name="name">name to find</param>
            <returns>true if object with given name is found in collection</returns>
        </member>
        <member name="P:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.Item(System.String)">
            <summary>
            Easy to use read access to collection, which does not throw an exception if the given key is not found
            </summary>
            <param name="name">name of item</param>
            <returns>Item with given name or null if item cannot be found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IReadOnlyNamedObjectCollection`1.TryGetValue(System.String,`0@)">
            <summary>
            Tries to get item with given name from collection.
            </summary>
            <param name="name">Item name.</param>
            <param name="item">Item with given name or null if item cannot be found</param>
            <returns>true, if item was found, otherwise false</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IResetable">
            <summary>
            Reset to Initial State
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IResetable.Reset">
            <summary>
            Resets this instance to Intial state.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.WindowFlags">
            <summary>
            Flags used for adjustment of window display for test jobs etc.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.WindowFlags.Floating">
            <summary> Window is displayed as floating (non modal) window </summary>
        </member>
        <member name="F:ET.FW.Core.Common.WindowFlags.Tab">
            <summary> Window is displayed on a new tab inside the GUI </summary>
        </member>
        <member name="T:ET.FW.Core.Common.IWindowHandlingWpf">
            <summary>
            Interface definition for service which provides access to GUI windows 
            and provides functions for windowe handling of test jobs ore services
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingWpf.ShowWindow(System.String,System.Windows.FrameworkElement)">
            <summary>
            Open a window containing the given WPF based user control
            Use CloseWindow() to "Close" the control. CreateControl is executed in GUI thread context.
            </summary>
            <param name="title">The title.</param>
            <param name="control">the control returned from createControl</param>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingWpf.ShowWindow(System.String,System.Windows.FrameworkElement,ET.FW.Core.Common.WindowFlags,System.Boolean)">
            <summary>
            Open a windows forms based window in GUI context for a WPF FrameworkElement (Control)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingWpf.ShowWindow(System.String,System.Func{System.Windows.FrameworkElement})">
            <summary>
            Open a window containing the given WPF based user control
            Use CloseWindow() to "Close" the control. CreateControl is executed in GUI thread context.
            </summary>
            <param name="title">The title.</param>
            <param name="createControl">a delegate returning a WPF control</param>
            <returns>the new control</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingWpf.ShowWindow(System.String,System.Func{System.Windows.FrameworkElement},ET.FW.Core.Common.WindowFlags,System.Boolean)">
            <summary>
            Open a windows forms based window in GUI context for a WPF FrameworkElement (Control)
            Delegate is called in GUI thread context and must return a FrameworkElement object.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingWpf.CloseWindow(System.Windows.FrameworkElement)">
            <summary>
            Close windows forms based window (which was formerly shown using ShowWindow) 
            </summary>
            <param name="control">window to close</param>
            <returns>true on success</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IWindowHandling">
            <summary>
            Interface definition for service which provides access to GUI windows 
            and provides functions for windowe handling of test jobs ore services
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandling.ShowWindow(System.String,System.Windows.Forms.Control)">
            <summary>
            Open a windows forms based window in GUI context
            </summary>
            <param name="title">The title.</param>
            <param name="control">window to show</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandling.ShowWindow(System.String,System.Windows.Forms.Control,ET.FW.Core.Common.WindowFlags,System.Boolean)">
            <summary>
            Open a windows forms based window in GUI context for a WinForms Control
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandling.ShowWindow(System.String,System.Func{System.Windows.Forms.Control})">
            <summary>
            Open a windows forms based window in GUI context. Use this for WinForms forms and UserControls
            Use CloseWindow() to "Close" the control. CreateControl is executed in GUI thread context.
            </summary>
            <param name="title">The title.</param>
            <param name="createControl">a delegate returning a WinForm control</param>
            <returns>the new control</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandling.ShowWindow(System.String,System.Func{System.Windows.Forms.Control},ET.FW.Core.Common.WindowFlags,System.Boolean)">
            <summary>
            Open a windows forms based window in GUI context for a WinForms Control
            Delegate is called in GUI thread context and must return a control object.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandling.CloseWindow(System.Windows.Forms.Control)">
            <summary>
            Close windows forms based window (which was formerly shown using ShowWindow) 
            </summary>
            <param name="control">window to close</param>
            <returns>true on success</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IWindowHandlingThreading">
            <summary>
            Interface definition for service which provides access to GUI windows 
            and provides functions for windowe handling of test jobs ore services
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingThreading.BeginAction(System.Action)">
            <summary>
            Perform given action asynchronously in thread context of application GUI
            </summary>
            <param name="action">action to be performed</param>
            <example>
            Set textbox tb text to "New text"
            <code>
            //C#2.0 syntax:
            BeginAction(delegate() { tb.Text = "New text"; } );
            
            //C#3.0 syntax:
            BeginAction( () => tb.Text = "New text" );
            </code></example>
            <remarks>If action has to be executed in another thread, it is performed asynchronously!</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingThreading.InvokeIfRequired(System.Action)">
            <summary>
            Perform given action synchronously in thread context of application GUI
            </summary>
            <param name="action">action to be performed</param>
            <example>
            Set textbox tb text to "New text"
            <code>
            //C#2.0 syntax:
            InvokeIfRequired(delegate() { tb.Text = "New text"; } );
            
            //C#3.0 syntax:
            InvokeIfRequired( () => tb.Text = "New text" );
            </code></example>
        </member>
        <member name="M:ET.FW.Core.Common.IWindowHandlingThreading.InvokeIfRequired``1(System.Func{``0})">
            <summary>
            Execute given function synchronously in thread context of application GUI
            </summary>
            <typeparam name="TResult">Type of given function return value</typeparam>
            <param name="function">function to be called</param>
            <returns>return value of given function</returns>
            <example>
            Read text from textbox tb into result string
            <code>
            //C#2.0 syntax:
            string result = xxx.InvokeIfRequired(delegate() { return tb.Text; } );
            
            //C#3.0 syntax:
            strin result = xxx.InvokeIfRequired( () => tb.Text );
            </code></example>
        </member>
        <member name="T:ET.FW.Core.Common.LinqExtensions">
            <summary>
            Extensions for arrays
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.LinqExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs the specified action on each element <typeparamref name="T"/> of the enumeration.
            </summary>
            <typeparam name="T">The type of the elements of the enumeration.</typeparam>
            <param name="source">The enumeration.</param>
            <param name="action">The action to perform on each element of the enumeration.</param>
        </member>
        <member name="T:ET.FW.Core.Common.Decoupler`1">
            <summary>
            Decoupler queues incoming objects and signals them asynchronously via Output event
            </summary>
            <typeparam name="T">Type of object to be decoupled/queued</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.Decoupler`1.MaxQueueSize">
            <summary>
            Max. queue size.
            </summary>
            <remarks>
            If the message count in the queue is reached with this size, the input methode is blocked, until a message is dequeued.
            Default size = int.MaxValue.
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Common.Decoupler`1.ObjectHandler">
            <summary>
            Delegate for transport of object
            </summary>
            <param name="obj">object to transport</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.#ctor(ET.FW.Core.Common.Decoupler{`0}.ObjectHandler,System.String,System.Threading.ThreadPriority,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            </summary>
            <param name="output">Output delegate called for each object</param>
            <param name="name">Decoupler (thread) name</param>
            <param name="priority">Thread priority for decoupler</param>
            <param name="maxQueueSize">Max. queue size</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.#ctor(ET.FW.Core.Common.Decoupler{`0}.ObjectHandler,System.String,System.Threading.ThreadPriority)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            </summary>
            <param name="output">Output delegate called for each object</param>
            <param name="name">Decoupler (thread) name</param>
            <param name="priority">Thread priority for decoupler</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.#ctor(ET.FW.Core.Common.Decoupler{`0}.ObjectHandler,System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            </summary>
            <param name="output">Output delegate called for each object</param>
            <param name="name">Decoupler (thread) name</param>
            <param name="maxQueueSize">Max. queue size</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.#ctor(ET.FW.Core.Common.Decoupler{`0}.ObjectHandler,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            </summary>
            <param name="output">Output delegate called for each object</param>
            <param name="name">Decoupler (thread) name</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.#ctor(ET.FW.Core.Common.Decoupler{`0}.ObjectHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            </summary>
            <param name="output">Output delegate called for each object</param>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.Input(`0)">
            <summary>
            Input method for new message to be decoupled
            </summary>
            <param name="obj">object to be decoupled</param>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.output">
            <summary>
            Message output delegate
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.StartThread">
            <summary>
            Start event handling thread
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Decoupler`1.HasMessages">
            <summary>
            Check if messages are waiting in queue
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.queue">
            <summary>
            Message queue
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.outputThread">
            <summary>
            Event handling thread
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.newObjectEvent">
            <summary>
            Synchronization object to wake up event handling thread, as soon as new messages are enqueued
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.notFullQueueEvent">
            <summary>
            Synchronization object to wake up input thread, after the queue is not full
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.emptyQueueEvent">
            <summary>
            Synchronization object to wake up caller thread, after the queue is empty
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Decoupler`1.disposed">
            <summary>
            Flag is set when this object is disposed
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.ThreadProc">
            <summary>
            Message handling thread:
            - Wait for new object in queue
            - Dequeue object
            - Call output delegate
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.WaitUntilEmpty">
            <summary>
            Blocks the caller thread, until queue is empty
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.Dispose">
            <summary>
            Shutdown this object:
            - Set disposed flag
            - Clear event queue
            - Stop event handling thread
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Decoupler`1.Finalize">
            <summary>
            Finalizes an instance of the <see cref="T:ET.FW.Core.Common.Decoupler`1" /> class.
            Finalyzer: dispose object if not already done
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Decoupler`1.Name">
            <summary>
            Decoupler (thread) name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Decoupler`1.Priority">
            <summary>
            Thread priority
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.GenericErrorDecoder`1">
            <summary>
            Generic Decoder for ErrorCodes of generic enumeration type
            </summary>
            <typeparam name="TErrorCode">Error code enumeration type.</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.GenericErrorDecoder`1.DecodeError(ET.FW.Core.Common.FrameworkError)">
            <summary>
            Fills the DefaultDescription of the given error.<para></para>
            Returns, whether the errorcode of the given error is known and the DefaultDescription
            could be set.<para></para>
            If DefaultDescription is already set, it is overwritten.
            </summary>
            <param name="error">The error to be decoded.</param>
            <returns>Returns, whether the errorcode of the given error is known and the DefaultDescription could be set.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.LivingStateValue">
            <summary>
            Enum for all valid Living State and corresponding signal value
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.Undefined">
            <summary>
            State Undefined
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_PARKING">
            <summary>
            State Parking
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_WELCOME">
            <summary>
            State Welcome
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_LIVING">
            <summary>
            State Living
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_BYE">
            <summary>
            State Bye
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_SILENT_PARKING">
            <summary>
            State Silent_Parking
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_DRIVING">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_CHECK_IN">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_CHECK_OUT">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_PRE_WELCOME">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_PRE_DRIVING">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.LivingStateValue.VSL_DIAGNOSTICS">
            <summary>
            
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.MultiPlatform">
            <summary>
            Some Function for Multiplatform Suppport
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.MultiPlatform.X86SubPath">
            <summary>
            Subpath in AssembliesPath for x86-specific assemblies
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.MultiPlatform.X64SubPath">
            <summary>
            Subpath in AssembliesPath for x64-specific assemblies
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.MultiPlatform.#cctor">
            <summary>
            static constructor registering an event-handler at CurrentDomain.AssemblyResolve
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.MultiPlatform.Init">
            <summary>
            Dummy init method, forces execution of static constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.MultiPlatform.CurrentDomain_AssemblyResolve(System.Object,System.ResolveEventArgs)">
            <summary>
            Handles the event, when an Assembly is being resolved and loads the
            correct one regarding, whether a 32bit- or 64-bit-process is running
            </summary>
            <param name="sender">the sender</param>
            <param name="args">the EventArgs containting the name of the assembly to be resolved.</param>
            <returns>The created assembly or null, if none could be created.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.MultiPlatform.LoadOsDependentDll(System.String)">
            <summary>
            Loads the os dependent DLL.
            </summary>
            <param name="dllName">Name of the DLL.</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Common.MultiPlatform.MakeLocalDllName(System.String)">
            <summary>
            Create absolute path to the DLL.
            </summary>
            <param name="dllName">Name of the DLL.</param>
            <returns> complete, x86 or x64 based DLL path local to application.</returns>
        </member>
        <member name="P:ET.FW.Core.Common.MultiPlatform.PlatformSubPath">
            <summary>
            Returns the platform-specific SubPath-Name.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.MultiPlatform.IsWin64Process">
            <summary>
            Gets a value indicating whether this instance is win64 process.
            </summary>
            <value>
            	<c>true</c> if this instance is win64 process; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ET.FW.Core.Common.ObservableObjectWithDecouplingCheck`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObjectWithDecouplingCheck`1.#ctor">
            <summary>
            constructor without parameter
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObjectWithDecouplingCheck`1.#ctor(`0)">
            <summary>
            constructor with parameter
            </summary>
            <param name="Startvalue"></param>
        </member>
        <member name="E:ET.FW.Core.Common.ObservableObjectWithDecouplingCheck`1.Changed">
            <summary>
            Event for notification of value changes
            </summary>
            <remarks>
            Event is raised decoupled, if event handler class implements  interface.
            Otherwise event subscription issues a warning message.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObjectWithDecouplingCheck`1.OnChanged(System.Nullable{System.DateTime})">
            <summary>
            Handle changed value: Raise Changed event and PropertyChanged notification
            </summary>
            <param name="timestamp">The timestamp.</param>
        </member>
        <member name="T:ET.FW.Core.Common.ParameterExtension">
            <summary>
            Extension class, which adds parameter handling to all objects
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.SetParameters(System.Object,ET.FW.Core.Common.ParameterCollection)">
            <summary>
            Apply collection of parameters to this object
            Object must contain an Property with same name as parameter and this property must have the attribute ParameterAttribute
            </summary>
            <param name="target">object to be parametrized</param>
            <param name="parameters">parameters to set</param>
            <returns>true if all parameter properties were found and set</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.SetParameters(System.Object,ET.FW.Core.Common.ParameterCollection,System.Collections.Generic.List{System.String}@)">
            <summary>
            Apply collection of parameters to this object
            Object must contain an Property with same name as parameter and this property must have the attribute ParameterAttribute
            </summary>
            <param name="target">object to be parametrized</param>
            <param name="parameters">parameters to set</param>
            <param name="errorMessages">out: List with Error-Messages</param>
            <returns>true if all parameter properties were found and set</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.SetParameter(System.Object,ET.FW.Core.Common.Parameter)">
            <summary>
            Apply single parameter to this object
            Object must contain an Property with same name as parameter and this property must have the attribute ParameterAttribute
            </summary>
            <param name="target">object to be parametrized</param>
            <param name="parameter">parameter to set</param>
            <returns>true if all parameter properties were found and set</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.SetParameter(System.Object,ET.FW.Core.Common.Parameter,System.String@)">
            <summary>
            Apply single parameter to this object
            Object must contain an Property with same name as parameter and this property must have the attribute ParameterAttribute
            </summary>
            <param name="target">object to be parametrized</param>
            <param name="parameter">parameter to set</param>
            <param name="errorMessage">out: Error-Messages</param>
            <returns>true if all parameter properties were found and set</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.SetStringValue(System.Reflection.PropertyInfo,System.Object,System.String)">
            <summary>
            Set single property value
            </summary>
            <param name="property">property information</param>
            <param name="target">target object</param>
            <param name="valueAsString">value as string</param>
            <returns>true if property could be set</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.GetPropertyTypeConverter(System.Reflection.PropertyInfo)">
            <summary>
            Get type converter string conversion of a property
            </summary>
            <param name="property">property information</param>
            <returns>The matching type converter, if found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.GetObjectFromStringValue(System.Type,System.String)">
            <summary>
            Transforms the value as string to the value as object.
            </summary>
            <param name="type">object type</param>
            <param name="valueAsString">value as string</param>
            <returns>the object which corresponds to valueAsString</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterExtension.GetStringValueFromObject(System.Type,System.Object)">
            <summary>
            Transforms the value as string to the value as object.
            </summary>
            <param name="type">object type</param>
            <param name="value">value to convert</param>
            <returns>the object which corresponds to valueAsString</returns>
        </member>
        <member name="T:ET.FW.Core.Common.PayloadUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.PayloadUpdate.CalculateMAC(System.Byte[],System.Int32,System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="pduSecKey"></param>
            <param name="length"></param>
            <param name="mact"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.PayloadUpdate.UpdatePayload(System.UInt64,System.Byte[],System.Byte[],System.UInt64,System.Int32)">
            <summary>
            
            </summary>
            <param name="dataId"></param>
            <param name="msgPayload"></param>
            <param name="pduSecKey"></param>
            <param name="freshnessValue"></param>
            <param name="ignoreLength"></param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.RingBuffer.IRingBuffer`1">
            <summary>
            Ring Buffer Functionality.Not thread safe
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.IRingBuffer`1.Add(`0)">
            <summary>
            Add Item.
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.IRingBuffer`1.Remove(`0)">
            <summary>
            Remove Item
            </summary>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.IRingBuffer`1.Peek">
            <summary>
            Current Node.
            </summary>
            <returns>Returns Current Node</returns>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.IRingBuffer`1.GetList">
            <summary>
            Get List of items.
            </summary>
            <returns>List of items</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.IRingBuffer`1.IsEmpty">
            <summary>
            check if the buffer is empty.
            </summary>
            <returns>Returns true if buffer is empty</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="T:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1">
            <summary>
            Ring Buffer Functionality.Not thread safe
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.Add(`0,System.DateTime)">
            <summary>
            Add Item
            </summary>
            <param name="item">Item To Add</param>
            <param name="currentDataTimeStamp">Current Data Time Stamp</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.Remove(`0)">
            <summary>
            Remove Item
            </summary>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.Peek">
            <summary>
            Current Node.
            </summary>
            <returns>Returns Current Node</returns>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.GetList">
            <summary>
            Get List of items.
            </summary>
            <returns>List of items</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.IsEmpty">
            <summary>
            check if the buffer is empty.
            </summary>
            <returns>Returns true if buffer is empty</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.ITimeBasedRingBuffer`1.Clear">
            <summary>
            Clear buffer
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.RingBuffer.RingBuffer`1">
            <summary>
            Ring Buffer implementation.Not Thread Safe
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.RingBuffer`1.list">
            <summary>
            List to contain Items
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.RingBuffer`1.length">
            <summary>
            Length of the buffer
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.RingBuffer`1.node">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.RingBuffer`1.currentNode">
            <summary>
            
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.#ctor(System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="length">Length of RingBuffer</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.Add(`0)">
            <summary>
            Add Item.
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.Remove(`0)">
            <summary>
            Remove Item
            </summary>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.Peek">
            <summary>
            Current Node.
            </summary>
            <returns>Returns Current Node</returns>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.GetList">
            <summary>
            Get List of items.
            </summary>
            <returns>List of items</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.RingBuffer`1.IsEmpty">
            <summary>
            check if the buffer is empty.
            </summary>
            <returns>Returns true if buffer is empty</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="T:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1">
            <summary>
            Ring Buffer implementation.Not Thread Safe
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.list">
            <summary>
            List to contain Items
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.node">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.currentNode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.startTimeStamp">
            <summary>
            Start Time Stamp of buffer
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.duration">
            <summary>
            Duration of buffer full
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.#ctor(System.DateTime,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="startTime">Start Time</param>
            <param name="minutes">Duration</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.Add(`0,System.DateTime)">
            <summary>
            Add Item
            </summary>
            <param name="item">Item To Add</param>
            <param name="currentDataTimeStamp">Current Data Time Stamp</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.Remove(`0)">
            <summary>
            Remove Item
            </summary>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.Peek">
            <summary>
            Current Node.
            </summary>
            <returns>Returns Current Node</returns>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.GetList">
            <summary>
            Get List of items.
            </summary>
            <returns>List of items</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.Clear">
            <summary>
            Clear buffer
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.RingBuffer.TimeBasedRingBuffer`1.IsEmpty">
            <summary>
            check if the buffer is empty.
            </summary>
            <returns>Returns true if buffer is empty</returns>
            <exception cref="T:System.NullReferenceException">Null reference Exception</exception>
        </member>
        <member name="T:ET.FW.Core.Common.SecuredTickCountSharedMemory">
            <summary>
            Helper class for handling Secured tick count shared memory
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.SecuredTickCountSharedMemory.UpdateMemory(System.UInt64)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ET.FW.Core.Common.SecuredTickCountSharedMemory.ReadMemory">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.SecuredTickCountSharedMemory.Dispose">
            <summary>
            Dispose semaphore
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.StringValueAttribute">
            <summary>
            Attribute class for storing string values.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.StringValueAttribute.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:ET.FW.Core.Common.StringValueAttribute"/> instance.
            </summary>
            <param name="value">The string value to store.</param>
        </member>
        <member name="P:ET.FW.Core.Common.StringValueAttribute.Value">
            <summary>
            Gets / sets the string value.
            </summary>
            <value></value>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.IQueueReader`1">
            <summary>
            Interface for reader of queue containing only dequeue functionality.
            </summary>
            <typeparam name="T">Element type of items</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.IQueueReader`1.Dequeue">
            <summary>
            Dequeues the next item in the queue. Blocking when no more items are available.
            </summary>
            <returns>Next item</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.IQueueReader`1.ReleaseReader">
            <summary>
            Releases the reader by setting an event which releases blocking call into Dequeue
            in case of missing items and indicating stop call for reader thread.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.IQueueWriter`1">
            <summary>
            Interface for writer of queue containing only enqueue functionality.
            </summary>
            <typeparam name="T">Element type of items</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.IQueueWriter`1.Enqueue(`0)">
            <summary>
            Enqueues a new item.
            </summary>
            <param name="data">The new item.</param>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.BlockingQueue`1">
            <summary>
            Queue for decoupling of reader and writer.
            </summary>
            <typeparam name="T">Element type of items</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.BlockingQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Synchronization.BlockingQueue`1"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.BlockingQueue`1.Enqueue(`0)">
            <summary>
            Enqueues a new item.
            </summary>
            <param name="data">The new item.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.BlockingQueue`1.Dequeue">
            <summary>
            Dequeues the next item in the queue. Blocking when no more items are available.
            </summary>
            <returns>Next item</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.BlockingQueue`1.ReleaseReader">
            <summary>
            Releases the reader by setting an event which releases blocking call into Dequeue
            in case of missing items and indicating stop call for reader thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.BlockingQueue`1.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.ExecutionType">
            <summary>
            Possible types of execution
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Synchronization.ExecutionType.Post">
            <summary>Post execution meanst asynchron non blocking execution</summary>
        </member>
        <member name="F:ET.FW.Core.Common.Synchronization.ExecutionType.Send">
            <summary>Send execution means blocking execution</summary>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem">
            <summary>
            Wrapper class for item to execute
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.#ctor(System.Threading.SendOrPostCallback,System.Object,ET.FW.Core.Common.Synchronization.ExecutionType)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem"/> class.
            </summary>
            <param name="callback">The callback.</param>
            <param name="state">The state.</param>
            <param name="type">The type.</param>
        </member>
        <member name="P:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.Exception">
            <summary>
            Gets the exception.
            </summary>
            <value>
            The exception.
            </value>
        </member>
        <member name="P:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.ExecutedWithException">
            <summary>
            Gets a value indicating whether the execution caused an exception.
            </summary>
            <value>
            <c>true</c> if [executed with exception]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.Execute">
            <summary>
            Executes this item.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.Send">
            <summary>
            Calling thread will block until mAsyncWaitHanel is set
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.Post">
            <summary>
            Unhandle execptions will terminate the STA thread
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem.ExecutionCompleteWaitHandle">
            <summary>
            Gets the execution complete wait handle.
            </summary>
            <value>
            The execution complete wait handle.
            </value>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.EtSynchronizationContext">
            <summary>
            Class providing an synchronization which executes calls in a row,
            the way they are received.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Synchronization.EtSynchronizationContext"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            When overridden in a derived class, dispatches a synchronous message to a synchronization context.
            </summary>
            <param name="d">The <see cref="T:System.Threading.SendOrPostCallback" /> delegate to call.</param>
            <param name="state">The object passed to the delegate.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            When overridden in a derived class, dispatches an asynchronous message to a synchronization context.
            </summary>
            <param name="d">The <see cref="T:System.Threading.SendOrPostCallback" /> delegate to call.</param>
            <param name="state">The object passed to the delegate.</param>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContext.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContext.CreateCopy">
            <summary>
            No copies allowed, returning this instance.
            </summary>
            <returns>
            This instance
            </returns>
        </member>
        <member name="T:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread">
            <summary>
            Class containing thead for reading and execution of 
            synchronization items.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.#ctor(System.Threading.SynchronizationContext,ET.FW.Core.Common.Synchronization.IQueueReader{ET.FW.Core.Common.Synchronization.SendOrPostCallbackItem})">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread" /> class.
            </summary>
            <param name="synchronizationContext">The synchronization context.</param>
            <param name="reader">The reader.</param>
        </member>
        <member name="P:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.ManagedThreadId">
            <summary>
            Gets the managed thread identifier.
            </summary>
            <value>
            The managed thread identifier.
            </value>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.Start">
            <summary>
            Starts the reader thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.Join">
            <summary>
            Joins this thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.Run">
            <summary>
            Runs method for thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Synchronization.EtSynchronizationContextThread.Stop">
            <summary>
            Stops this reader thread.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.TCollection`1">
            <summary>
            Collection of T which can be accessed by Uppercase names
            </summary>
            <typeparam name="T">Type of collection item</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.TCollection`1.#ctor">
            <summary>
            Constructor instantiates with type.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.TCollection`1.GetKeyForItem(`0)">
            <summary>
            Extract key from stored object
            </summary>
            <param name="item">stored object</param>
            <returns>Object key</returns>
        </member>
        <member name="M:ET.FW.Core.Common.TCollection`1.Contains(System.String)">
            <summary>
            Check if object with given name is already stored in collection
            </summary>
            <param name="name">name to find</param>
            <returns>true if object with given name is found in collection</returns>
        </member>
        <member name="P:ET.FW.Core.Common.TCollection`1.Item(System.String)">
            <summary>
            Easy to use read access to collection, which does not throw an exception if the given key is not found
            </summary>
            <param name="name">name of item</param>
            <returns>Item with given name or null if item cannot be found</returns>
        </member>
        <member name="P:ET.FW.Core.Common.TCollection`1.UnfilteredItems">
            <summary>
            All parameters, including the ones with non-unique names
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.TCollection`1.AddItemNotRequiredBeingUnique(`0)">
            <summary>
            Adds the given item to the Dictionary. If an item with the same name
            already exists, the given one is added as unfiltered item, which
            makes it accessible via UnfilteredItems.
            </summary>
            <param name="item">The item to add</param>
        </member>
        <member name="T:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter">
            <summary>
            
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.videoFileWriter">
            <summary>
            
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.Open(System.String,System.Int32,System.Int32)">
            <summary>
            Create video file with the specified name and attributes
            </summary>
            <param name="fileName"> Video file name to create.</param>
            <param name="width">Frame width of the video file.</param>
            <param name="height">Frame height of the video file.</param>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.Open(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
             Create video file with the specified name and attributes.
            </summary>
            <param name="fileName"> Video file name to create.</param>
            <param name="width">Frame width of the video file.</param>
            <param name="height">Frame height of the video file.</param>
            <param name="frameRate">Frame rate of the video file.</param>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.WriteVideoFrame(System.Drawing.Bitmap)">
            <summary>
            Write Frames
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.WriteVideoFrame(System.Drawing.Bitmap,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="frame"></param>
            <param name="timestamp"></param>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.Close">
            <summary>
            Close currently opened video file if any.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.AviVideoWriter.AviVideoWriter.IsOpen">
            <summary>
            The property specifies if a video file is opened or not by this instance of the class.
            </summary>
            <returns>true if file is open</returns>
        </member>
        <member name="T:ET.FW.Core.Common.VideoWriter.IVideoFileWriter">
            <summary>
            
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.IVideoFileWriter.Open(System.String,System.Int32,System.Int32)">
            <summary>
            Create video file with the specified name and attributes
            </summary>
            <param name="fileName"> Video file name to create.</param>
            <param name="width">Frame width of the video file.</param>
            <param name="height">Frame height of the video file.</param>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.IVideoFileWriter.Open(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
             Create video file with the specified name and attributes.
            </summary>
            <param name="fileName"> Video file name to create.</param>
            <param name="width">Frame width of the video file.</param>
            <param name="height">Frame height of the video file.</param>
            <param name="frameRate">Frame rate of the video file.</param>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.IVideoFileWriter.WriteVideoFrame(System.Drawing.Bitmap)">
            <summary>
            Write frames.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.IVideoFileWriter.Close">
            <summary>
            Close currently opened video file if any.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.VideoWriter.IVideoFileWriter.IsOpen">
            <summary>
            The property specifies if a video file is opened or not by this instance of the class.
            </summary>
            <returns>true if file is open</returns>
        </member>
        <member name="T:ET.FW.Core.Common.WaitableObservableObject`1">
            <summary>
            Waitable ObservableObject
            </summary>
            <typeparam name="T">Type of object</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.#ctor(`0)">
            <summary>
            The constructor
            </summary>
            <param name="startValue">Start value</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Init">
            <summary>
            Inits instance
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.OnChanged(System.Object,ET.FW.Core.Common.ValueChangedEventArgs{`0})">
            <summary>
            On value changed event handler
            </summary>
            <param name="sender">The sender</param>
            <param name="e">event args</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.SetChangedHandles">
            <summary>
            Set changed handles
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.SetWaitHandles(`0)">
            <summary>
            Set wait handles
            </summary>
            <param name="value">value for wait handle</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Dispose">
            <summary>
            Disposes instance
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.AddHandle(`0,System.Threading.ManualResetEvent)">
            <summary>
            Adds wait handle
            </summary>
            <param name="value">value of handle</param>
            <param name="handle">The handle</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.RemoveHandle(`0,System.Threading.ManualResetEvent)">
            <summary>
            Removes wait handle
            </summary>
            <param name="value">value of handle</param>
            <param name="handle">The handle</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.GetHandle(`0[])">
            <summary>
            Get Handle for values
            </summary>
            <param name="values">values to wait for</param>
            <returns>Wait handle</returns>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.DisposeHandle(`0[],System.Threading.ManualResetEvent)">
            <summary>
            Disposes hanlde
            </summary>
            <param name="values">Values of handle</param>
            <param name="handle">The Handle</param>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Wait(`0[])">
            <summary>
            Wait for changing to value
            </summary>
            <param name="values">changed values to wait for</param>
            <returns>true if success</returns>
            <remarks>if no values passed, then it waits until any value changes</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Wait(System.Int32,`0[])">
            <summary>
            Wait for changing to value
            </summary>
            <param name="millisecondsTimeout">Timeout milliseconds</param>
            <param name="values">changed values to wait for</param>
            <returns>True if success</returns>
            <remarks>if no values passed, then it waits until any value changes</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Wait(System.TimeSpan,`0[])">
            <summary>
            Wait for changing to value
            </summary>
            <param name="timeout">The Timeout</param>
            <param name="values">changed values to wait for</param>
            <returns>True if success</returns>
            <remarks>if no values passed, then it waits until any value changes</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.TestAny(`0[])">
            <summary>
            Test values
            </summary>
            <param name="values">Values to test</param>
            <returns>True if anny value matched</returns>
        </member>
        <member name="M:ET.FW.Core.Common.WaitableObservableObject`1.Test(`0)">
            <summary>
            Test value
            </summary>
            <param name="value">value to test</param>
            <returns>True if test value equals object value</returns>
        </member>
        <member name="T:ET.FW.Core.Common.InvokeExtensions">
            <summary>
            Extension methods for ISynchronizeInvoke interface for cross thread access.
            Class provides some methods to simplify access to Control/Form objects from other threads.
            </summary>
            <remarks>
            Methods are designed to provide a short clear syntax if combined with anonymous methods or lambda expressions.
            See examples provided with each method.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.InvokeExtensions.BeginAction(System.ComponentModel.ISynchronizeInvoke,System.Action,System.Boolean)">
             <summary>
             Perform given action asynchronously in correct thread context for this control
             </summary>
             <param name="control">Control which provides the thread context for execution</param>
             <param name="action">action to be performed</param>
             <param name="throwExceptions"><c>false</c>: Exceptions are caught and not rethrown. <c>true</c>: Exceptions are thrown.</param>
             <example>
             Set textbox tb text to "New text"
             <code>
             //C#2.0 syntax:
            	control.BeginAction(delegate() { tb.Text = "New text"; } );
            
            	//C#3.0 syntax:
            	control.BeginAction( () => tb.Text = "New text" );
             </code></example>
        </member>
        <member name="M:ET.FW.Core.Common.InvokeExtensions.InvokeIfRequired(System.ComponentModel.ISynchronizeInvoke,System.Action,System.Boolean)">
             <summary>
             Perform given action synchronously in correct thread context for this control
             </summary>
             <param name="control">Control which provides the thread context for execution</param>
             <param name="action">action to be performed</param>
             <param name="throwExceptions"><c>false</c>: Exceptions are caught and not rethrown. <c>true</c>: Exceptions are thrown.</param>
             <example>
             Set textbox tb text to "New text"
             <code>
             //C#2.0 syntax:
            	control.InvokeIfRequired(delegate() { tb.Text = "New text"; } );
            
            	//C#3.0 syntax:
            	control.InvokeIfRequired( () => tb.Text = "New text" );
             </code></example>
        </member>
        <member name="M:ET.FW.Core.Common.InvokeExtensions.InvokeIfRequired``1(System.ComponentModel.ISynchronizeInvoke,System.Func{``0},System.Boolean)">
             <summary>
             Execute given function synchronously in correct thread context for this control and return its result
             </summary>
             <typeparam name="TResult">Type of given function return value</typeparam>
             <param name="control">Control which provides the thread context for execution</param>
             <param name="function">function to be called</param>
             <param name="throwExceptions"><c>false</c>: Exceptions are caught and not rethrown. <c>true</c>: Exceptions are thrown.</param>
             <returns>return value of given function</returns>
             <example>
             Read text from textbox tb into result string
             <code>
             //C#2.0 syntax:
            	string result = control.InvokeIfRequired(delegate() { return tb.Text; } );
            
            	//C#3.0 syntax:
            	string result = control.InvokeIfRequired( () => tb.Text );
             </code></example>
        </member>
        <member name="T:ET.FW.Core.Common.VoidDelegate">
            <summary>
            Generic delegate for functions without parameters.
            Should be replaced by System.Action delegate!
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Endian">
            <summary>
            Helper class to swap between endians
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapInt16(System.Int16)">
            <summary>
            Swaps the bytes inside an int16.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapUInt16(System.UInt16)">
            <summary>
            Swaps the bytes inside an uint16.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapInt32(System.Int32)">
            <summary>
            Swaps the bytes inside an int32.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapUInt32(System.UInt32)">
            <summary>
            Swaps the bytes inside an uint32.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapInt64(System.Int64)">
            <summary>
            Swaps the bytes inside an int64.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.Common.Endian.SwapUInt64(System.UInt64)">
            <summary>
            Swaps the bytes inside an Uint64.
            </summary>
            <param name="v">The v.</param>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.Common.ETClock">
            <summary>
            Global Timebase for the ET framework (e.g. Logging). All devices and services should use this clock as
            time base. It has a higher accuracy than the PC RTC-Clock
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETClock.sw">
            <summary>
            The Highpresion timer witch replaces the RTC
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETClock.dateStart">
            <summary>
            The start time of the stopwatch == sw (Highprecisontimer)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.#ctor">
            <summary>
            Private Constructor 
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.InitEtKind">
            <summary>
            Initializes the ETClock Kind
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETClock.Kind">
            <summary>
            DateTime Kind of ET-Clock
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETClock.Instance">
            <summary>
            The one and only instance
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETClock.Now">
            <summary>
            delivers the global timestamp for the log
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.CreateDateTime(System.Int64)">
            <summary>
            Create DateTime with ETClock DateTimeKind
            </summary>
            <param name="ticks">the dateTime in ticks</param>
            <returns>the dateTime as ETClock Kind</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.CreateDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create instance of DateTime
            </summary>
            <param name="year">The year.</param>
            <param name="month">The month.</param>
            <param name="day">The day.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <returns>the dateTime as ETClock Kind</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.ToETClockTime(System.DateTime)">
            <summary>
            Convert to ETClock Kind time
            </summary>
            <param name="dateTime">The DataTime to convert</param>
            <returns>the dateTime as ETClock Kind</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.SpecifyETClockKind(System.DateTime)">
            <summary>
            Specify Datetime as ETClock Kind
            </summary>
            <param name="dateTime">The DataTime to convert</param>
            <returns>the dateTime as ETClock Kind</returns>
        </member>
        <member name="P:ET.FW.Core.Common.ETClock.MinValue">
            <summary>
            Min value of the DataTime Type
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ETClock.MaxValue">
            <summary>
            Max value of the DataTime Type
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.FromBinary(System.Int64)">
            <summary>
            From Binary with ETClock Kind
            </summary>
            <param name="dateData">the DateTime as Binary</param>
            <returns>the DateTime</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.Parse(System.String)">
            <summary>
            Parse date time string
            </summary>
            <param name="s">string to parse</param>
            <returns>the DateTime</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.Parse(System.String,System.String)">
            <summary>
            Parse date time string
            </summary>
            <param name="s">string to parse</param>
            <param name="format">the format of the date time</param>
            <returns>the DateTime</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.TryParse(System.String,System.DateTime@)">
            <summary>
            Try parse date time string
            </summary>
            <param name="s">string to parse</param>
            <param name="result">the datetime</param>
            <returns>true is possible to parse</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ETClock.TryParse(System.String,System.String,System.DateTime@)">
            <summary>
            Try parse date time string
            </summary>
            <param name="s">string to parse</param>
            <param name="format">the format of the date time</param>
            <param name="result">the datetime</param>
            <returns>true, if possible to parse</returns>
        </member>
        <member name="T:ET.FW.Core.Common.INamedObject">
            <summary>
            Interface for standard access to object name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.INamedObject.Name">
            <summary>
            Object Name
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.INamedObjectCollection`1">
            <summary>
            Collection of named objects which can be accessed by names
            </summary>
            <typeparam name="T">type of the objects to collect (needs the INamedObject interface)</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.INamedObjectCollection`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
            <value>
            The number of elements contained in the collection.
            </value>
        </member>
        <member name="P:ET.FW.Core.Common.INamedObjectCollection`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the collection.</exception>
        </member>
        <member name="M:ET.FW.Core.Common.INamedObjectCollection`1.Remove(System.String)">
            <summary>
            Removes the object with the specified name
            </summary>
            <param name="name">The object name.</param>
            <returns>true if the element is successfully removed; otherwise, false. This method also returns false if name is not found in the collection.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.ValueChangedEventArgs`1">
            <summary>
            Event arguments for notification of canged observable values
            </summary>
            <typeparam name="T">Type of observable value</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.ValueChangedEventArgs`1.#ctor(`0)">
            <summary>
            Constructor, construct new event argument for given value
            </summary>
            <param name="newValue">new value</param>
        </member>
        <member name="M:ET.FW.Core.Common.ValueChangedEventArgs`1.#ctor(`0,System.Nullable{System.DateTime})">
            <summary>
            Constructor, construct new event argument for given value
            </summary>
            <param name="newValue">new value</param>
            <param name="timestamp">Optional timestamp value</param>
        </member>
        <member name="P:ET.FW.Core.Common.ValueChangedEventArgs`1.NewValue">
            <summary>
            New value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ValueChangedEventArgs`1.Timestamp">
            <summary>
            timestamp of change, optional value which is not used for all observable objects
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.ValueChangedEventHandler`1">
            <summary>
            Event handler for value changed events
            </summary>
            <typeparam name="T">Type of changed value</typeparam>
            <param name="sender">event source</param>
            <param name="e">event arguments containing new value</param>
        </member>
        <member name="T:ET.FW.Core.Common.IReadOnlyObservableObject`1">
            <summary>
            Interface for read only access to observable values
            </summary>
            <typeparam name="T">Type of observable value</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.IReadOnlyObservableObject`1.Value">
            <summary>
            Current value
            </summary>
        </member>
        <member name="E:ET.FW.Core.Common.IReadOnlyObservableObject`1.Changed">
            <summary>
            Event for notification of value changes
            </summary>
            <remarks>
            Subscribers of some (time) critical events should implement event decoupling <see cref="T:ET.FW.Core.Events.IEventDecoupling"/>
            Some implementation classes issue a warning if your event handler target does not support decoupling.
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Common.IObservableObject`1">
            <summary>
            Interface for access to observable values.
            Value can be modified via setter which triggers the changed event.
            </summary>
            <typeparam name="T">Type of observable value</typeparam>
        </member>
        <member name="P:ET.FW.Core.Common.IObservableObject`1.Value">
            <summary>
            Current value
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.IParametrizable">
            <summary>
            Interface definition for parametrizable classes.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IParametrizable.SetParameters(ET.FW.Core.Common.ParameterCollection)">
            <summary>
            Sets the parameters.
            </summary>
            <param name="parameters">The parameter collection.</param>
        </member>
        <member name="T:ET.FW.Core.Common.IService">
            <summary>
            Interface definition for ET framework services.
            Interface is used for different API services which are provided as a single instance for usage by different test jobs or API functions.
            Services might provide special functionality which can be based on hardware devices or on other services.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IService.Init">
            <summary>
            Initializes the service.
            </summary>
            <returns><c>true</c> if successfull; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.IStartable">
            <summary>
            Interface for objects which can be started and stopped
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.IStartable.Start">
            <summary>
            Start object
            </summary>
            <returns><c>true</c>, if successful</returns>
        </member>
        <member name="M:ET.FW.Core.Common.IStartable.Stop">
            <summary>
            Stop object
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.IStartable.IsRunning">
            <summary>
            Indicates if the object is started and still runs
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.DisposeList">
            <summary>
            Disposes the registered IDisposable objects
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.DisposeList.Add(System.IDisposable)">
            <summary>
            Adds the specified disposable.
            </summary>
            <param name="disposable">The disposable.</param>
        </member>
        <member name="M:ET.FW.Core.Common.DisposeList.Remove(System.IDisposable)">
            <summary>
            Removes the specified disposable from the AppExit list.
            Should be called during Dispose, so object will not get a Dispose later.
            </summary>
            <param name="disposable">The disposable.</param>
        </member>
        <member name="M:ET.FW.Core.Common.DisposeList.System#IDisposable#Dispose">
            <summary>
            Disposes all added IDisposables. Dispose must check if object was Disposed before.
            Will be called from a controlling object, e.g. a online/offline handler in the framework
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.NamedObjectCollection`1">
            <summary>
            Collection of named objects which can be accessed by names
            </summary>
            <typeparam name="T">type of the objects to collect (needs the INamedObject interface)</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.#ctor">
            <summary>
            Constructor instantiates an empty list.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor instantiates an list from enumerable.
            </summary>
            <param name="collection">Collection of T.</param>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.GetKeyForItem(`0)">
            <summary>
            Extract key from stored object
            </summary>
            <param name="item">stored object</param>
            <returns>Object key</returns>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds an other NamedObjectCollection of the same T
            </summary>
            <param name="collection">collection to add</param>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.Contains(System.String)">
            <summary>
            Check if object with given name is already stored in collection
            </summary>
            <param name="name">name to find</param>
            <returns>true if object with given name is found in collection</returns>
        </member>
        <member name="P:ET.FW.Core.Common.NamedObjectCollection`1.Item(System.String)">
            <summary>
            Easy to use read access to collection, which does not throw an exception if the given key is not found
            </summary>
            <param name="name">name of item</param>
            <returns>Item with given name or null if item cannot be found</returns>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.TryGetValue(System.String,`0@)">
            <summary>
            Tries to get item with given name from collection.
            </summary>
            <param name="name">Item name.</param>
            <param name="item">Item with given name or null if item cannot be found</param>
            <returns>true, if item was found, otherwise false</returns>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.Equals(System.Object)">
            <summary>
            Determines whether the specified Object is equal to the current Object.
            </summary>
            <remarks>Compares the count and the containing objects by the name.</remarks>
            <param name="obj">The Object  to compare with the current Object. </param>
            <returns> true if the specified Object  is equal to the current Object; otherwise, false.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.NamedObjectCollection`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>A hash code for the current Object.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.ObservableObject">
            <summary>
            Static class for the creation of ObservableObjects, contains factory methods.
            An observable object in a job has a known TYPE, so you will create it
            as new ObservableObject&lt;string&gt;(), for example.
            <para/>
            Use this static class factory if you do not know the exact type of your object
            that must be wrapped. You can create a matching generic ObservableObject&lt;&gt; by 
            using object.GetType() as type parameter and object as value parameter.
            <para/>
            Some more info about current usage:
            A test plan has only strings as initial values for test job properties, so it 
            will ask the job for the TYPE the property, and then create an ObservableObject&lt;TYPE&gt;
            using the type-dependend Parser to transform the string to the corresponding TYPE.
            A TYPE-dependend factory-method is part oft ObservableObject&lt;TYPE&gt;, the 
            factory-method with TYPE as parameter is part of this non-generic parent.
            This ObservableObject class is a base class of the generic classes, so that
            we can return a static type in the factory method instead of a unspecific "object" type.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject.GetObservableObject(System.Type,System.Object)">
            <summary>
            Creates a new observable object that wraps a instance of an type where the type is given as parameter. 
            The instance is initialized by the object given as parameter value.
            </summary>
            <param name="type">The type.</param>
            <param name="value">The value.</param>
            <returns>Returns a newly created ObservableObject{} instance of given type and with given value.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.ObservableObject`1">
            <summary>
            Helper class for observable values.
            Each change of the Value triggers notification of a Changed event with the newly set value.
            Optionally the event can include a timestamp.
            </summary>
            <remarks>Changed event is raised using decoupled events</remarks>
            <typeparam name="T">Type of observable object</typeparam>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.#ctor">
            <summary>
            Default constructor, value starts with default
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.#ctor(`0)">
            <summary>
            Constructor with start value
            </summary>
            <param name="startValue">initial value</param>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.ObservableObjectOn(System.Object)">
            <summary>
            Factory method: returns an generic typed ObservableObject with a start value
            collected from a parameter object. The start Value is converted using
            TypeConverters, so a class implementor can set the right converter using attributes.
            </summary>
            <param name="startValue">initial value</param>
            <returns>Returns a newly created ObservableObject{T} instance with given value.</returns>
            <exception cref="T:System.ArgumentException">TypeConverter for type  + typeof(T).ToString() +  not available or TypeConverter cannot convert  + valType +  into this type</exception>
            <remarks>Method is internally used by ObservableObject.GetObservableObject() method.</remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.op_Implicit(ET.FW.Core.Common.ObservableObject{`0})~`0">
            <summary>
            Implicit cast to type of value
            </summary>
            <param name="observable">observable object to be casted</param>
            <returns>object value</returns>
        </member>
        <member name="P:ET.FW.Core.Common.ObservableObject`1.Value">
            <summary>
            The current value
            </summary>
            <remarks>
            If the newly set value is different from previous value a changed event is raised
            Setter sets timestamp of raised changed event to null
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.SetValue(`0,System.Nullable{System.DateTime})">
            <summary>
            Set method which sets new value and enables use of Timestamp parameter.
            </summary>
            <param name="newValue">new value</param>
            <param name="timestamp">timestamp of value change</param>
            <remarks>
            This method always raises a Changed event, even if new value is the same as previous value
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.OnChanged(System.Nullable{System.DateTime})">
            <summary>
            Handle changed value: Raise Changed event and PropertyChanged notification
            </summary>
            <param name="timestamp">The timestamp.</param>
        </member>
        <member name="E:ET.FW.Core.Common.ObservableObject`1.Changed">
            <summary>
            Event for notification of value changes
            </summary>
            <remarks>
            Event is raised decoupled, if event handler class implements IEventDecoupling interface
            </remarks>
        </member>
        <member name="E:ET.FW.Core.Common.ObservableObject`1.PropertyChanged">
            <summary>
            Represents the method that will handle the PropertyChanged event raised when a 
            property is changed on a component.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.ToString">
            <summary>
            Returns ObservableObject Value as text
            </summary>
            <returns>Value as text</returns>
        </member>
        <member name="M:ET.FW.Core.Common.ObservableObject`1.OnChangedRaiseDecoupled(System.Nullable{System.DateTime})">
            <summary>
            logs the rasing of decoupled
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Parameter">
            <summary>
            Simple Parameter consisting of name and value string
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Parameter.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Parameter.#ctor(System.String,System.String)">
            <summary>
            Constructor for the Parameter
            </summary>
            <param name="name">parameter name</param>
            <param name="value">parameter value</param>
        </member>
        <member name="P:ET.FW.Core.Common.Parameter.Name">
            <summary>
            The Name of the parameter
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Parameter.Value">
            <summary>
            Parameter value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Parameter.Reader">
            <summary>
            Xml parameter reader
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Parameter.ToString">
            <summary>
            Convert Parameter to text (format: "Name=Value")
            </summary>
            <returns>Parameter as string</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Parameter.Parse(System.String)">
            <summary>
            Parse parameter string (format: "Name=Value")
            </summary>
            <param name="text">text to parse</param>
            <returns>parsed parameter object</returns>
            <remarks>First '=' is taken as separator, following '=' are considered part of the parameter value</remarks>
        </member>
        <member name="T:ET.FW.Core.Common.ParameterCollection">
            <summary>
            Collection of Parameter which can be accessed by Uppercase names
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.ParameterCollection.UnfilteredParameters">
            <summary>
            All parameters, including the ones with non-unique names
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ParameterCollection.AddParameterNotRequiredBeingUnique(ET.FW.Core.Common.Parameter)">
            <summary>
            Adds the given param to the Dictionary. If a param with the same name
            already exists, the given one is added as unfiltered parameter, which
            makes it accessible via UnfilteredParameters.
            </summary>
            <param name="param">The Parameter to add</param>
        </member>
        <member name="T:ET.FW.Core.Common.Service">
            <summary>
            Default implementation for ET framework services, 
            Class is intended as base class for different service implementations
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Service.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Service.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Service name</param>
        </member>
        <member name="P:ET.FW.Core.Common.Service.Name">
            <summary>
            Service name, used to identify and access the service
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Service.Init">
            <summary>
            Initialize the service
            </summary>
            	<c>true</c> if successfull; otherwise, <c>false</c>.
        </member>
        <member name="M:ET.FW.Core.Common.Service.Dispose">
            <summary>
            Shutdown the service
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.Settings">
            <summary>
            Global framework environment settings
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.BasePath">
            <summary>
            Base path (without trailing separator char)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.AssembliesPath">
            <summary>
            Assemblies path (without trailing separator char)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.ConfigPath">
            <summary>
            Directory for configuration files
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.UserProfileFilePath">
            <summary>
            Directory for UserProfiles.xml path
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.UserSelectedProfile">
            <summary>
            Name of User Seleceted Profiles
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.CatalogsPath">
            <summary>
            Directory for catalogs
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.DiagnosticsPath">
            <summary>
            
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.LogsPath">
            <summary>
            Directory for Logs
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.AppSettings">
            <summary>
            Returns the AppSettings section from the EtSettings.xml
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.TracesPath">
            <summary>
            Default directory for traces (another directory may be configured in settings file)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.PplPath">
            <summary>
            Directory for the PPL hierarchy
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.PplTpdExt">
            <summary>
            Extension for TestPlanDef Files
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.PplTsExt">
            <summary>
            Extension for TestSet Files
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.PplTsOldExt">
            <summary>
            Extension for TestSet Files
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.TsFileExtensions">
            <summary>
            Extension for TestSet Files, in lowercase
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.TraceFileExtensions">
            <summary>
            Extension for Trace Files, in lowercase
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.TraceFileSummaryName">
            <summary>
            Spezial file name for unzipped trace files, in lowercase
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.TraceFileOpenDialogFilter">
            <summary>
            Filter for open file dialog
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.JobsPath">
            <summary>
            Directory for job dlls
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.DefaultCultureInfo">
            <summary>
            Language settings for data convert - use always US settings for time and numbers
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.InstrumentsFileMask">
            <summary>
            The Filemask for the Instruments
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.ProtocolsFileMask">
            <summary>
            The Filemask for the Protocols
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.BussesFileMask">
            <summary>
            The Filemask for the busses
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.ConfigName">
            <summary>
            File name for the settings file in ConfigPath
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.AcpCommanderName">
            <summary>
            File name for the acp commander executable 
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.AcpCommanderArguments">
            <summary>
            Arguments for the acp commander to start with framewok config editor active
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.FrameworkConfigEditorName">
            <summary>
            File name for the framework config editor library
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.EquipmentManagerFileMask">
            <summary>
            File Mask to search for EquipmentManagers
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.OfflineChannelAccessFileMask">
            <summary>
            File Mask to search for offline channel accesses
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.OfflineProtocolFactoryFileMask">
            <summary>
            File Mask to search for OfflineProtocolFactories
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.PplJobDllFileMask">
            <summary>
            File Mask to load in jobs dir before searching for ppl classes (plans and jobs)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.TraceConfigDllFileMask">
            <summary>
            File Mask to load in jobs dir before searching for formatter and Message classes
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.Settings.AddonDllFileMask">
            <summary>
            File Mask to load Add on
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.ETFrameworkTempPath">
            <summary>
            Gets the ET framework temp path.
            </summary>
            <value>The ET framework temp path.</value>
        </member>
        <member name="M:ET.FW.Core.Common.Settings.RemoveETFrameworkTempPath">
            <summary>
            Remove the ET framework temp path.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.Settings.GetAcpCommanderPath">
            <summary>
            Gets the full path to the acp commander executable.
            </summary>
            <returns>The path to the executable</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Settings.GetFrameworkConfigEditorPath">
            <summary>
            Gets the full path to the framework configurator editor.
            </summary>
            <returns>The path to the library</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Settings.ValidateFileName(System.String@,System.Boolean,System.Boolean)">
            <summary>
            Validates the given fileName, i.e. checks, whether a file with the given name exists and, if not, investigates
            framework-paths for it, depending on the given parameters.<para></para>
            Returns TRUE, if the fileName can be used to open a file, FALSE otherwise.<para></para>
            The Catalog-Path is not investigated.
            </summary>
            <param name="fileName">ref: the fileName to investiage. Changed, if neccesary. Not changed, if FALSE is returned.</param>
            <param name="investigateAssembliesPath">TRUE, to look for the file within the Assemblies-Path, FALSE otherwise.</param>
            <param name="investiageConfigPath">TRUE, to look for the file within the Config-Path, FALSE otherwise.</param>
            <returns>Returns TRUE, if the fileName can be used to open a file, FALSE otherwise.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.Settings.ValidateFileName(System.String@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Validates the given fileName, i.e. checks, whether a file with the given name exists and, if not, investigates
            framework-paths for it, depending on the given parameters.<para></para>
            Returns TRUE, if the fileName can be used to open a file, FALSE otherwise.<para></para>
            If all given parameters are FALSE, it is only checked, whether the given fileName exists.
            </summary>
            <param name="fileName">ref: the fileName to investiage. Changed, if neccesary. Not changed, if FALSE is returned.</param>
            <param name="investigateAssembliesPath">TRUE, to look for the file within the Assemblies-Path, FALSE otherwise.</param>
            <param name="investiageConfigPath">TRUE, to look for the file within the Config-Path, FALSE otherwise.</param>
            <param name="investigateCatalogPath">TRUE, to look for the file within the Catalog-Path, FALSE otherwise.</param>
            <param name="investigateBasePath">TRUE, to look for the file within the Base-Path, FALSE otherwise.</param>
            <param name="investigateWorkingPath"><c>true</c>, to look for the file within the current working dirctory; otherwise <c>false</c>.</param>
            <returns>Returns TRUE, if the fileName can be used to open a file, FALSE otherwise.</returns>
        </member>
        <member name="P:ET.FW.Core.Common.Settings.LogMemInfo">
            <summary>
            Set to TRUE to automatically log MemoryInfos<para></para>
            Default is FALSE<para></para>
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.ETThreadPool">
            <summary>
            Thread Pool class with pre-initialized threads and dynamic increase.
            TODO: Move unused Threads to a shared static pool instead of keeping 
            them in the ThreadPool instance
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.#ctor(System.String,System.Int32,System.Boolean,System.Threading.ThreadPriority)">
            <summary>
            Initialize and create minThreadCount threads.
            </summary>
            <param name="name">Name of the ETThreadPool</param>
            <param name="threadCount">Number of Threads to create at start. If more threads than already created are needed, this parameter is used to dertermine, how many new threads are to be created at once.</param>
            <param name="delayDuplicateStart"><c>true</c> or <c>false</c>.</param>
            <param name="priority">With which priority shall those threads created by this ThreadPool be executed.</param>
        </member>
        <member name="P:ET.FW.Core.Common.ETThreadPool.AboveNormalThreads">
            <summary>
            Gets a Thread Pool for "above normal" threads.
            </summary>
            <value>The above normal threads pool.</value>
        </member>
        <member name="P:ET.FW.Core.Common.ETThreadPool.NormalThreads">
            <summary>
            Gets a Thread Pool for "normal" threads.
            </summary>
            <value>The normal threads pool.</value>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.disposed">
            <summary>
            check that we do not dispose the instance twice
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.name">
            <summary>
            a name for the thread pool (improved logging)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.initialThreadCount">
            <summary>
            initial threads that should be created, will be used as fallback when threads end: keep this number of sleeping threads
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.threadDelegate">
            <summary>
            delegate for the Threads to run on
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.priority">
            <summary>
            Preset m_priority for this ETThreadPool
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.startJobsWaitHandle">
            <summary>
            Wait handle for idle Threads to wait on
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.loopEndedWaitHandle">
            <summary>
            Handle that is set only when ETThreadPool exits
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.shutdown">
            <summary>
            Shutdown is set to true on dispose
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.listLock">
            <summary>
            Syncronizing on member data
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.threadCount">
            <summary>
            current number of threads
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.sleepingThreads">
            <summary>
            number of thread waiting on startJobsWaitHandle
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.threadList">
            <summary>
            List of all threads
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.startJobs">
            <summary>
            jobs to run next for free threads, thread will remove job from queue
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.queuedJobs">
            <summary>
            job requests (running or waiting to be put to startJobs - only used if m_delayDuplicateStart == true
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.startedJobs">
            <summary>
            jobs running (in thread or in startJobs)  - only used if m_delayDuplicateStart == true
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.collisions">
            <summary>
            if a job is already running a (single) new run request is stored for execution after job ended
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.ETThreadPool.delayDuplicateStart">
            <summary>
            Wait for the former delegate to end before starting it again, will only start 1 time even if there were many calls delayed
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.AddThread">
            <summary>
            Add new thread to the pool
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.ThreadEnded">
            <summary>
            When ThreadLoop ends, the thread ends and updates statistics, last one unlocks external processing.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.ThreadLoop">
            <summary>
            Method as delegate for the threads: get something to to from the list, do it and repeat until shutdown signal
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.Start(ET.FW.Core.Common.VoidDelegate)">
            <summary>
            Call Execute on threadBuffer
            </summary>
            <param name="job">The job to execute.</param>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.WaitUntilEnd">
            <summary>
            Wait until ETThreadPool finished (after Dispose)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.ETThreadPool.Dispose">
            <summary>
            Implements IDisposable
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.TimerDelegate">
            <summary>
            Delegate for event handlers that can by called by a TimerList on a timer event.
            </summary>
            <param name="time">Time when the event was scheduled</param>
        </member>
        <member name="T:ET.FW.Core.Common.TimerList">
            <summary>
            Class to handle several timeouts with only one timer. An object can register 
            a timer and unregister it later before the timer delegate is called. 
            The timer is unregistered automaticly when the timer delegate is called.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.TimerList.Timers">
            <summary>
            Singleton object of a TimerList
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.TimerList"/> class.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.TimerList.timerDelegate">
            <summary>
            we need to store this delegate, otherwise the GarbageCollector would clean it up ...
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.TimerList.times">
            <summary>
            Stores all DateTimes with a corresponding list of TimeoutDelegates to start at this DateTime 
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.TimerList.timer">
            <summary>
            The Timer
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.Add(System.TimeSpan,ET.FW.Core.Common.TimerDelegate)">
            <summary>
            Add a new delegate to be started after a delay
            </summary>
            <param name="delay">Time to wait</param>
            <param name="onTimer">Delegate to call on timer</param>
            <returns>Absolute time to start the delegate.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.Add(System.Double,ET.FW.Core.Common.TimerDelegate)">
            <summary>
            Add a new delegate to be started after a delay
            </summary>
            <param name="delayms">Time to wait in milliseconds</param>
            <param name="onTimer">Delegate to call on timer</param>
            <returns>Absolute time to start the delegate.</returns>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.Remove(System.DateTime,ET.FW.Core.Common.TimerDelegate)">
            <summary>
            Removes a delegate from the timer list. The delegate might be already called when this remove starts!
            </summary>
            <param name="time">DateTime value as returned from Add</param>
            <param name="onTimer">Delegate to remove</param>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.TimeProcHandler(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Timer callback
            </summary>
            <param name="id">The identifier of the timer. The identifier is returned by the timeSetEvent function.</param>
            <param name="msg">The parameter is not used.</param>
            <param name="user">The value that was specified for the dwUser parameter of the timeSetEvent function.</param>
            <param name="param1">The parameter is not used.</param>
            <param name="param2">The parameter is not used.</param>
        </member>
        <member name="T:ET.FW.Core.Common.TimerList.TimeoutEntry">
            <summary>
            Temp storage for timer delegate and associated due time
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.TimerList.TimeoutEntry.Time">
            <summary>
            Timer delegate due time
            </summary>
        </member>
        <member name="F:ET.FW.Core.Common.TimerList.TimeoutEntry.OnTimeout">
            <summary>
            The delegate
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.TimeoutEntry.#ctor(System.DateTime,ET.FW.Core.Common.TimerDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.TimerList.TimeoutEntry"/> class.
            </summary>
            <param name="time">Due time</param>
            <param name="onTimeout">Timer delegate</param>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.TimeoutEntry.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns>Cloned TimeoutEntry</returns>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.OnTimedEventDo(System.DateTime)">
            <summary>
            Executes all delegates due up to (current time + 5ms) and restarts Timer.
            Delegates may be executed when they got deleted just a moment before!
            May be used to restart timer m_testJobRunsAfter a list change
            </summary>
            <param name="currentTime">"current time"</param>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.TimeoutCall(ET.FW.Core.Common.TimerList.TimeoutEntry)">
            <summary>
            Wrapper around timer delegate call to catch possible exceptions
            </summary>
            <param name="timeout">Timer delegate info</param>
        </member>
        <member name="M:ET.FW.Core.Common.TimerList.System#IDisposable#Dispose">
            <summary>
            Implement IDisposable.Dispose()
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.HiResDelayTimer">
            <summary>
            Wrapper for Win32 High resolution delay timer
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.HiResDelayTimer.TimerCaps">
            <summary>
            Timer capabilities
            </summary>
        </member>
        <member name="T:ET.FW.Core.Common.HiResDelayTimer.TimerProc">
            <summary>
            Represents the method that is called by Windows when a timer event occurs.
            </summary>
            <param name="id">The identifier of the timer. The identifier is returned by the timeSetEvent function.</param>
            <param name="msg">The parameter is not used.</param>
            <param name="user">The value that was specified for the dwUser parameter of the timeSetEvent function.</param>
            <param name="param1">The parameter is not used.</param>
            <param name="param2">The parameter is not used.</param>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.#ctor(ET.FW.Core.Common.HiResDelayTimer.TimerProc)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Common.HiResDelayTimer"/> class.
            </summary>
            <param name="timerOneShotEventCallback">The timer one shot event callback.</param>
        </member>
        <member name="P:ET.FW.Core.Common.HiResDelayTimer.Capabilities">
            <summary>
            Multimedia timer capabilities.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.HiResDelayTimer.Period">
            <summary>
            Period between timer events in milliseconds.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.Start">
            <summary>
            Starts this instance.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.Stop">
            <summary>
            Stops this instance.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.timeGetDevCaps(ET.FW.Core.Common.HiResDelayTimer.TimerCaps@,System.Int32)">
            <summary>
            The timeGetDevCaps function queries the timer device to determine its resolution. 
            </summary>
            <param name="timerCaps">A pointer to a TIMECAPS structure. This structure is filled with information about the resolution of the timer device. </param>
            <param name="sizeOfTimerCaps">The size, in bytes, of the TIMECAPS structure. </param>
            <returns>Returns MMSYSERR_NOERROR if successful or an error code otherwise. </returns>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.timeSetEvent(System.Int32,System.Int32,ET.FW.Core.Common.HiResDelayTimer.TimerProc,System.Int32,System.Int32)">
            <summary>
            The timeSetEvent function starts a specified timer event. The multimedia timer runs in its own thread. After the event is activated, it calls the specified callback function or sets or pulses the specified event object.
            </summary>
            <param name="delay">Event delay, in milliseconds. If this value is not in the range of the minimum and maximum event delays supported by the timer, the function returns an error. </param>
            <param name="resolution">Resolution of the timer event, in milliseconds. The resolution increases with smaller values; a resolution of 0 indicates periodic events should occur with the greatest possible accuracy. To reduce system overhead, however, you should use the maximum value appropriate for your application. </param>
            <param name="proc">Pointer to a callback function that is called once upon expiration of a single event or periodically upon expiration of periodic events. </param>
            <param name="user">User-supplied callback data. </param>
            <param name="mode">Timer event type (see MSDN for details)</param>
            <returns>Returns an identifier for the timer event if successful or an error otherwise. This function returns NULL if it fails and the timer event was not created. (This identifier is also passed to the callback function.)</returns>
        </member>
        <member name="M:ET.FW.Core.Common.HiResDelayTimer.timeKillEvent(System.Int32)">
            <summary>
            The timeKillEvent function cancels a specified timer event.
            </summary>
            <param name="id">Identifier of the timer event to cancel. This identifier was returned by the timeSetEvent function when the timer event was set up.</param>
            <returns>Returns TIMERR_NOERROR if successful or MMSYSERR_INVALPARAM if the specified timer event does not exist.</returns>
        </member>
        <member name="T:ET.FW.Core.Common.RelativeFilePath">
            <summary>
            Class to convert full paths to paths relative to a basepath
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.RelativeFilePath.#ctor(System.String,System.String)">
            <summary>
            Create a RelativeFilePath instance
            </summary>
            <param name="basePath">The base path, will not change</param>
            <param name="filePath">A file name, starting with .\ for relative, or starting with basePath for relative, or absolute else.</param>
        </member>
        <member name="P:ET.FW.Core.Common.RelativeFilePath.RelativePath">
            <summary>
            Get the path as relative (if it is relative) or as absolute path
            Set the path to a relative value (starting with .\) or as FullPath
            </summary>
        </member>
        <member name="P:ET.FW.Core.Common.RelativeFilePath.FullPath">
            <summary>
            Get a full path or set the path to a full path value. Paths within base paths are automatically detected.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Common.RelativeFilePath.IsRelativeFilePath(System.String)">
            <summary>
            Determines whether the given filePath is a relative one according
            to be used with a RelativeFilePath. This is TRUE, if filePath starts with .\
            </summary>
            <param name="filePath">The file path to check.</param>
            <returns>TRUE if filePath is a path interpreted as a relative one when used with RelativeFilePath, FALSE otherwise.</returns>
        </member>
        <member name="T:ET.FW.Core.Config.CatalogTypeAttribute">
            <summary>
            Attribute for protocol classes to declare the type of catalog used.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.CatalogTypeAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.CatalogTypeAttribute"/> class.
            </summary>
            <param name="catalogType">Type of the catalog.</param>
        </member>
        <member name="P:ET.FW.Core.Config.CatalogTypeAttribute.CatalogType">
            <summary>
            Type of catalog used for this protocol (can be catalog class or interface)
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.ChannelAccessAttribute">
            <summary>
            An attribute for declaring a channel access in an equipment.<para></para>
            In other words: Defines, what kind of ChannelAccess an equipment supports.<para></para>
            Used in TestBenchEditor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.ChannelAccessAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.ChannelAccessAttribute"/> class.
            </summary>
            <param name="channelAccessType">Type of the channel access.</param>
            <param name="port">The port name</param>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessAttribute.ChannelAccessType">
            <summary>
            The type of the channel access.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessAttribute.Port">
            <summary>
            The port number of the channel. This must be unique within an equipment.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.ChannelAccessRangeAttribute">
            <summary>
            Attribute to declare a range of channel accesses of same type.
            Standard usage of this attribute is at equipments which contain multiple channel accesses of same type.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.ChannelAccessRangeAttribute.#ctor(System.Type,System.String,System.UInt32,System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.ChannelAccessRangeAttribute" /> class.
            </summary>
            <param name="channelAccessType">Type of the channel accesses.</param>
            <param name="prefix">Port name prefix.</param>
            <param name="maxNumber">The maximum number of channel accesses (optional)</param>
            <param name="defaultNumber">Default number of channel accesses.</param>
        </member>
        <member name="M:ET.FW.Core.Config.ChannelAccessRangeAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.ChannelAccessRangeAttribute" /> class.
            </summary>
            <param name="channelAccessType">Type of the channel accesses.</param>
            <param name="prefix">Port name prefix.</param>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessRangeAttribute.ChannelAccessType">
            <summary>
            The type of the channel accesses.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessRangeAttribute.Prefix">
            <summary>
            Prefix for channel access port names.
            Port names are composed of this prefix and port number (beginning with 1)
            For Example CAN1, CAN2,... (prefix is CAN)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessRangeAttribute.MaxNumber">
            <summary>
            Optional maximum number of supported ports
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelAccessRangeAttribute.DefaultNumber">
            <summary>
            Default number of ports
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.ChannelTypeAttribute">
            <summary>
            An attribute to determine the type of the channel access.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.ChannelTypeAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.ChannelTypeAttribute"/> class.
            </summary>
            <param name="portType">The type of the channel.</param>
        </member>
        <member name="P:ET.FW.Core.Config.ChannelTypeAttribute.PortType">
            <summary>
            Gets the type of the channel.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.EquipmentDependencyAttribute">
            <summary>
            An attribute for equipment dependency.<para></para>
            In other words: defines, which equipment(s) an ExternalDevice depends on.<para></para>
            Used in TestBenchEditor.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.EquipmentDependencyAttribute.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="dependencyType">The type of the equipment dependency.</param>
        </member>
        <member name="M:ET.FW.Core.Config.EquipmentDependencyAttribute.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="dependencyName">The class name of the equipment dependency.</param>
        </member>
        <member name="P:ET.FW.Core.Config.EquipmentDependencyAttribute.DependencyType">
            <summary>
            Gets or sets the type of the dependency.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.EquipmentDependencyAttribute.DependencyName">
            <summary>
            Gets or sets the class name of the dependency.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.EquipmentTypeAttribute">
            <summary>
            An attribute to determine the type of the equipment.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.EquipmentTypeAttribute.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="type">The type of the equipment.</param>
        </member>
        <member name="P:ET.FW.Core.Config.EquipmentTypeAttribute.EquipmentType">
            <summary>
            gets the type of the equipment.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.OfflineProtocolPortTypeAttribute">
            <summary>
            Attribute for IOfflineProtocolFactorys, describing the
            PortTypes, for which an OfflineProtocol can be created.
            Used in Testbench
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.OfflineProtocolPortTypeAttribute.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="portType">The PortType</param>
        </member>
        <member name="P:ET.FW.Core.Config.OfflineProtocolPortTypeAttribute.PortType">
            <summary>
            Gets the PortTypes, for which an OfflineProtocol can be created.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Config.HWProtocolAttribute">
            <summary>
            Declaration attribute for ChannelAccess protocol. Attribute provides HW protocol information for configuration.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Config.HWProtocolAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.HWProtocolAttribute" /> class. This constructor allows different identifier and implementation class names.
            </summary>
            <param name="implementation">Protocol implementation class.</param>
            <param name="identifier">The name of the protocol in the configuration (could be different from implementation class name)</param>
        </member>
        <member name="M:ET.FW.Core.Config.HWProtocolAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Config.HWProtocolAttribute" /> class.
            Use this constructor if protocol identifier is equal to implementation class name.
            </summary>
            <param name="implementation">Protocol implementation class.</param>
        </member>
        <member name="P:ET.FW.Core.Config.HWProtocolAttribute.Identifier">
            <summary>
            Gets the name of the protocol which will be used in the configuration file.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Config.HWProtocolAttribute.Implementation">
            <summary>
            Type of protocol implementation used by the channel access
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.DecoupledEventExtensions">
            <summary>
            Extension class for events. Class contains methods to raise decoupled events.
            Class provides optimized methods for events using recommended event pattern.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.RaiseDecoupled(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Raise decoupled events with recommended standard event handler and parameter types.
            Event must be implemented following the standard design patterns using EventHandler delegate.
            </summary>
            <remarks>
            Optimized version for events using EventHandler delegate.
            </remarks>
            <param name="eventDelegate">Event delegate which raises the event</param>
            <param name="sender">Event sender parameter</param>
            <param name="args">Event arguments parameter</param>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.RaiseDecoupled``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Raise decoupled events with recommended standard event handler and parameter types.
            Event must be implemented following the standard design patterns using EventHandler&lt;&gt; delegate.
            </summary>
            <remarks>
            Optimized version for events using EventHandler&lt;&gt; delegate.
            Type parameter may not be specified, method is used automatically if event matches parameters.
            </remarks>
            <typeparam name="TArgs">Type of second event handler parameter e, must be derived from EventArgs</typeparam>
            <param name="eventDelegate">Event delegate which raises the event</param>
            <param name="sender">Event sender parameter</param>
            <param name="args">Event arguments parameter</param>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.RaiseDecoupled``1(ET.FW.Core.Common.ValueChangedEventHandler{``0},System.Object,ET.FW.Core.Common.ValueChangedEventArgs{``0})">
            <summary>
            Raise decoupled events of type ValueChangedEventHandler&lt;&gt; delegate (e.g. ObservableObject).
            </summary>
            <remarks>
            Optimized version for events using ValueChangedEventHandler&lt;&gt;
            Type parameter may not be specified, method is used automatically if event matches parameters.
            </remarks>
            <typeparam name="TValue">Type of value which is wrapped in event args object</typeparam>
            <param name="eventDelegate">Event delegate which raises the event</param>
            <param name="sender">Event sender parameter</param>
            <param name="args">Event arguments parameter</param>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.RaiseDecoupledWithLog``1(ET.FW.Core.Common.ValueChangedEventHandler{``0},System.Object,ET.FW.Core.Common.ValueChangedEventArgs{``0})">
            <summary>
            Raise decoupled events of type ValueChangedEventHandler&lt;&gt; delegate (e.g. ObservableObject).
            </summary>
            <remarks>
            Optimized version for events using ValueChangedEventHandler&lt;&gt;
            Type parameter may not be specified, method is used automatically if event matches parameters.
            </remarks>
            <typeparam name="TValue">Type of value which is wrapped in event args object</typeparam>
            <param name="eventDelegate">Event delegate which raises the event</param>
            <param name="sender">Event sender parameter</param>
            <param name="args">Event arguments parameter</param>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.RaiseDecoupled(System.Delegate,System.Object[])">
            <summary>
            Raise decoupled events with non standard event handler
            </summary>
            <param name="eventDelegate">event delegate which raises the event</param>
            <param name="paras">event parameters</param>
        </member>
        <member name="M:ET.FW.Core.Events.DecoupledEventExtensions.CheckTarget(System.Object,System.Delegate)">
            <summary>
            Checks an event handler target for decoupling.
            For some time criticat events the events subscriber should implement event decouping. This method checks if the target object of an event handler supports decoupling.
            </summary>
            <param name="source">The event source. Argument is used for error logging.</param>
            <param name="handler">The event handler of the target object</param>
            <returns>true for event handlers which support event decoupling</returns>
        </member>
        <member name="T:ET.FW.Core.Events.EventDecoupler">
            <summary>
            Event decoupler implementation: Incoming decoupled events are handled asyncronously.
            Events are queued and handlers are called via separate thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.#ctor">
            <summary>
            Constructor.
            Event thread gets priority of current thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.#ctor(System.String)">
            <summary>
            Constructor.
            Event thread gets priority of current thread.
            </summary>
            <param name="name">Decoupler name used for logging, debugging</param>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.#ctor(System.String,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Events.EventDecoupler"/> class.<para></para>
            Starts a guard which kills and reinitializes the event-process if an event-handling
            lasts longer than the given timespan.
            </summary>
            <param name="name">The name.</param>
            <param name="maxHandlingDuration">Duration of the max handling.</param>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.#ctor(System.Threading.ThreadPriority)">
            <summary>
            the Constructor.
            </summary>
            <param name="priority">Thread priority for event handling thread</param>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.#ctor(System.String,System.Threading.ThreadPriority)">
            <summary>
            the Constructor.
            </summary>
            <param name="name">Decoupler name used for logging, debugging</param>
            <param name="priority">Thread priority for event handling thread</param>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.CreateEventThread(System.String,System.Threading.ThreadPriority)">
            <summary>
            Create and assign the EventThread
            </summary>
            <param name="name">Name of the thread</param>
            <param name="priority">Priority of the thread</param>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.doTimeoutCheck">
            <summary>
            Flag which is set to TRUE if the maxHandlingDuration of an event shall be guarded
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.killTimeout">
            <summary>
            The time when the last started event-handling must have been finished.<para></para>
            Set to DateTime.MaxValue when no event is being handled.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.maxHandlingDuration">
            <summary>
            The defined maximum timespan the handling of a single event may may last.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.NewEvent(System.Delegate,System.Object[])">
            <summary>
            Input method for new events to be decoupled
            </summary>
            <param name="del">event handler delegate </param>
            <param name="args">event arguments</param>
        </member>
        <member name="P:ET.FW.Core.Events.EventDecoupler.HasEvents">
            <summary>
            Check if events are waiting in queue
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.eventQueue">
            <summary>
            Event queue
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.eventThread">
            <summary>
            Event handling thread
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.guardThread">
            <summary>
            GuardThread which observes the eventThread for not exeeding the maximum duration.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.threadPriority">
            <summary>
            Priority for the eventThread
            </summary>
        </member>
        <member name="P:ET.FW.Core.Events.EventDecoupler.Priority">
            <summary>
            Priority of event thread
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.newEvent">
            <summary>
            Synchronization object to wake up event handling thread, as soon as new events are enqueued
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.GuardProc">
            <summary>
            This method is the kill-guard, if a maxHandlingduration was passed
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.ThreadProc">
            <summary>
            Event handling thread:
            - Wait for new events in queue
            - Dequeue event data
            - Call event handler via its delegate
            </summary>
            <remarks>TODO: optimize delegate invokation (Delegate.DynamicInvoke() is costly operation)</remarks>
        </member>
        <member name="F:ET.FW.Core.Events.EventDecoupler.disposed">
            <summary>
            Flag is set when this object is disposed
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.Dispose">
            <summary>
            Shutdown this object:
            - Set disposed flag
            - Clear event queue
            - Stop event handling thread
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupler.Finalize">
            <summary>
            Finalyzer: dispose object if not already done
            </summary>
        </member>
        <member name="P:ET.FW.Core.Events.EventDecoupler.Name">
            <summary>
            Name is used for logging, debugging
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.EventData">
            <summary>
            Helper class to store event data
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventData.#ctor(System.Delegate,System.Object[])">
            <summary>
            the Constructor.
            </summary>
            <param name="del">event delegate</param>
            <param name="paras">event parameters</param>
        </member>
        <member name="F:ET.FW.Core.Events.EventData.Delegate">
            <summary>
            Event delegate, used to invoke event handler
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.EventData.Paras">
            <summary>
            Event parameters
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.EventDecoupling">
            <summary>
            Event decoupling implementation, class can be used as base class for other classes which handle (receive) decoupled events
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupling.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Events.EventDecoupling"/> class.
            </summary>
            <param name="name">decoupler name, used for debugging, logging</param>
        </member>
        <member name="P:ET.FW.Core.Events.EventDecoupling.Decoupler">
            <summary>
             Decoupler which does the event decoupling
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.EventDecoupling.Dispose">
            <summary>
            Shutdown decoupler
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.GuiEventDecoupler">
            <summary>
            Event decoupler implementation for GUI thread: Incoming decoupled events are handled asyncronously.
            Events are queued and handlers are called via GUI thread.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.GuiEventDecoupler.#ctor(System.ComponentModel.ISynchronizeInvoke)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Events.GuiEventDecoupler"/> class.
            </summary>
            <param name="control">The control, which provides the GUI thread to use for event handler invokation</param>
        </member>
        <member name="F:ET.FW.Core.Events.GuiEventDecoupler.control">
            <summary>
            The control providing GUI thread to use for event handler invokation
            </summary>
        </member>
        <member name="F:ET.FW.Core.Events.GuiEventDecoupler.disposed">
            <summary>
            Disposed flag, stops invokation of events
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.GuiEventDecoupler.NewEvent(System.Delegate,System.Object[])">
            <summary>
            Input method for new events to be decoupled
            </summary>
            <param name="del">event handler delegate</param>
            <param name="args">event arguments</param>
        </member>
        <member name="M:ET.FW.Core.Events.GuiEventDecoupler.Dispose">
            <summary>
            Dispose this decoupler: stop invokation of events (already running event handlers continue execution)
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.IEventDecoupling">
            <summary>
            Interface to be implemented by classes which register and handle decoupled events
            </summary>
        </member>
        <member name="P:ET.FW.Core.Events.IEventDecoupling.Decoupler">
            <summary>
            Access to Decoupler which does the event decoupling
            </summary>
        </member>
        <member name="T:ET.FW.Core.Events.IEventDecoupler">
            <summary>
            Interface of event decoupler which handles the event queue and thread for decoupling
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.IEventDecoupler.NewEvent(System.Delegate,System.Object[])">
            <summary>
            Input method for new events to be decoupled
            </summary>
            <param name="del">event handler delegate </param>
            <param name="args">event arguments</param>
        </member>
        <member name="T:ET.FW.Core.Events.INoEventDecoupling">
            <summary>
            Marker interface, to indicate that derived class does not use event decoupling for subscribed events.
            </summary>
            <remarks>
            Subscription code for some events checks for decoupling and issues a warning if event target does not support event decoupling.
            If it is sure, that the event handlers are not time consuming and have no side effect and you want to consume the event without warning, you may implement this interface.
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Events.TEventArgs`1">
            <summary>
            Generic extension of EventArgs
            </summary>
            <typeparam name="T">Type of the values</typeparam>
        </member>
        <member name="P:ET.FW.Core.Events.TEventArgs`1.OldValue">
            <summary>
            The old value
            </summary>
        </member>
        <member name="P:ET.FW.Core.Events.TEventArgs`1.NewValue">
            <summary>
            The new value
            </summary>
        </member>
        <member name="M:ET.FW.Core.Events.TEventArgs`1.#ctor(`0,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Events.TEventArgs`1"/> class.
            </summary>
            <param name="oldValue">The old value.</param>
            <param name="newValue">The new value.</param>
        </member>
        <member name="T:ET.FW.Core.Hal.IErrorQueryable">
            <summary>
            Interface to query status / error messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IErrorQueryable.ClearErrors">
            <summary>
            Clears errors
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IErrorQueryable.HasErrors">
            <summary>
            True if device has errors
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IErrorQueryable.Errors">
            <summary>
            Queried Errors
            </summary>
        </member>
        <member name="E:ET.FW.Core.Hal.IErrorQueryable.ErrorsEvent">
            <summary>
            Errors event handler
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.QueryErrorEventArgs">
            <summary>
            error event args
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.QueryErrorEventArgs.Errors">
            <summary>
            Queried Errors
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.QueryErrorEventArgs.#ctor(System.Collections.Generic.IEnumerable{ET.FW.Core.Hal.QueryError})">
            <summary>
            The constructor
            </summary>
            <param name="errors">Queried errors</param>
        </member>
        <member name="T:ET.FW.Core.Hal.QueryError">
            <summary>
            Error of query
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.QueryError.Kind">
            <summary>
            Kind of error
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.QueryError.Message">
            <summary>
            Message of error
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.QueryError.#ctor(ET.FW.Core.Hal.ErrorKind,System.String)">
            <summary>
            The constructor
            </summary>
            <param name="kind">Kind of error</param>
            <param name="message">The message</param>
        </member>
        <member name="T:ET.FW.Core.Hal.ErrorKind">
            <summary>
            Error kind
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ErrorKind.SystemError">
            <summary>
            System internal error
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ErrorKind.DeviceError">
            <summary>
            Device error
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.ISynchronizedDevice">
            <summary>
            Interface definition for external devices for synchonized calls
            </summary>
        </member>
        <member name="E:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedStatusEvent">
            <summary>
            Event to notified device busy or not available 
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.ISynchronizedDevice.IsBusy">
            <summary>
            Gets a value indicating whether this <see cref="T:ET.FW.Core.Hal.IExternalDevice"/> is busy on operating.
            </summary>
            <value><c>true</c> if busy; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedGetProperty``1(System.Func{``0})">
            <summary>
            Synchronized Get Property
            </summary>
            <typeparam name="T">Type of property</typeparam>
            <param name="funcGet">Get function</param>
            <returns>Value of property</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedSetProperty``1(System.Action{``0},``0)">
            <summary>
            Synchronized Set Property
            </summary>
            <typeparam name="T">Type of property</typeparam>
            <param name="funcSet">Set function</param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``1(System.Func{``0})">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``2(System.Func{``0,``1},``0)">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TParam">Type of Parameter</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <param name="param">The parameter</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``3(System.Func{``0,``1,``2},``0,``1)">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TParam1">Type of Parameter1</typeparam>
            <typeparam name="TParam2">Type of Parameter2</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <param name="param1">The parameter1</param>
            <param name="param2">The parameter2</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``4(System.Func{``0,``1,``2,``3},``0,``1,``2)">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TParam1">Type of Parameter1</typeparam>
            <typeparam name="TParam2">Type of Parameter2</typeparam>
            <typeparam name="TParam3">Type of Parameter3</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <param name="param1">The parameter1</param>
            <param name="param2">The parameter2</param>
            <param name="param3">The parameter3</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2,``3)">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TParam1">Type of Parameter1</typeparam>
            <typeparam name="TParam2">Type of Parameter2</typeparam>
            <typeparam name="TParam3">Type of Parameter3</typeparam>
            <typeparam name="TParam4">Type of Parameter4</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <param name="param1">The parameter1</param>
            <param name="param2">The parameter2</param>
            <param name="param3">The parameter3</param>
            <param name="param4">The parameter4</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCall``6(System.Func{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4)">
            <summary>
            Synchronized On call
            </summary>
            <typeparam name="TParam1">Type of Parameter1</typeparam>
            <typeparam name="TParam2">Type of Parameter2</typeparam>
            <typeparam name="TParam3">Type of Parameter3</typeparam>
            <typeparam name="TParam4">Type of Parameter4</typeparam>
            <typeparam name="TParam5">Type of Parameter5</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Call function</param>
            <param name="param1">The parameter1</param>
            <param name="param2">The parameter2</param>
            <param name="param3">The parameter3</param>
            <param name="param4">The parameter4</param>
            <param name="param5">The parameter5</param>
            <returns>Value of result</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCallAsync``1(System.Func{``0},System.TimeSpan)">
            <summary>
            Sends the specified request.
            The Result of the RequestJob contains the answer.
            </summary>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Get function</param>
            <param name="timeout">The timeout for the request.</param>
            <returns>
            The job containing the answer of the device.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCallAsync``2(System.Func{``0,``1},``0,System.TimeSpan)">
            <summary>
            Sends the specified request.
            The Result of the RequestJob contains the answer.
            </summary>
            <typeparam name="TParam">Type of Parameter</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Get function</param>
            <param name="param">The parameter</param>
            <param name="timeout">The timeout for the request.</param>
            <returns>
            The job containing the answer of the device.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ISynchronizedDevice.SynchronizedOnCallAsync``3(System.Func{``0,``1,``2},``0,``1,System.TimeSpan)">
            <summary>
            Sends the specified request.
            The Result of the RequestJob contains the answer.
            </summary>
            <typeparam name="TParam1">Type of Parameter1</typeparam>
            <typeparam name="TParam2">Type of Parameter2</typeparam>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="funcCall">Get function</param>
            <param name="param1">The parameter1</param>
            <param name="param2">The parameter2</param>
            <param name="timeout">The timeout for the request.</param>
            <returns>
            The job containing the answer of the device.
            </returns>
        </member>
        <member name="T:ET.FW.Core.Hal.SynchronizedStatusEventArgs">
            <summary>
            Synchronized status EventArgs
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.SynchronizedStatusEventArgs.IsBusy">
            <summary>
            True if device is busy, otherwise device is not available
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.SynchronizedStatusEventArgs.#ctor(System.Boolean)">
            <summary>
            The constructor
            </summary>
            <param name="busy">True if device is busy, otherwise device is not available</param>
        </member>
        <member name="T:ET.FW.Core.Hal.DebugTimestampCorrection">
            <summary>
            Implementation which uses the ETTimestampCorrection + Additional output 
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.DebugTimestampCorrection.#ctor(System.String)">
            <summary>
            constructor of the correction
            </summary>
            <param name="name">name of the correction</param>
        </member>
        <member name="M:ET.FW.Core.Hal.DebugTimestampCorrection.#ctor(System.String,System.TimeSpan)">
            <summary>
            constructor with Latency
            </summary>
            <param name="name">name of the correction</param>
            <param name="latency">Latency between hw and pc</param>
        </member>
        <member name="M:ET.FW.Core.Hal.DebugTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.DebugTimestampCorrection.Reset">
            <summary>
            Got a Reset, so store this by adding a null/now-Pair and call reset
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.DebugTimestampCorrection.Dispose">
            <summary>
            Debug in here to save all the collected Timestamps
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.DummyTimestampCorrection">
            <summary>
            Base implementation with the easiest (do nothing) algorithm for timestamp adjustment 
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.DummyTimestampCorrection.adjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.DummyTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>The adjusted Timestamp</returns>
        </member>
        <member name="P:ET.FW.Core.Hal.DummyTimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.ETClockTimestampCorrection">
            <summary>
            Implementation which is just using the ETClock  
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ETClockTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTime">Hardware Timestamp</param>
            <param name="etcTime">ETClock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the Adjusted Timestamp, in this case the ETClock-Timestamp</returns>
        </member>
        <member name="T:ET.FW.Core.Hal.ETTimestampCorrection">
            <summary>
            Timestamp: all times are UTC
            used to correct the HW time from external time source to the FW time
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.hwLast">
            <summary>
            HW time (including offset) of last message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.etcLast">
            <summary>
            ETClock time of last message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.adjustedLast">
            <summary>
            Adjusted time of last message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.ETTimestampCorrection.Latency">
            <summary>
            Additional offset time to compensate message Latency
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.#ctor(System.String)">
            <summary>
            default constructor
            </summary>
            <param name="name">Name of the correction</param>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.#ctor(System.String,System.TimeSpan)">
            <summary>
            Constructor of the correction
            </summary>
            <param name="name">The name of the correction</param>
            <param name="latency">Compensation offset for message Latency</param>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.adjustLock">
            <summary>
            sync-object for multithreading
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.OffsetCorrectionDivisor">
            <summary>
            Offset correction divisor, contolling how many ticks will be "shifted" per tick of etc-time.
            Shift value is difference between currend and last message HW times divided by this divisor.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.EtcTolerance">
            <summary>
            ET-Clock tolerance for identical hwTimestamps
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.FutureTolerance">
            <summary>
            Tolerance for future Timestamps
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.MaxJumpTolerance">
            <summary>
            Maximum tolerance for hw-timestamp jumps
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.hwDiff2Last">
            <summary>
            difference of HW-Times
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.ETTimestampCorrection.etcDiff2Last">
            <summary>
            difference of SW-Times
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.ETTimestampCorrection.StackTraceString">
            <summary>
            Returns a StackTraceString if the maximum number of stacktraces has not
            been reached yet. Otherwise an empty string is returned.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>The adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.Init(System.DateTime,System.DateTime)">
            <summary>
            (Re-)Initialize Timestamp-Correction
            </summary>
            <param name="hwTimestamp">the hw timestamp</param>
            <param name="etcTimestamp">the pc timestamp</param>
            <returns>the adjusted timesamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.Reset">
            <summary>
            Reset the correction by setting hwLast to MinValue. This will trigger an Init for the next Adjust
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ETTimestampCorrection.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.ETTimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.IChannelAccess">
            <summary>
            Public base interface for ET Framework channel access / hardware port
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IChannelAccess.Equipment">
            <summary>
            Equipment/box which contains this channel access
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IChannelAccess.PortName">
            <summary>
            Port name e.g. 'COM1' or 'MOST Node'
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IChannelAccess.Information">
            <summary>
            Retrieves information about the channel access.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IChannelAccess.CreateHardwareProtocol(System.String,System.String)">
            <summary>
            Provide Hardware protocol of given type
            </summary>
            <param name="type">Type/class name of protocol to provide</param>
            <param name="name">Name of protocol instance</param>
            <returns>Matching protocol or null if not available</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IChannelAccess.GetTypeOfHardwareProtocol(System.String,System.String)">
            <summary>
            Returns the Type of the Protocol, which is created by CreateHardwareProtocol
            with the corresponding parameters.<para></para>
            This method must be overridden by all those ChannelAccesses using protocols,
            which may define further dependencies via Attributes.
            </summary>
            <param name="type">Type/class name of protocol to provide</param>
            <param name="name">Name of protocol instance</param>
            <returns>Type of the protocol or null</returns>
        </member>
        <member name="T:ET.FW.Core.Hal.IEquipment">
            <summary>
            Public ET Framework Equipment interface
            Equipment is a hardware box or interface, that provides one or more hardware ports (Channel Accesses) for framework use
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.Type">
            <summary>
            Device type
            </summary>
            <remarks>
            Type of the underlying HW device.
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.Information">
            <summary>
            Retrieves general information about the device. The returned value maybe a multi line String (by using \\r\\n).
            </summary>
            <value></value>
            <returns>General information about the device.</returns>
            <example>
            As example following values may be reported:
            - Serial numbers identifying parts inside the device.
            - Hardware dependend addresses like MAC-Address.
            - Revision of hardware and software components inside the device (Mainboard-, FPGA bitsream Revision e.g.)
            </example>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.SerialNumber">
            <summary>
            Hardware serial number
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.HardwareName_index">
            <summary>
            Harware index number
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.PortName">
            <summary>
            Portname from testbench.xml
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipment.CreateChannelAccess(System.String,System.String,System.String)">
            <summary>
            Create/provide channel access
            </summary>
            <param name="portName">Hardware port name</param>
            <param name="name">Channel access name</param>
            <param name="portType">Port type for channel access</param>
            <returns>The matching channel access, null if none can be provided</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipment.GetChannelAccessType(System.String,System.String)">
            <summary>
            Returns the Type of the ChannelAccess to be created for portName 
            with the given name. <para></para>
            This method must be implemented by all those Equipment using ChannelAccesses,
            which may have further dependencies, which are described in Attributes.
            </summary>
            <param name="portName">Hardware port name</param>
            <param name="name">Channel access name</param>
            <returns>Type of the ChannelAccess to be created for portName with the given name.</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipment.Connect">
            <summary>
            Connect to hardware
            </summary>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipment.Disconnect">
            <summary>
            Disconnect hardware
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.IsConnected">
            <summary>
            Check if hardware is connected
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.TimestampCorrection">
            <summary>
            Timestamp correction (used for external devices with own time base to calculate message timestamp)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipment.DefaultLatency">
            <summary>
            The equipment specific latency, if not set the default of none is returned
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.IEquipmentManager">
            <summary>
            Interface for EquipmentManagers
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.GetEquiment(System.String)">
            <summary>
            Gets equipment object with name
            </summary>
            <param name="name">equipment name to get</param>
            <returns>created equipment, null if no equipment available</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.CreateEquipment(System.String)">
            <summary>
            Create new equipment object, object is not assigned to a special HW
            </summary>
            <param name="name">equipment name to set</param>
            <returns>newly created equipment, null if no equipment available</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.CreateEquipment(System.String,System.String)">
            <summary>
            Create equipment for given serial number
            </summary>
            <param name="name">equipment name to set</param>
            <param name="serial">serial number of equipment</param>
            <returns>newly created eqipment for HW box with given serial number, null if no box with serial available</returns>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipmentManager.Equipments">
            <summary>
            Collection of already configured (created) equipment objects
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipmentManager.EquipmentType">
            <summary>
            Type of equipment handled by this manager
            </summary>
            <remarks>
            Corresponds to XML-Attribute "DeviceType" in testbench.xml config file
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.Init">
            <summary>
            Initialize manager.
            May be used to find connected devices etc.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.IEquipmentManager.IsReady">
            <summary>
            Equipmnet manager is initialized
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.RemoveEquipment(ET.FW.Core.Hal.IEquipment)">
            <summary>
            Remove the given Equipment
            </summary>
            <param name="equipment">The Equipment to remove</param>
        </member>
        <member name="M:ET.FW.Core.Hal.IEquipmentManager.DisconnectEquipments">
            <summary>
            Disconnects all equipments.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.IExternalDevice">
            <summary>
            Interface definition for external devices.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IExternalDevice.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Initializes the device.
            </summary>
            <param name="downlinks">list of downlink protocols</param>
            <returns>
            	<c>true</c> if successful; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:ET.FW.Core.Hal.IExternalDevice.Available">
            <summary>
            Gets a value indicating whether this <see cref="T:ET.FW.Core.Hal.IExternalDevice"/> is available.
            </summary>
            <value><c>true</c> if available; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:ET.FW.Core.Hal.ITimestampCorrection">
            <summary>
            Interface for timestamp adjustment
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ITimestampCorrection.AdjustTime(System.DateTime)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTime">the HW Timestamp</param>
            <returns>The adjusted Timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ITimestampCorrection.AdjustTime(System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ITimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.ITimestampCorrection.AdjustTime(System.DateTime,System.DateTime)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp and pc-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="P:ET.FW.Core.Hal.ITimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.ITimestampCorrection.Reset">
            <summary>
            Reset all the offsets and pitches
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.IInitBusWithProtocolsChannelAccessAndOfflineMode">
            <summary>
            Interface for Busses which need to be initialised with Protocols, ChannelAccess and
            Offline-Mode-Parameter.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.IInitBusWithProtocolsChannelAccessAndOfflineMode.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol},ET.FW.Core.Hal.IChannelAccess,System.Boolean)">
            <summary>
            Initialize
            </summary>
            <param name="protocols">List with IProtocol</param>
            <param name="channelAccess">The corresponding ChannelAccess</param>
            <param name="offline">TRUE, if initializing Offline-mode, FALSE otherwise</param>
            <returns>TRUE, if initialization succeeded, FALSE otherwise.</returns>
        </member>
        <member name="T:ET.FW.Core.Hal.IOutputChannelAccess`1">
            <summary>
            Public base interface for ET Framework channel access / hardware port with output event
            </summary>
            <typeparam name="TMessage">The type of the message.</typeparam>
        </member>
        <member name="T:ET.FW.Core.Hal.OffsetTimestampCorrection">
            <summary>
            Implementation which is just adding a offset to the Timestamp
            offset is set with first message as difference between ETClock and HW time
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.OffsetTimestampCorrection.etcLast">
            <summary>
            ETClock time of last message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.OffsetTimestampCorrection.adjustedLast">
            <summary>
            Adjustet time of last message
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.OffsetTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTime">the HW-Timestamp</param>
            <param name="etcTime">the ET-Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted Timestamp</returns>
        </member>
        <member name="P:ET.FW.Core.Hal.OffsetTimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.OffsetTimestampCorrection.Reset">
            <summary>
            Reset the correction
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.PCClockTimestampCorrection">
            <summary>
            Timestamp correction for times which were generated using local time from standard PC realtime clock(DateTime.Now)
            </summary>
            <remarks>
            Implementation assumes that offest between ETClock and PC realtime clock is nearly constant between the time the realtime clock was querried and the time the timestamp is adjusted
            Current implementation may fail on start/end of daylight saving time!
            </remarks>
        </member>
        <member name="F:ET.FW.Core.Hal.PCClockTimestampCorrection.offsetLast">
            <summary>
            The last calculated offset between ETClock and RTC
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.PCClockTimestampCorrection.etcLast">
            <summary>
            ETClock time of last message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Hal.PCClockTimestampCorrection.adjustedLast">
            <summary>
            Adjustet time of last message
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.PCClockTimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Calculate ET time from PC realtime clock time
            </summary>
            <param name="hwTimestamp">realtime clock timestamp</param>
            <param name="etcNow">ET timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>adjusted time</returns>
            <remarks>
            Implementation calculated current offset of realtime and ET clock and applies it to given HW time
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Hal.PCClockTimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="P:ET.FW.Core.Hal.PCClockTimestampCorrection.Instance">
            <summary>
            Get singelton, one instance may be used for all sources which use PC realtime clock
            </summary>
        </member>
        <member name="T:ET.FW.Core.Hal.TimestampCorrection">
            <summary>
            abtract class for all Timestamp-Corrections
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.#ctor(System.String)">
            <summary>
            Default constructor with name
            </summary>
            <param name="name">name of the correction</param>
        </member>
        <member name="P:ET.FW.Core.Hal.TimestampCorrection.Name">
            <summary>
            Timestamp name
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.AdjustTime(System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.AdjustTime(System.DateTime)">
            <summary>
            Adjust the timestamp using HW-Time and convert to SW-Time.
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.AdjustTime(System.DateTime,System.DateTime,System.Boolean,ET.FW.Core.Messaging.MessageError@)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <param name="forcePlausible">force calculation of plausible timestamps in case of jump if set to true</param>
            <param name="error">return MessageError if jump in timestamp detected</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.AdjustTime(System.DateTime,System.DateTime)">
            <summary>
            delivers the corrected sw-timestamp out of hw-timestamp
            </summary>
            <param name="hwTimestamp">HW-Timestamp of the message</param>
            <param name="etcNow">ET-Clock Timestamp</param>
            <returns>the adjusted timestamp</returns>
        </member>
        <member name="P:ET.FW.Core.Hal.TimestampCorrection.AdjustedLatency">
            <summary>
            The Latency of the last timestamp meaning the difference between the ETClock-timestamp and the adjusted timestamp
            </summary>
        </member>
        <member name="M:ET.FW.Core.Hal.TimestampCorrection.Reset">
            <summary>
            Reset the correction by resetting all the offsets and pitches
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.AsyncJob">
            <summary>
            Abstract base class for async jobs.
            Method Execute() is invoked asynchrounous in Start() method
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.AsyncJob.#ctor(System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="timeout">Default timeout for job execution, Job.WaitInfinite (-1 milliseconds) for no timeout.</param>
            <remarks>If timeout is set, job is aborted when timeout has expired</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.AsyncJob.Start">
            <summary>
            Mark job as started and start async execution
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.AsyncJob.Execute">
            <summary>
            Method to be overloaded for asynchronous execution
            </summary>
            <remarks>
            Method should call Completed() or Failed() to inform JobHandling about job execution result
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.DelaySequenceMode">
            <summary>
            Execution modes for delayed sequence
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.DelaySequenceMode.Undefined">
            <summary>
            No mode set, use default (WaitCompletion)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.DelaySequenceMode.WaitCompletion">
            <summary>
            Execution of next step is not started before current step is finished, even if delay time is expired.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.DelaySequenceMode.ForceTime">
            <summary>
            Execution of next step starts after delay time of current job expires. If current job is still running when its delay time expires, it is aborted.
            </summary>
            <remarks>
            Job timeouts of sequence job is manipulated in this mode. Inner job timeouts are set to corresponding delay times, to ensure job is aborted i delay time is over.
            </remarks>
        </member>
        <member name="F:ET.FW.Core.Jobs.DelaySequenceMode.WaitCompletionPlusDelay">
            <summary>
            Delay time is started after inner job completes. Step duration is job execution time plus delay time.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.DelaySequenceJob">
            <summary>
            Special sequence job, which associates every executed job with a minimum delay time.
            Sequence job ensures minimum delay time before execution of next job, even if current job finishes before delay time expires
            </summary>
            <remarks>
            Do not use already started or even finished jobs.
            If one or more of the jobs are already running or even failed, aborted or completed then the whole sequence will fail.
            This is the designed behaviour because in this case the sequence was not correct.
            If execution of an inner job is not completed successfully, the behaviour depends on the inner jobs final state:
            - If inner job was aborted (e.g. due to timeout), the sequence continues with the next step (after delay time is finished).
            - If inner job failed, Sequence execution fails too. In this case the sequence execution is stopped.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.#ctor(System.TimeSpan,ET.FW.Core.Jobs.DelaySequenceMode,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.DelaySequenceJob" /> class.
            This constructor is used for sequences with fixed size and up to 5 elements
            </summary>
            <param name="timeout">Timeout for execution of sequence</param>
            <param name="mode">Execution mode, controlling the step timing</param>
            <param name="job1">First job to execute</param>
            <param name="delay1">Delay of first job.</param>
            <param name="job2">Optional second job to execute</param>
            <param name="delay2">Delay of second job.</param>
            <param name="job3">Optional third job to execute</param>
            <param name="delay3">Delay of third job.</param>
            <param name="job4">Optional fourth job to execute</param>
            <param name="delay4">Delay of fourth job.</param>
            <param name="job5">Optional fifth job to execute</param>
            <param name="delay5">Delay of fifth job.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.#ctor(ET.FW.Core.Jobs.DelaySequenceMode,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan,ET.FW.Core.Jobs.IJob,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.DelaySequenceJob"/> class.
            This constructor is used for sequences with fixed size and up to 5 elements
            Sequence timeout will be calculated from sequence step durations.
            </summary>
            <param name="mode">Execution mode, controlling the step timing</param>
            <param name="job1">First job to execute</param>
            <param name="delay1">Delay of first job.</param>
            <param name="job2">Optional second job to execute</param>
            <param name="delay2">Delay of second job.</param>
            <param name="job3">Optional third job to execute</param>
            <param name="delay3">Delay of third job.</param>
            <param name="job4">Optional fourth job to execute</param>
            <param name="delay4">Delay of fourth job.</param>
            <param name="job5">Optional fifth job to execute</param>
            <param name="delay5">Delay of fifth job.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.#ctor(ET.FW.Core.Jobs.DelaySequenceMode,System.TimeSpan,ET.FW.Core.Jobs.JobDurationPair[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.DelaySequenceJob"/> class.
            </summary>
            <param name="mode">Execution mode, controlling the step timing</param>
            <param name="timeout">Timeout for execution of sequence</param>
            <param name="steps">Array of sequence steps (job and delay).</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.#ctor(ET.FW.Core.Jobs.DelaySequenceMode,ET.FW.Core.Jobs.JobDurationPair[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.DelaySequenceJob"/> class.
            Sequence timeout will be calculated from sequence step durations.
            </summary>
            <param name="mode">Execution mode, controlling the step timing</param>
            <param name="steps">Array of sequence steps (job and delay).</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.DelaySequenceJob.Mode">
            <summary>
            Mode for sequence execution, mode controlls handling of delay times per step
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.DelaySequenceJob.Delays">
            <summary>
            List of job delays.
            Each item is the delay time associated of job from Jobs collection with same index
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.DelaySequenceJob.Item(System.Int32)">
            <summary>
            Gets job and delay with of sequence step the specified index.
            </summary>
            <param name="idx">Sequence step index.</param>
            <returns>Job and delay time with specified index.</returns>
            <remarks>Operator does not return the originally provided <see cref="T:ET.FW.Core.Jobs.JobDurationPair"/> instance, each call creates a new pair</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.Init">
            <summary>
            Initialize sequence:
            - Remove null entries
            - Calculates the default timeout from all jobs. 
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.CalculateTimeout">
            <summary>
            Calculates the default timeout based on contained jobs and delays.
            Time per job is greater value of job timeout or delay
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.HandleJobEnded(ET.FW.Core.Jobs.IJob)">
            <summary>
            Internal handler for job ended event.
            </summary>
            <param name="job">The current job which just ended</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DelaySequenceJob.DelayEnded(System.Object)">
            <summary>
            Internal handler for delay timer
            </summary>
            <param name="jobIdx">index of current job</param>
        </member>
        <member name="F:ET.FW.Core.Jobs.DelaySequenceJob.delayTimer">
            <summary>
            Timer used to wait remaining delay time
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobDurationPair">
            <summary>
            Job and associated duration
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobDurationPair.#ctor(ET.FW.Core.Jobs.IJob,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.JobDurationPair"/> class.
            </summary>
            <param name="job">The job.</param>
            <param name="duration">The duration.</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.JobDurationPair.Job">
            <summary>
            Gets or sets the job.
            </summary>
            <value>
            The job.
            </value>
        </member>
        <member name="P:ET.FW.Core.Jobs.JobDurationPair.Duration">
            <summary>
            Gets or sets the duration.
            </summary>
            <value>
            The duration.
            </value>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration">
            <summary>
            Core Job to check a sequence of (not yet started) jobs
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.JobName">
            <summary>
            Job name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.EstimatedDuration">
            <summary>
            Allows to define an estimated duration for the whole sequence.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.ExeededEstimatedDuration">
            <summary>
            Flag which is set at the End of execution which indicates,
            whether the IJob did exeed the estimated duration.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.DetectedDuration">
            <summary>
            Timespan which is set, if a duration check is performed
            describing the detected execution-time of the IJob.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.#ctor(System.TimeSpan,System.Nullable{System.TimeSpan},ET.FW.Core.Jobs.IJob[])">
            <summary>
            Build up the sequence jobs
            </summary>
            <remarks>
            Do not use already started or even finished jobs.
            If one or more of the jobs are already running or even failed, aborted or completed then the whole sequence will fail.
            This is the designed behaviour because in this case the sequence was not correct.
            </remarks>
            <param name="timeout">timeout of the sequence</param>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="jobs">array of jobs which define the sequence</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.Completed">
            <summary>
            Mark job as successfully finished.
            </summary>
            <remarks>
            Only jobs in state 'Running' can be completed.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.Create``2(System.Nullable{System.TimeSpan},``0,``1)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.Create``3(System.Nullable{System.TimeSpan},``0,``1,``2)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.Create``4(System.Nullable{System.TimeSpan},``0,``1,``2,``3)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <param name="job4">Job 4.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration.CreateWithEstimatedDuration``5(System.Nullable{System.TimeSpan},``0,``1,``2,``3,``4)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <typeparam name="T5">Type of job 5.</typeparam>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <param name="job4">Job 4.</param>
            <param name="job5">Job 5.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`2">
            <summary>
            Typed sequence with 2 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`2.Job1">
            <summary>
            Sequenced job 1
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`2.Job2">
            <summary>
            Sequenced job 2
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`2.#ctor(System.TimeSpan,System.Nullable{System.TimeSpan},`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`2"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`3">
            <summary>
            Typed sequence with 3 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`3.Job3">
            <summary>
            Sequenced job 3
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`3.#ctor(System.TimeSpan,System.Nullable{System.TimeSpan},`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`3"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`4">
            <summary>
            Typed sequence with 4 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`4.Job4">
            <summary>
            Sequenced job 4
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`4.#ctor(System.TimeSpan,System.Nullable{System.TimeSpan},`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`4"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`5">
            <summary>
            Typed sequence with 5 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <typeparam name="T5">Type of job 5.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`5.Job5">
            <summary>
            Sequenced job 5
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`5.#ctor(System.TimeSpan,System.Nullable{System.TimeSpan},`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJobWithEstimatedDuration`5"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="estimatedDuration">The estimated maximum duration of the whole sequence-job. Pass null for no duration-check</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
            <param name="job5">Job 5 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.DoJob">
            <summary>
            Do job which executes code
            </summary>
            <remarks>Experimental! Not for normal use.</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoJob.#ctor(System.TimeSpan,System.Action)">
            <summary>
            Constructs a do job which executes code and has a timeout
            </summary>
            <param name="timeout">timeout of the control-job</param>
            <param name="action">Action to execute.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoJob.#ctor(System.Action)">
            <summary>
            Constructs a do job which executes code without timeout
            </summary>
            <param name="action">Action to execute.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoJob.Start">
            <summary>
            Starts this job and with it all the jobs in its tummy
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoJob.InternalDo">
            <summary>
            Internal async do 
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.DoWhileJob">
            <summary>
            Control-job for a reapeated job (do-job) that will be repeated while the while-job is working
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.DoWhileJob.DoesDone">
            <summary>
            Count of how many times the do-job was run
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoWhileJob.#ctor(System.TimeSpan,ET.FW.Core.Jobs.Job,ET.FW.Core.Jobs.Job)">
            <summary>
            Construct a control-job for a reapeated job (do-job) that will be repeated while the while-job is working
            </summary>
            <param name="timeout">timeout of the control-job</param>
            <param name="doJob">the job which is repeated</param>
            <param name="whileJob">the job where its end triggers the end of the do-job</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoWhileJob.#ctor(ET.FW.Core.Jobs.Job,ET.FW.Core.Jobs.Job)">
            <summary>
            Construct a control-job for a reapeated job (do-job) that will be repeated while the while-job is working
            </summary>
            <param name="doJob">the job which is repeated</param>
            <param name="whileJob">the job where its end triggers the end of the do-job</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.DoWhileJob.Start">
            <summary>
            Starts this job and with it all the jobs in its tummy
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobState">
            <summary>
            Job state
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobState.Init">
            <summary>initial state</summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobState.Running">
            <summary>job is not finished jet</summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobState.Completed">
            <summary>job execution completed successful</summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobState.Failed">
            <summary>job execution failed</summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobState.Aborted">
            <summary> job is cancelled (or timed out)</summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobStateEventArgs">
            <summary>
            Event parameter for job ended event
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobStateEventArgs.#ctor(ET.FW.Core.Jobs.JobState)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.JobStateEventArgs"/> class.
            </summary>
            <param name="state">Job state</param>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobStateEventArgs.State">
            <summary>
            job state
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.IJob">
            <summary>
            Common interface for asynchronous jobs
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob.State">
            <summary>
            current state of this job
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob.Timeout">
            <summary>
            Timeout for wait operation, -1 msec to wait infinite
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob.HasEnded">
            <summary>
            Check if job is finished (eith or without success)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJob.Start">
            <summary>
            Start job execution.
            This method should only be used, for jobs which are not already started, job state is init. 
            </summary>
            <remarks>
            Some API methods create and start jobs internally, for this jobs Start() should not be called!
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJob.Abort">
            <summary>
            Abort this job.
            </summary>
            <remarks>
            Method normally stops job execution and cleans up internally used resources, event handlers etc.
            </remarks>
        </member>
        <member name="E:ET.FW.Core.Jobs.IJob.Ended">
            <summary>
            Event is signalled when job is finished (completed, failed or aborted)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJob.Wait">
            <summary>
            Wait for this job to be finished using default timeout
            </summary>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
            <remarks>Method aborts the job if the timeout elapses</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJob.Wait(System.TimeSpan)">
            <summary>
            Wait for this job to be finished
            </summary>
            <param name="timeout">wait timeout</param>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
            <remarks>Method aborts the job if the timeout elapses</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJob.Run">
            <summary>
            Run starts the job, waits and returns the result synchron. 
            </summary>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob.RunningTime">
            <summary>
            Returns the execution duration of the job.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob.StartTime">
            <summary>
            Time when job is started.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.IJob`1">
            <summary>
            Job interface with additional result value
            </summary>
            <typeparam name="TResult">Type of result value</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJob`1.Result">
            <summary>
            Result of job execution, property can be read after job execution is finished successfully
            While job is running or if job ends with an error, the value is undefined (normally null or default value for value types)
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.IJobExtensions">
            <summary>
            Some extension-methods for IJobs
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJobExtensions.CanPerformEstimatedDurationCheck(ET.FW.Core.Jobs.IJob)">
            <summary>
            Checks, whether an IJob can perform a check, whether the
            execution-duration matches a given EstimatedDuration
            </summary>
            <param name="job">The Job to check</param>
            <returns>TRUE if the IJob can perform this check, FALSE otherwise.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJobExtensions.DidPerformEstimatedDurationCheck(ET.FW.Core.Jobs.IJob)">
            <summary>
            Checks, whether an IJob did perform a check, whether the
            execution-duration matches a given EstimatedDuration
            </summary>
            <param name="job">The Job to check</param>
            <returns>TRUE if the IJob did perform this check, FALSE otherwise.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.IJobExtensions.DidExeedEstimatedDuration(ET.FW.Core.Jobs.IJob)">
            <summary>
            Checks, whether the duration of the execution of an IJob
            matches the defined EstimatedDuration. Returns FALSE if this
            check cannot be performed by the job or has not been performed yet.<para></para>
            Otherwise, TRUE is returned if the DetectedDuration of the execution if greater
            than the defined estimated duration and FALSE otherwise.
            </summary>
            <param name="job">The Job to check</param>
            <returns>see sumary</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.IJobWithEstimatedDuration">
            <summary>
            Interface for TestJobs performing a check of their
            execution-duration.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJobWithEstimatedDuration.ExeededEstimatedDuration">
            <summary>
            Flag which is set at the End of execution which indicates,
            whether the IJob did exeed the estimated duration.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJobWithEstimatedDuration.EstimatedDuration">
            <summary>
            Timespan describing the estimated duration of the IJob.<para></para>
            If no estimated duration is set, no check is performed.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IJobWithEstimatedDuration.DetectedDuration">
            <summary>
            Timespan which is set, if a duration check is performed
            describing the detected execution-time of the IJob.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.IProgressJob">
            <summary>
            Common interface for asynchronous jobs supporting progress.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.IProgressJob.Progress">
            <summary>
            Gets the progress of the operation.
            </summary>
            <value>The progress (0..100).</value>
        </member>
        <member name="T:ET.FW.Core.Jobs.IResetableJob">
            <summary>
            Additional interface for re-startable job. Job can be reseted to initial state "Init" and may then be started again.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.IResetableJob.Reset">
            <summary>
            Reset job to initial state.
            All operational and result data is cleared.
            </summary>
            <remarks>
            Method must not be called for running jobs, it can be executed in states Completed, Failed and Aborted.
            After this operation you can no longer query job result.
            Take care: If multiple objects wait for job completion and one object calls Reset() on job completion the other objects may not be notified or may not be able to query job results!
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.Job">
            <summary>
            Common base class for async device API calls
            </summary>
            <remarks>
            Asynchron API functions must:
            - set a reasonable timeout for the operation
            - call Start() at the beginning of the asynchron operation
            - call Completed() or Failed() to signal end of asynchron operation
            This requirements may be fulfilled by a derived job class
            Derived classes should override Abort() method to cancel asynchron operation
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.#ctor(System.TimeSpan)">
            <summary>
            Job Constructor
            </summary>
            <param name="timeout">Default timeout for job execution, WaitInfinite (-1 milliseconds) for no timeout.</param>
            <remarks>If timeout is set, job is aborted when timeout has expired</remarks>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job.State">
            <summary>
            Current state of this job.
            </summary>
            <remarks>
            Internal setter signals Ended event for final states (Completed, Failed, Aborted)
            </remarks>
        </member>
        <member name="F:ET.FW.Core.Jobs.Job.stateLock">
            <summary>
            Lock object for thread synchronization of job state handling
            Every write access to State/state must be protected by a lock of this object
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job.Timeout">
            <summary>
            Timeout for wait operation, -1 msec to wait infinite
            </summary>
            <remarks>
            If there is a default timeout for an operation, this property should be set during job construction.
            Timeout value must not be changed after job ist started, in Running state new timeout value will be ingored!
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Start">
            <summary>
            Mark job as started (and start watchdog for timeout handling)
            </summary>
            <remarks>
            Only jobs in state 'Init' can be started!
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Abort">
            <summary>
            Abort this job (called if timeout expires)
            </summary>
            <remarks>
            Only jobs in state 'Running' or 'Init' can be aborted
            Should be overriden by derived job classes to clean up unfinished jobs.
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job.HasEnded">
            <summary>
            Check if job is finished (with or without success)
            </summary>
        </member>
        <member name="E:ET.FW.Core.Jobs.Job.Ended">
            <summary>
            Event is signalled when job is finished (completed, failed or aborted)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Wait">
            <summary>
            Wait for this job to be finished using default timeout
            </summary>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
            <remarks>Method aborts the job if the timeout elapses</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Wait(System.TimeSpan)">
            <summary>
            Wait for this job to be finished
            </summary>
            <param name="timeout">wait timeout</param>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
            <remarks>Method aborts the job if the timeout elapses</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Run">
            <summary>
            Run starts the job, waits and returns the result synchron.
            </summary>
            <returns>true if job is finished successfully, false on failed job or timeout</returns>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job.RunningTime">
            <summary>
            Returns the execution duration of the job.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Completed">
            <summary>
            Mark job as successfully finished.
            </summary>
            <remarks>
            Only jobs in state 'Running' can be completed.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Failed(ET.FW.Core.Jobs.Error)">
            <summary>
            Mark job as failed (used for failure during job execution or if job cannot be started).
            </summary>
            <param name="error">Error details, may be used by derived classes</param>
            <remarks>
            Only jobs in state 'Running' or 'Init' can fail!
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.Reset">
            <summary>
            Reset job to initial state. All operational and result data is cleared.
            </summary>
            <remarks>
            Method must not be called for running jobs, it can be executed in states Completed, Failed and Aborted
            After this operation you can no longer query job result.
            Method is to be used by derived classes which implement IResetableJob interface. This jobs can be re-started multiple times.
            Derived class should overwrite Reset, call base class method and clean up job data and results.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.TimeoutHandler(System.Object)">
            <summary>
            Internal timeout handler, job is aborted when timeout elapses.
            </summary>
            <param name="objectState">state object, not used here</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job.StartTime">
            <summary>
            Time when job is started.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.Job.watchdog">
            <summary>
            Timer for internal timeout handling
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.Job.endedHandle">
            <summary>
            Optional waitable handle used by wait() method
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.Job.WaitInfinite">
            <summary>
            Timeout to use to wait infinite
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job.FailedJob">
            <summary>
            Create job for errors, job is in state failed
            </summary>
            <returns>Failed job</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.Job`1">
            <summary>
            Extended Job implementation with additional job result property
            </summary>
            <typeparam name="TResult">type of job result</typeparam>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job`1.#ctor(System.TimeSpan)">
            <summary>
            Job Constructor.
            </summary>
            <param name="timeout">Job timeout</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.Job`1.Result">
            <summary>
            Result of job execution, property is valid after job execution is finished successfully
            While job is running or if job ends with an error, the value is undefined (normally null or default value for value types)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job`1.Reset">
            <summary>
            Reset job to initial state. All operational and result data is cleared.
            </summary>
            <remarks>
            Method must not be called for running jobs, it can be executed in states Completed, Failed and Aborted
            After this operation you can no longer query job result.
            Method is to be used by derived classes which implement IResetableJob interface. This jobs can be re-started multiple times.
            Derived class should overwrite Reset, call base class method and clean up job data and results.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.Job`1.FailedJob">
            <summary>
            Create job for errors, job is in state failed
            </summary>
            <returns>Failed job</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.Error">
            <summary>
            Dummy base class for error information
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobExtensions">
            <summary>
            Extension methods for Job classes.
            </summary>
            <remarks>
            Methods are designed to provide a short clear syntax if combined with lambda expressions. 
            See examples provided with each method.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobExtensions.WaitFor``1(ET.FW.Core.Common.IReadOnlyObservableObject{``0},System.TimeSpan,System.Predicate{``0})">
            <summary>
            Determines whether the value of a observable object satisfies a condition.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">An <c>IReadOnlyObservableObject</c> to apply the predicate to.</param>
            <param name="timeout">Determination timeout.</param>
            <param name="predicate">A function to test the value.</param>
            <returns>A job which can be executed to test the value.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobExtensions.WaitFor``1(ET.FW.Core.Common.IReadOnlyObservableObject{``0},System.TimeSpan,``0)">
            <summary>
            Determines whether the value of a observable object reaches a expected value.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">An <c>IReadOnlyObservableObject</c> to apply the expection to.</param>
            <param name="timeout">Determination timeout.</param>
            <param name="expectedValue">Expected value.</param>
            <returns>A job which can be executed.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobExtensions.WaitForSet``1(ET.FW.Core.Common.IObservableObject{``0},System.TimeSpan,``0)">
            <summary>
            Sets the value of an observable object and determines whether the value of a observable object reaches this value.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">An <c>IReadOnlyObservableObject</c> to apply the expection to.</param>
            <param name="timeout">Determination timeout.</param>
            <param name="value">Value to set.</param>
            <returns>A job which can be executed.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobExtensions.WaitForSet``1(ET.FW.Core.Common.IObservableObject{``0},System.TimeSpan,``0,``0)">
            <summary>
            Sets the value of an observable object and determines whether the value of a observable object reaches this value.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">An <c>IReadOnlyObservableObject</c> to apply the expection to.</param>
            <param name="timeout">Determination timeout.</param>
            <param name="setValue">Value to set.</param>
            <param name="compareValue">Value to compare</param>
            <returns>A job which can be executed.</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobHandling">
            <summary>
            Handling of async jobs
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.WaitInfinite">
            <summary>
            Timeout to use to wait infinite
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.Synchronize(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Synchronize given jobs: Method waits for completion of all jobs or for expiration of longest job timeout
            </summary>
            <param name="jobs">Variable number of jobs to be synchronized</param>
            <returns>true if all jobs were successful completed, false otherwise</returns>
            <remarks>
            This method is an alias for WaitAll method, only difference is the method name.
            All unfinished jobs are aborted if timeout elapses.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.Synchronize(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Synchronize given jobs: Method waits for completion of all jobs or for timeout expiration
            </summary>
            <param name="syncTimeout">Synchronization timeout</param>
            <param name="jobs">Variable number of jobs to be synchronized</param>
            <returns>true if all jobs were successful completed, false otheerwise</returns>
            <remarks>
            This method is an alias for WaitAll method, only difference is the method name.
            All unfinished jobs are aborted if timeout elapses.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.WaitAll(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Wait for completion of all jobs or for expiration of longest job timeout
            </summary>
            <param name="jobs">Variable number of jobs to be waited for</param>
            <returns>true if all jobs were successful completed, false otherwise</returns>
            <remarks>
            This method is an alias for Synchronize method, only difference is the method name
            All unfinished jobs are aborted if timeout elapses.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.WaitAll(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Wait for completion of all jobs or for timeout expiration
            </summary>
            <param name="waitAllTimeout">Synchronization timeout</param>
            <param name="jobs">Variable number of jobs to be waited for</param>
            <returns>true if all jobs were successful completed, false otheerwise</returns>
            <remarks>
            This method is an alias for Synchronize method, only difference is the method name
            All unfinished jobs are aborted if timeout elapses.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.WaitAny(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Wait for completion of at least one given job, timeout is longest timeout of given jobs
            </summary>
            <param name="jobs">Variable number of jobs to be waited for</param>
            <returns>Job which was successfully completed first, null on timeout or if all jobs failed.</returns>
            <remarks>All jobs which are not completed when WaitAny returns are aborted </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.WaitAny(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Wait for completion of at least one given job
            </summary>
            <param name="jobTimeout">Timeout for job completion</param>
            <param name="jobs">Variable number of jobs to be waited for</param>
            <returns>job which was successfully completed first, null on timeout or if all jobs failed</returns>
            <remarks>All jobs which are not completed when WaitAny returns are aborted </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.#ctor(ET.FW.Core.Jobs.IJob[],System.TimeSpan,System.Boolean)">
            <summary>
            Create job handling object for given jobs
            </summary>
            <param name="jobs">jobs to handle</param>
            <param name="timeout">Timeout for job completion</param>
            <param name="waitAll">if flag is set job handling waits for completion of all jobs, otherwise it waits for first completed job</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.Wait">
            <summary>
            Wait for completion of first job/all jobs
            </summary>
            <returns>true if job(s) complete(s) within timeout and without failure</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.job_Ended(System.Object,ET.FW.Core.Jobs.JobStateEventArgs)">
            <summary>
            job signals end of execution: update job handling state
            </summary>
            <param name="sender">ended job</param>
            <param name="args">final job state</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandling.AbortRunningJobs">
            <summary>
            Abort all jobs which are not finished by now
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.waitAll">
            <summary>
            Flag for handling mode: 
            true: JobHandling waits for completion of all jobs, 
            false: it waits for completion of first job
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.timeout">
            <summary>
            Timeout for job handling
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.runningJobs">
            <summary>
            list of registered jobs which are not finished
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.JobHandling.FinishedJobs">
            <summary>
            list of finished jobs in order of completion
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.jobFailed">
            <summary>
            flag which indicates that at least one job failed
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.syncHandle">
            <summary>
            handle used to wait for completion of all jobs
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandling.thisLock">
            <summary>
            object used for thread synchronization of this class
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobHandlingJob">
            <summary>
            Job which waits for completion of multiple inner jobs.
            Job may be used to wait for completion of first or of all inner jobs.
            </summary>
            <remarks>
            Class functionality is very similar to JobHandling class
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.JobHandlingJob.Mode">
            <summary>
            Handling mode
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.Mode.WaitAll">
            <summary>Waits for completion of all jobs</summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.Mode.WaitAny">
            <summary>Waits for completion of first jobs</summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.#ctor(ET.FW.Core.Jobs.JobHandlingJob.Mode,System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Constructor with specified timeout
            </summary>
            <param name="mode">Job handling mode (wait for all/any)</param>
            <param name="timeout">timeout for this (outer) job</param>
            <param name="jobs">Jobs to monitor (inner jobs)</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.#ctor(ET.FW.Core.Jobs.JobHandlingJob.Mode,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Constructor without specified timeout.
            Timeout of outer job is derived from inner jobs timeouts, longest timeout of all inner jobs is taken for outer job.
            </summary>
            <param name="mode">Job handling mode (wait for all/any)</param>
            <param name="jobs">Jobs to monitor (inner jobs)</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.Start">
            <summary>
            Start job monitoring.
            Method starts all inner jobs which are not already running or finished
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.Abort">
            <summary>
            Abort this job, all running inner jobs are aborted too!
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.job_Ended(System.Object,ET.FW.Core.Jobs.JobStateEventArgs)">
            <summary>
            Job signals end of execution: update job handling state
            </summary>
            <param name="sender">ended job</param>
            <param name="args">final job state</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.Finish">
            <summary>
            Finish job, clean up inner jobs and calculate resulting job state
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.JobHandlingJob.AbortRunningJobs">
            <summary>
            Abort all jobs which are not finished by now
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.JobHandlingJob.Jobs">
            <summary>
            List of all monitored jobs
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.runningJobs">
            <summary>
            List of registered jobs which are not finished
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.JobHandlingJob.FinishedJobs">
            <summary>
            List of finished jobs in order of completion (jobs may have completed successfully or failed)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.failedCount">
            <summary>
            Number of failed inner jobs
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.mode">
            <summary>
            Handling mode: Wait for all or for first job
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.JobHandlingJob.thisLock">
            <summary>
            Object used for thread synchronization of this class
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.ErrorJob">
            <summary>
            Do job which traces error log and always returns failed 
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.ErrorJob.Message">
            <summary>
            Error message to be logged
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.ErrorJob.Logger">
            <summary>
            Logger to logs error message
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.ErrorJob.#ctor(ET.FW.Core.Tracing.ILogger,System.String)">
            <summary>
            Constructs a do job which log error wiht given logger
            </summary>
            <param name="logger">Logger to log error message</param>
            <param name="message">error message</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.ErrorJob.#ctor(System.String)">
            <summary>
            Constructs a do job which log error with standard logger
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.ErrorJob.Start">
            <summary>
            Starts this job and with it all the jobs in its tummy
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.ErrorJob.InternalDo">
            <summary>
            Internal async do 
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.ProgressJob">
            <summary>
            Job with progress indicator.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.ProgressJob.#ctor(System.Func{System.Boolean},System.Action,ET.FW.Core.Common.IReadOnlyObservableObject{System.Int32},System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.ProgressJob"/> class.
            </summary>
            <param name="doWork">The "working function".</param>
            <param name="abort">The abort method.</param>
            <param name="progress">The observable object sending progress events.</param>
            <param name="timeout">The timeout of the job.</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.ProgressJob.Progress">
            <summary>
            Gets the progress of a VoltageCurveProgramming operation.
            </summary>
            <value>The progress (0..100).</value>
        </member>
        <member name="M:ET.FW.Core.Jobs.ProgressJob.Start">
            <summary>
            Mark job as started and start async execution
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.ProgressJob.Abort">
            <summary>
            Abort this job (called e.g. if timeout expires).
            </summary>
            <remarks>
            Only jobs in state 'Running' or 'Init' can be aborted
            Should be overriden by derived job classes to clean up unfinished jobs.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.ProgressJob.Execute">
            <summary>
            Executes the job.
            </summary>
            <remarks>
            Method should call Completed() or Failed() to inform JobHandling about job execution result
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitJob">
            <summary>
            Waits for a specific time.
            </summary>
            <remarks>Uses currently the normal .net timer.</remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitJob.#ctor(System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="waitTime">Time to wait.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitJob.Abort">
            <summary>
            Abort job (called in case of timeout)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitJob.Reset">
            <summary>
            Resets the WaitJob
            </summary>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJob">
            <summary>
            Core Job to check a sequence of (not yet started) jobs
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob.Jobs">
            <summary>
            List of all sequence jobs.
            Do not modify this collection, otherwise timeout calculation or sequence execution migth fail.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob.CurrentJob">
            <summary>
            Index of currently executed job in the List
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.SequenceJob.endedCalled">
            <summary>
            List of bools to show for which jobs the ended handler was called yet
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.SequenceJob.callEndedLock">
            <summary>
            an object as lock for call of ended
            </summary>
        </member>
        <member name="F:ET.FW.Core.Jobs.SequenceJob.ContinueOnFailure">
            <summary>
            To continue sequence execution if an inner job does not complete successfully
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.#ctor(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Build up the sequence jobs
            </summary>
            <remarks>
            Do not use already started or even finished jobs.
            If one or more of the jobs are already running or even failed, aborted or completed then the whole sequence will fail.
            This is the designed behaviour because in this case the sequence was not correct.
            Sequence execution fails, if an inner job does not complete successfully. In this case the sequence execution is stopped.
            </remarks>
            <param name="timeout">timeout of the sequence</param>
            <param name="jobs">array of jobs which define the sequence</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.#ctor(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Build up the sequence jobs. The timeout is automatically calculated from the comprised jobs.
            </summary>
            Do not use already started or even finished jobs.
            If one or more of the jobs are already running or even failed, aborted or completed than the whole sequence will fail.
            This is the designed behaviour because than the sequence was not correct.
            <param name="jobs">array of jobs which define the sequence</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.CalculateTimeout">
            <summary>
            Calculates the default timeout from all jobs
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.Start">
            <summary>
            Starts this job and with it the first job in its tummy
            </summary>
            <remarks>
            If one or more of the jobs are allready running or even failed, aborted or completed than the whole sequence will fail.<para></para>
            This is the designed behaviour because than the sequence was not correct.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.LastCompleted">
            <summary>
            return last sucessfully completed job
            </summary>
            <returns>Last successfully completed job</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.job_Ended(System.Object,ET.FW.Core.Jobs.JobStateEventArgs)">
            <summary>
            Handles the Ended event of each job.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:ET.FW.Core.Jobs.JobStateEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.HandleJobEnded(ET.FW.Core.Jobs.IJob)">
            <summary>
            Internal handler for job ended event.
            </summary>
            <param name="job">The current job which just ended</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.NextStep">
            <summary>
            Execute next sequence step.
            Finish sequence if recent job was last.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.Create``2(``0,``1)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.Create``3(``0,``1,``2)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.Create``4(``0,``1,``2,``3)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <param name="job4">Job 4.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob.Create``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates a new sequence job.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <typeparam name="T5">Type of job 5.</typeparam>
            <param name="job1">Job 1.</param>
            <param name="job2">Job 2.</param>
            <param name="job3">Job 3.</param>
            <param name="job4">Job 4.</param>
            <param name="job5">Job 5.</param>
            <returns>Sequence job object.</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJob`2">
            <summary>
            Typed sequence with 2 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob`2.Job1">
            <summary>
            Sequenced job 1
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob`2.Job2">
            <summary>
            Sequenced job 2
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`2.#ctor(System.TimeSpan,`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJob`2"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`2.#ctor(`0,`1)">
            <summary>
            Constructor. The timeout is automatically calculated from the comprised jobs.
            </summary>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJob`3">
            <summary>
            Typed sequence with 3 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob`3.Job3">
            <summary>
            Sequenced job 3
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`3.#ctor(System.TimeSpan,`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJob`3"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`3.#ctor(`0,`1,`2)">
            <summary>
            Constructor. The timeout is automatically calculated from the comprised jobs.
            </summary>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJob`4">
            <summary>
            Typed sequence with 4 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob`4.Job4">
            <summary>
            Sequenced job 4
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`4.#ctor(System.TimeSpan,`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJob`4"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Constructor. The timeout is automatically calculated from the comprised jobs.
            </summary>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.SequenceJob`5">
            <summary>
            Typed sequence with 5 sequenced jobs.
            </summary>
            <typeparam name="T1">Type of job 1.</typeparam>
            <typeparam name="T2">Type of job 2.</typeparam>
            <typeparam name="T3">Type of job 3.</typeparam>
            <typeparam name="T4">Type of job 4.</typeparam>
            <typeparam name="T5">Type of job 5.</typeparam>
        </member>
        <member name="P:ET.FW.Core.Jobs.SequenceJob`5.Job5">
            <summary>
            Sequenced job 5
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`5.#ctor(System.TimeSpan,`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.SequenceJob`5"/> class.
            </summary>
            <param name="timeout">Timeout of the sequence.</param>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
            <param name="job5">Job 5 object.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.SequenceJob`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Constructor. The timeout is automatically calculated from the comprised jobs.
            </summary>
            <param name="job1">Job 1 object.</param>
            <param name="job2">Job 2 object.</param>
            <param name="job3">Job 3 object.</param>
            <param name="job4">Job 4 object.</param>
            <param name="job5">Job 5 object.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitForJob`1">
            <summary>
            Waits for an successful predicate which operates in associate of an observable object.
            </summary>
            <remarks>If the predicate is true from the start, the job is directly completet.</remarks>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IReadOnlyObservableObject{`0},System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.WaitForJob`1"/> class.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="predicate">Predicate function to determinate job target</param>
        </member>
        <member name="P:ET.FW.Core.Jobs.WaitForJob`1.ObservableObject">
            <summary>
            The object to observe.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Jobs.WaitForJob`1.Timestamp">
            <summary>
            The timestamp of the successed value change.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.Start">
            <summary>
            Start job execution
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.ValueChanged(System.Object,ET.FW.Core.Common.ValueChangedEventArgs{`0})">
            <summary>
            ObservableObject value changed event method
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:ET.FW.Core.Common.ValueChangedEventArgs`1"/> instance containing the event data.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.Completed">
            <summary>
            Mark job as successfully finished.
            </summary>
            <remarks>
            Only jobs in state 'Running' can be completed.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.Abort">
            <summary>
            Abort job (called in case of timeout)
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.Reset">
            <summary>
            Resets the WaitForValueJob
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForJob`1.Equals``1(``0,System.Boolean)">
            <summary>
            Special equals method, which ignores the casing from string objects
            </summary>
            <typeparam name="T">Data type of value to compare</typeparam>
            <param name="expectedValue">The expected value.</param>
            <param name="ignoreCase">Sets ignoring case at <c>string</c> types.</param>
            <returns>Predicate function</returns>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitAllJob">
            <summary>
            Wait for all given jobs
            </summary>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitAllJob.#ctor(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.WaitAllJob"/> class.
            </summary>
            <param name="timeout">Timeout for outer job</param>
            <param name="jobs">Jobs to wait for</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitAllJob.#ctor(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.WaitAllJob"/> class.
            Timeout of outer job is derived from inner jobs timeouts, longest timeout of all inner jobs is taken for outer job.
            </summary>
            <param name="jobs">Jobs to wait for</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitAnyJob">
            <summary>
            Wait for completion of at least one job
            </summary>
            <remarks>
            If one inner job is aborted all other jobs stay running, if a job is successfully completed all other jobs are aborted.
            First successfully completed job is stored in Result property
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitAnyJob.#ctor(System.TimeSpan,ET.FW.Core.Jobs.IJob[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.WaitAllJob"/> class.
            </summary>
            <param name="timeout">Timeout for outer job</param>
            <param name="jobs">Jobs to wait for</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitAnyJob.#ctor(ET.FW.Core.Jobs.IJob[])">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Jobs.WaitAllJob"/> class.
            Timeout of outer job is derived from inner jobs timeouts, longest timeout of all inner jobs is taken for outer job.
            </summary>
            <param name="jobs">Jobs to wait for</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitEventJob">
            <summary>
            Job which waits for an event to be raised.
            Event must be implemented using the .net default event pattern. 
            Otherwise EventHandler cannot be registered at event, due to incompatible parameter types.
            </summary>
            <example>
            Example (EventHandler must be registered at event and job must be started):
            <code>
            WaitEventJob job = new WaitEventJob(timeout);
            eventSource.Event += job.EventHandler;				// Register EventHandler at event
            job.Start();										// Start job
            bool eventWasRaised = job.Wait();					// Wait for job completion
            eventSource.Event -= job.EventHandler;				// Deregister EventHandler
            </code></example>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob.#ctor(System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="timeout">job timeout</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob.EventHandler(System.Object,System.EventArgs)">
            <summary>
            Event handler for monitored event
            </summary>
            <param name="sender">event source</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob.Reset">
            <summary>
            Reset job to initial state.
            All operational and result data is cleared.
            Registration of "EvejntHandler()" is not affected, because it has to be controlled from the outside of the job.
            </summary>
            <remarks>
            Method must not be called for running jobs, it can be executed in states Completed, Failed and Aborted.
            After this operation you can no longer query job result.
            Take care: If multiple objects wait for job completion and one object calls Reset() on job completion the other objects may not be notified or may not be able to query job results!
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitEventJob`1">
            <summary>
            Job which waits for an event to be raised. Job provides event arguments parameter as job result.
            Event must be implemented using the .net default event pattern. 
            Otherwise EventHandler cannot be registered at event, due to incompatible parameter types.
            </summary>
            <remarks>
            If job completes successfully, the Result property contains the event arguments
            </remarks>
            <typeparam name="TArgs">Type of event arguments, used for typesafe access to result</typeparam>
            <example>
            Example (EventHandler must be registered at event and job must be started):
            <code>
            WaitEventJob&lt;StringEventArgs&gt; job = new WaitEventJob&lt;StringEventArgs&gt;(timeout);
            eventSource.Event += job.EventHandler;				// Register EventHandler at event
            job.Start();										// Start job
            if (job.Wait()) {									// Wait for job completion
                StringEventArgs args = job.Result;				// Access event args
            }
            eventSource.Event -= job.EventHandler;				// Deregister EventHandler
            </code></example>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob`1.#ctor(System.TimeSpan)">
            <summary>
            Constructor
            </summary>
            <param name="timeout">job timeout</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob`1.EventHandler(System.Object,`0)">
            <summary>
            Event handler for monitored event
            </summary>
            <param name="sender">event source</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitEventJob`1.Reset">
            <summary>
            Reset job to initial state.
            All operational and result data is cleared.
            Registration of "EvejntHandler()" is not affected, because it has to be controlled from the outside of the job.
            </summary>
            <remarks>
            Method must not be called for running jobs, it can be executed in states Completed, Failed and Aborted.
            After this operation you can no longer query job result.
            Take care: If multiple objects wait for job completion and one object calls Reset() on job completion the other objects may not be notified or may not be able to query job results!
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitForValueJob`1">
            <summary>
            Waits for an expected value of an observable object.
            </summary>
            <remarks>If the expected value is set from the start, the job is directly completet.</remarks>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IReadOnlyObservableObject{`0},`0)">
            <summary>
            Constructor. Ignores casing at <c>string</c> types by default.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="expectedValue">Expected value.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IReadOnlyObservableObject{`0},`0,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="expectedValue">Expected value.</param>
            <param name="ignoreCase">Sets ignore case at <c>string</c> types.</param>
        </member>
        <member name="T:ET.FW.Core.Jobs.WaitForValueSetJob`1">
            <summary>
            Waits for the setting of an value based on a observable object.
            </summary>
            <remarks>If the value is set from the start, the job is directly completet.</remarks>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueSetJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IObservableObject{`0},`0,`0)">
            <summary>
            Constructor. Ignores casing at <c>string</c> types by default.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="setValue">Value to set.</param>
            <param name="compareValue">compare Value.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueSetJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IObservableObject{`0},`0)">
            <summary>
            Constructor. Ignores casing at <c>string</c> types by default.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueSetJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IObservableObject{`0},`0,System.Boolean)">
            <summary>
            The Constructor.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="value">Value to set.</param>
            <param name="ignoreCase">Sets ignore case at <c>string</c> types.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueSetJob`1.#ctor(System.TimeSpan,ET.FW.Core.Common.IObservableObject{`0},`0,`0,System.Boolean)">
            <summary>
            The Constructor.
            </summary>
            <param name="timeout">Job timeout.</param>
            <param name="observableObject">Value to observe.</param>
            <param name="setValue">Value to set.</param>
            <param name="compareValue">compare Value.</param>
            <param name="ignoreCase">Sets ignore case at <c>string</c> types.</param>
        </member>
        <member name="M:ET.FW.Core.Jobs.WaitForValueSetJob`1.Start">
            <summary>
            Start job execution
            </summary>
        </member>
        <member name="T:ET.FW.Core.Licensing.ByteArrayExtensions">
            <summary>
            Extends the <see cref="T:byte[]"/> data type.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Licensing.ByteArrayExtensions.GetString(System.Byte[])">
            <summary>
            Returns a string that represents the byte array.
            </summary>
            <param name="bytes">The byte array to get the string.</param>
            <returns>A string that represents the byte array. A empty string if the byte array contains no data.</returns>
        </member>
        <member name="T:ET.FW.Core.Licensing.ISystemInfos">
            <summary>
            Interface definition for SystemInfos objects. 
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.BiosId">
            <summary>
            Gets or sets the Bios id of the requesting machine.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.DriveSerialNumber">
            <summary>
            Gets or sets the Drive serial numbers of the requesting machine.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.ExpireDate">
            <summary>
            Gets or sets the expire date of the license.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Licensing.ISystemInfos.GetDataToEncrypt">
            <summary>
            Returns a string to encrypt.
            </summary>
            <returns>A string to encrypt.</returns>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.LastAccessDate">
            <summary>
            Gets or sets the date of last accessing the ET-Framework.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.MachineName">
            <summary>
            Gets or sets the Machine name of the requesting machine. 
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.MainboardSerialNumber">
            <summary>
            Gets or sets the Mainbord serial number of the requesting machine.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.ProccessorIds">
            <summary>
            Gets or sets the Processor ids of the requesting machine.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.ISystemInfos.UserName">
            <summary>
            Gets or sets the User name of the requesting person.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Licensing.LicenseAgreementInfo">
            <summary>
            LicenseAgreementInfo class stores information about the license Agreement.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseAgreementInfo.LicenseAgreementVersion">
            <summary>
            gets or sets the license agreement version
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseAgreementInfo.LicenseAgreedDate">
            <summary>
            gets or sets the license agreed date
            </summary>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseAgreementInfo.Serialize(System.String)">
            <summary>
            Serializes a <see cref="T:ET.FW.Core.Licensing.LicenseAgreementInfo"/> object.
            </summary>
            <param name="path">The path to the xml.</param>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseAgreementInfo.Deserialize(System.String)">
            <summary>
            Deserializes a <see cref="T:ET.FW.Core.Licensing.LicenseAgreementInfo"/> object.
            </summary>
            <param name="path">The path to the serialized Licenseinfo.</param>
            <returns>The new <see cref="T:ET.FW.Core.Licensing.LicenseAgreementInfo"/> object.</returns>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseAgreementInfo.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes a <see cref="T:ET.FW.Core.Licensing.LicenseAgreementInfo"/> object.
            </summary>
            <param name="input">The Stream to deserialize.</param>
            <returns>The new <see cref="T:ET.FW.Core.Licensing.LicenseAgreementInfo"/> object.</returns>
        </member>
        <member name="T:ET.FW.Core.Licensing.LicenseFiles">
            <summary>
            static constants for Licensing
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseFiles.PublicKeyFile">
            <summary>
            The public key file name
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseFiles.LicenseDatabase">
            <summary>
            The name of the local License database file.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseFiles.LicenseDatabasePath">
            <summary>
            Returns the path read/write License database file.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseFiles.LicenseAgreement">
            <summary>
            The name of the local License database file.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Licensing.LicenseInfo">
            <summary>
            LicenseInfo class stores information about the license.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseInfo.MinDate">
            <summary>
            The minimum Date for using in C++.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseInfo.RSAKeyValue">
            <summary>
            Gets ors sets the PublicKey data.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseInfo.LicenseData">
            <summary>
            Gets ors sets the License data.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Licensing.LicenseInfo.IsValid">
            <summary>
            <c>true</c> if the current <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> has valid data; otherwise, <c>false</c>.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseInfo.Serialize(System.String)">
            <summary>
            Serializes a <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> object.
            </summary>
            <param name="path">The path to the xml.</param>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseInfo.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes a <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> object.
            </summary>
            <param name="input">The Stream to deserialize.</param>
            <returns>The new <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> object.</returns>
        </member>
        <member name="M:ET.FW.Core.Licensing.LicenseInfo.Deserialize(System.String)">
            <summary>
            Deserializes a <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> object.
            </summary>
            <param name="path">The path to the serialized Licenseinfo.</param>
            <returns>The new <see cref="T:ET.FW.Core.Licensing.LicenseInfo"/> object.</returns>
        </member>
        <member name="T:ET.FW.Core.Licensing.LicenseStates">
            <summary>
            Defines states of a License
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseStates.InValid">
            <summary>
            The license is invalid.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseStates.Valid">
            <summary>
            The license is valid.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseStates.Expired">
            <summary>
            The license has expired.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseStates.NoLicense">
            <summary>
            No license available.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Licensing.LicenseStates.NoPublicKey">
            <summary>
            No PublicKey available.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Logging.AttachmentMessage">
            <summary>
            Message for System attachment messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.#ctor(System.String,System.String,System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="name">The name</param>
            <param name="filelink">file link</param>
            <param name="source">Source name</param>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes this message using the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.SerializeString(System.IO.BinaryWriter,System.String)">
            <summary>
            simple function to serialize a string
            </summary>
            <param name="writer">the writer where into the serialization writes</param>
            <param name="text">test to serialize</param>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes this message using the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.DeserializeString(System.IO.BinaryReader)">
            <summary>
            simple function to deserialize a string
            </summary>
            <param name="reader">reader from where to deserialize</param>
            <returns>deserialised string</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.Translate">
            <summary>
            Translate binary message to textual representation
            </summary>
            <returns>translation text</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessage.TranslateMessage">
            <summary>
            Translate the message
            </summary>
            <returns>The MessageTranslation</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.AttachmentMessage.Name">
            <summary>
            Name of the Attachment Message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.AttachmentMessage.Filelink">
            <summary>
            Filelink of Attachment
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.AttachmentMessage.Source">
            <summary>
            Source of the Attachment Message
            </summary>
        </member>
        <member name="T:ET.FW.Core.Logging.AttachmentMessageFactory">
            <summary>
            Creates Attachment messages.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.AttachmentMessageFactory.Instance">
            <summary>
            The only one Attachment message factory
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessageFactory.#ctor">
            <summary>
            Private constructor, to avoid explicit instantiation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessageFactory.ET#FW#Core#Messaging#IMessageFactory#CreateMessage``1(ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Create new message
            </summary>
            <typeparam name="TMessage">type of message</typeparam>
            <param name="protocol">protocol which processes the message</param>
            <returns>the newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessageFactory.SerializeMessage(ET.FW.Core.Messaging.IMessage,System.IO.BinaryWriter)">
            <summary>
            Write given message to stream
            </summary>
            <param name="message">message to serialize</param>
            <param name="writer">writer to access the stream</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentMessageFactory.DeserializeMessage(System.IO.BinaryReader,ET.FW.Core.Messaging.IProtocol,System.Int32)">
            <summary>
            Read message from stream
            </summary>
            <param name="reader">reader to access the stream</param>
            <param name="protocol">protocol which is assigned to the message</param>
            <param name="length">length of message data in bytes</param>
            <returns>the restored message or null on error</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.AttachmentProtocol">
            <summary>
            Protocol handling Attachment messages.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentProtocol.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Logging.AttachmentProtocol"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentProtocol.Init">
            <summary>
            Inits this instance.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.AttachmentProtocol.Id">
            <summary>
            Gets the id.
            </summary>
            <value>The unique id of the protocol.</value>
        </member>
        <member name="M:ET.FW.Core.Logging.AttachmentProtocol.SendMessage(ET.FW.Core.Logging.AttachmentMessage)">
            <summary>
            Send message
            </summary>
            <param name="msg">The message</param>
            <returns>Send result</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.CommentBus">
            <summary>
            Implements the message Bus for system messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentBus.#ctor(System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="name">bus name</param>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentBus.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Configure and initialize bus
            </summary>
            <param name="protocols">collection of protocols for bus (configured in XML-file)</param>
            <returns>true if initialization was successful</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentBus.CommentProtocol">
            <summary>
            Protocol for Logmessages
            </summary>
        </member>
        <member name="T:ET.FW.Core.Logging.CommentMessage">
            <summary>
            Message for System logging messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Text">
            <summary>
            Gets or sets the text.
            </summary>
            <value>The source.</value>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Order">
            <summary>
            Type of logging message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.UId">
            <summary>
            Unique ID
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Source">
            <summary>
            Gets or sets the source.
            </summary>
            <value>The source.</value>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Message">
            <summary>
            Text of system message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.RxTx">
            <summary>
            The Rx/Tx
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.Translate">
            <summary>
            Translates Message
            </summary>
            <returns>The text</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.TranslateMessage">
            <summary>
            Translate message
            </summary>
            <returns>Message translation</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Payload">
            <summary>
            The Payload
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Timestamp">
            <summary>
            The Timestamp
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.Protocol">
            <summary>
            The Protocol
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.HWTimestamp">
            <summary>
            Orignal timestamp of the Hardware
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessage.MessageError">
            <summary>
            Always null.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.HasError">
            <summary>
            Always false.
            </summary>
            <returns>true if has error</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessage.GetCacheKey">
            <summary>
            gets key for caching
            </summary>
            <returns>key for caching</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.CommentProtocol">
            <summary>
            Protocol handling log messages.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentProtocol.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Logging.LogProtocol"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentProtocol.Init">
            <summary>
            Inits this instance.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentProtocol.Id">
            <summary>
            Gets the id.
            </summary>
            <value>The unique id of the protocol.</value>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentProtocol.SendMessage(ET.FW.Core.Logging.CommentMessage)">
            <summary>
            Send message
            </summary>
            <param name="msg">The message</param>
            <returns>Send result</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.CommentMessageFactory">
            <summary>
            Creates comment messages.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.CommentMessageFactory.Instance">
            <summary>
            The only one Log message factory
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessageFactory.#ctor">
            <summary>
            Private constructor, to avoid explicit instantiation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessageFactory.ET#FW#Core#Messaging#IMessageFactory#CreateMessage``1(ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Creates Message
            </summary>
            <typeparam name="TMessage">The message type</typeparam>
            <param name="protocol">The protocol</param>
            <returns>Message object</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessageFactory.SerializeMessage(ET.FW.Core.Messaging.IMessage,System.IO.BinaryWriter)">
            <summary>
            Write given message to stream
            </summary>
            <param name="message">message to serialize</param>
            <param name="writer">writer to access the stream</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.CommentMessageFactory.DeserializeMessage(System.IO.BinaryReader,ET.FW.Core.Messaging.IProtocol,System.Int32)">
            <summary>
            Read message from stream
            </summary>
            <param name="reader">reader to access the stream</param>
            <param name="protocol">protocol which is assigned to the message</param>
            <param name="length">length of message data in bytes</param>
            <returns>the restored message or null on error</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.ILoggingChannelAccess">
            <summary>
            Interface for logging channels
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.ILoggingChannelAccess.LogProtocol">
            <summary>
            Protocol for logging texts
            </summary>
        </member>
        <member name="T:ET.FW.Core.Logging.Log">
            <summary>
            Static wrapper for loggers of this assembly
            </summary>
            <example>
            The example shows a common call to add a message to log
            <code>
            Log.Messages.Error("An error occured");
            </code></example>
        </member>
        <member name="P:ET.FW.Core.Logging.Log.Logging">
            <summary>
            Logger with code "ComPort"
            </summary>
        </member>
        <member name="T:ET.FW.Core.Logging.LogMessage">
            <summary>
            Message for System logging messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.#ctor(ET.FW.Core.Tracing.LogType)">
            <summary>
            The Constructor
            </summary>
            <param name="logType">Type of system message</param>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.#ctor(ET.FW.Core.Tracing.LogType,System.String,System.Exception)">
            <summary>
            The Constructor
            </summary>
            <param name="logType">Type of system message</param>
            <param name="message">string message</param>
            <param name="exception">The exception</param>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.UId">
            <summary>
            Unique ID
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.MessageType">
            <summary>
            System type as Message type
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Source">
            <summary>
            Gets or sets the source.
            </summary>
            <value>The source.</value>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.LogType">
            <summary>
            Type of logging message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Exception">
            <summary>
            Exception object
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Message">
            <summary>
            Text of system message
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes this message using the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.SerializeString(System.IO.BinaryWriter,System.String)">
            <summary>
            Serializes String
            </summary>
            <param name="writer">The writer</param>
            <param name="text">The text</param>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes this message using the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.DeserializeString(System.IO.BinaryReader)">
            <summary>
            Deserializes String
            </summary>
            <param name="reader">The reader</param>
            <returns>Deserialized text</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.RxTx">
            <summary>
            The Rx/Tx
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.Translate">
            <summary>
            Translates Message
            </summary>
            <returns>The text</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.TranslateMessage">
            <summary>
            Translate message
            </summary>
            <returns>Message translation</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Payload">
            <summary>
            The Payload
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Timestamp">
            <summary>
            The Timestamp
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.Protocol">
            <summary>
            The Protocol
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.HWTimestamp">
            <summary>
            Orignal timestamp of the Hardware
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessage.MessageError">
            <summary>
            Always null.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.HasError">
            <summary>
            Always false.
            </summary>
            <returns>true if has error</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessage.GetCacheKey">
            <summary>
            gets key for caching
            </summary>
            <returns>key for caching</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.LogMessageFactory">
            <summary>
            Creates log messages.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogMessageFactory.Instance">
            <summary>
            The only one Log message factory
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessageFactory.#ctor">
            <summary>
            Private constructor, to avoid explicit instantiation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessageFactory.ET#FW#Core#Messaging#IMessageFactory#CreateMessage``1(ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Creates Message
            </summary>
            <typeparam name="TMessage">The message type</typeparam>
            <param name="protocol">The protocol</param>
            <returns>Message object</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessageFactory.SerializeMessage(ET.FW.Core.Messaging.IMessage,System.IO.BinaryWriter)">
            <summary>
            Write given message to stream
            </summary>
            <param name="message">message to serialize</param>
            <param name="writer">writer to access the stream</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Logging.LogMessageFactory.DeserializeMessage(System.IO.BinaryReader,ET.FW.Core.Messaging.IProtocol,System.Int32)">
            <summary>
            Read message from stream
            </summary>
            <param name="reader">reader to access the stream</param>
            <param name="protocol">protocol which is assigned to the message</param>
            <param name="length">length of message data in bytes</param>
            <returns>the restored message or null on error</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.LogProtocol">
            <summary>
            Protocol handling log messages.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogProtocol.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Logging.LogProtocol"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.LogProtocol.Init">
            <summary>
            Inits this instance.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Logging.LogProtocol.Id">
            <summary>
            Gets the id.
            </summary>
            <value>The unique id of the protocol.</value>
        </member>
        <member name="M:ET.FW.Core.Logging.LogProtocol.SendMessage(ET.FW.Core.Logging.LogMessage)">
            <summary>
            Send message
            </summary>
            <param name="msg">The message</param>
            <returns>Send result</returns>
        </member>
        <member name="T:ET.FW.Core.Logging.SystemBus">
            <summary>
            Implements the message Bus for system messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Logging.SystemBus.#ctor(System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="name">bus name</param>
        </member>
        <member name="M:ET.FW.Core.Logging.SystemBus.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Configure and initialize bus
            </summary>
            <param name="protocols">collection of protocols for bus (configured in XML-file)</param>
            <returns>true if initialization was successful</returns>
        </member>
        <member name="P:ET.FW.Core.Logging.SystemBus.LogProtocol">
            <summary>
            Protocol for Logmessages
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.ICache">
            <summary>
            Interface for caching of Payload and Translation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ICache.GetPayloadCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Get cache key for payload
            </summary>
            <param name="message">Message with payload to cache</param>
            <returns>Cache key for payload. No caching if key is null or empty</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ICache.GetTranslationCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Get cache key for translation
            </summary>
            <param name="message">Message with translation to cache</param>
            <returns>Cache key for translation. No caching if key is null or empty</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.ITrace">
            <summary>
            Trace interface for Trace source
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ITrace.TraceMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Traces message
            </summary>
            <param name="message">The IMessage</param>
        </member>
        <member name="T:ET.FW.Core.Messaging.ITraceSource">
            <summary>
            Trace Source
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ITraceSource.TraceTarget">
            <summary>
            Trace target
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageEventExtensions">
            <summary>
            Extension class for events. Class contains methods to raise decoupled events
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageEventExtensions.RaiseDecoupled``1(ET.FW.Core.Messaging.MessageEventHandler{``0},System.Object,ET.FW.Core.Messaging.MessageEventArgs{``0})">
            <summary>
            Raise decoupled message events
            </summary>
            <remarks>
            Optimized version of DecoupledEventExtensions.RaiseDecoupled() for message events.
            Events are raised without dynamic invocation
            </remarks>
            <typeparam name="TMessage">Type of message</typeparam>
            <param name="eventDelegate">Event delegate which raises the event</param>
            <param name="sender">Event sender parameter</param>
            <param name="args">Event arguments parameter</param>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageWithErrorInterpreter">
            <summary>
            Base implementation for messages with error interpreter/decoder
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageWithErrorInterpreter.DecodeError">
            <summary>
            Decodes MessageErrors
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageWithErrorInterpreter.SetError(System.UInt32,System.String)">
            <summary>
            Sets a MessageError with the given kind and the given additional info.<para></para>
            The ErrorDescription is automatically filled, if possible.<para></para>
            Assigns the created MessageError to the accoring property of the message.<para></para>
            If a MessageError had already been assigned, it will be lost.
            </summary>
            <param name="errorKind">Kind of the error</param>
            <param name="additionalInfo">Additional Info to write into the error</param>
            <returns>The created MessageError</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageWithErrorInterpreter.ErrorDecoder">
            <summary>
            The Error Decoder to use.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessageEncoder`1">
            <summary>
            Common interface for message encoding/decoding
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageEncoder`1.EncodeData(`0)">
            <summary>
            Pack structured message fields to raw data bytes for transmission
            </summary>
            <param name="message">message to encode</param>
            <returns>raw byte array</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessageDecoder`1">
            <summary>
            Common interface for message encoding/decoding
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageDecoder`1.DecodeData(System.Byte[],`0)">
            <summary>
            Extract structured message fields and payload from raw data bytes
            </summary>
            <param name="data">data bytes</param>
            <param name="message">message to receive decoded data</param>
            <returns>true on success</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessageWithErrorInterpreter">
            <summary>
            Interface for Messages knowing to interpret errorcodes.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageWithErrorInterpreter.DecodeError">
            <summary>
            Fills the DefaultDescription of own MessageError
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageWithErrorInterpreter.SetError(System.UInt32,System.String)">
            <summary>
            Sets a MessageError with the given kind and the given additional info.<para></para>
            The ErrorDescription is automatically filled, if possible.<para></para>
            Assigns the created MessageError to the accoring property of the message.<para></para>
            If a MessageError had already been assigned, it will be lost.
            </summary>
            <param name="errorKind">Kind of the error</param>
            <param name="additionalInfo">Additional Info to write into the error</param>
            <returns>The created MessageError</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessageWithErrorInterpreter.ErrorDecoder">
            <summary>
            The used IErrorDecoder.
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.ISegmentedMessage`1">
            <summary>
            Interface for messages generated out of one or
            several other messages (e.g.: CanTpMessage consists of CanMessages)
            </summary>
            <typeparam name="TMessage">Type of the messages this message consists of</typeparam>
        </member>
        <member name="P:ET.FW.Core.Messaging.ISegmentedMessage`1.MessageParts">
            <summary>List of messages which are parts of the segmented message</summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.IProtocolCollection">
            <summary>
            Interface for collection of protocols
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocolCollection.Get``1">
            <summary>
            Access protocol by its type
            </summary>
            <typeparam name="TProtocol">protocol interface type</typeparam>
            <returns>instance of protocol which implements given type, null if none available</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocolCollection.Get``1(System.String)">
            <summary>
            Access service by its type and name 
            </summary>
            <typeparam name="TProtocol">Service type (interface)</typeparam>
            <param name="name">Protocol name (alias)</param>
            <returns>Instance of protocol with given name which implements given type, null if none available</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageError">
            <summary>
            Object which represents an error which was detected in a Message<para></para>
            This class is sealed, as extending this class would cause severe problems with serialization.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.#ctor">
            <summary>
            Create a new instance of the <see cref="T:ET.FW.Core.Messaging.MessageError"/> class.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.#ctor(System.UInt32)">
            <summary>
            Create a new instance of the <see cref="T:ET.FW.Core.Messaging.MessageError"/> class.
            </summary>
            <param name="kind">The Kind of the error.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.#ctor(System.UInt32,System.String)">
            <summary>
            Create a new instance of the <see cref="T:ET.FW.Core.Messaging.MessageError"/> class.
            </summary>
            <param name="kind">The Kind of the error.</param>
            <param name="additionalInfo">Extended textual description of the error.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.CreateFrom(ET.FW.Core.Common.FrameworkError)">
            <summary>
            Create a new instance of <see cref="T:ET.FW.Core.Messaging.MessageError"/> class from the given error.
            </summary>
            <param name="error">A <see cref="T:ET.FW.Core.Common.FrameworkError"/> object to create the new MessageError.</param>
            <returns>The new instance of the error parameter.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes using the specified writer.<para></para>
            Does not serialize the DefaultDescription.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes using the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageError.Clone">
            <summary>
            Clones this MessageError and all SubErrors.
            </summary>
            <returns>The Clone of this MessageError object.</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageTranslation">
            <summary>
            Class to store the Translation of an IMessage-implementing object
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.#ctor(System.String,ET.FW.Core.Common.FrameworkError)">
            <summary>
            Create a new instance of the MessageTranslation class.
            </summary>
            <param name="translation">The translated text.</param>
            <param name="error">A optional FrameworkError object.</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageTranslation.HasError">
            <summary>
            Returns, whether an error occured, when this tranlation was done
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageTranslation.TranslationText">
            <summary>
            The tranlated text
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageTranslation.Error">
            <summary>
            Gets- or sets the Error object.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.GetHashCode">
            <summary>
            Serves as a hash function for the MessageTranslation type. 
            </summary>
            <returns>A hash code for the current MessageTranslation object.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.Equals(System.Object)">
            <summary>
            Determines whether the specified Object is equal to the current MessageTranslation object.
            </summary>
            <param name="obj">The object to compare with the current MessageTranslation object.</param>
            <returns><c>true</c> if the specified Object is equal to the current MessageTranslation object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.ToString">
            <summary>
            Returns a string that represents the current MessageTranslation object.
            </summary>
            <returns>A string that represents the current MessageTranslation object.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.Equals(ET.FW.Core.Messaging.MessageTranslation)">
            <summary>
            Determines whether two MessageTranslation instances are equal.
            </summary>
            <param name="other">The MessageTranslation object to compare with the current MessageTranslation object.</param>
            <returns><c>true</c> if the specified MessageTranslation object is equal to the current MessageTranslation object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageTranslation.CompareTo(ET.FW.Core.Messaging.MessageTranslation)">
            <summary>
            Compares this instance with a specified MessageTranslation object.
            </summary>
            <param name="other">The MessageTranslation to compare with this instance.</param>
            <summary>
            Compares the MessageTranslation of this instance with a specified MessageTranslation object and indicates whether this
            instance precedes, follows, or appears in the same position in the sort order as the specified MessageTranslation.
            </summary>
            <returns>
            	<para>A 32-bit signed integer that indicates the relative order of the objects
                being compared. The return value has the following meanings:</para>
            	<para>
            		<list type="table">
            			<item>
            				<term><strong>Value</strong></term>
            				<description><strong>Meaning</strong></description>
            			</item>
            			<item>
            				<term>Less than zero</term>
            				<description>This instance is less than the <span class="parameter">other</span> parameter.</description>
            			</item>
            			<item>
            				<term>Zero</term>
            				<description>This instance object is equal to <span class="parameter">other</span>.</description>
            			</item>
            			<item>
            				<term>Greater than zero</term>
            				<description>This instance object is greater than <span class="parameter">other</span>.</description>
            			</item>
            		</list>
            	</para>
            </returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.PortType">
            <summary>
            Specifies the type of channel access.
            </summary>
            <remarks>This is a comfortable way to detect the underlying bus type.</remarks>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.NotSet">
            <summary>
            Not specified or unknown bus type. This is the value set by the default constructors.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Most25">
            <summary>
            Optical MOST bus, Speed grade 25MBit/s.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Most">
            <summary>
            Optical MOST bus.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Can">
            <summary>
            Electrical MOST bus, Speed grade up to 150MBit/s.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.CanFD">
            <summary>
            CanFD type
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.FlexRay">
            <summary>
            Flexray specified by the Flexray consortium. Speed grade 10MBit/s.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Lin">
            <summary>
            Automotive Local Interconnect Network.  Specified by the LIN consortium. Speed grade up to 19,2KBit/s
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Ethernet">
            <summary>
            Ethernet. Specified by the IEEE. Speed grade up to 1000MBit/s.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Text">
            <summary>
            Text stream (e.g. from data logger)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Usb">
            <summary>
            Universal Serial Bus. Invented by Intel. Speed grade typical 480MBit/s.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Com">
            <summary>
            Universal Asynchronous Receiver Transmitter, Serial (COM) interface. Speed grade typical 115,2KBit/s
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Gpib">
            <summary>
            General Purpose Interface Bus. Specified by the IEEE.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.GNLogger">
            <summary>
            Special interface for the Harman GNLogger
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Most150">
            <summary>
            MOST 150
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Logging">
            <summary>
            System/Marker Log
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Visa">
            <summary>
            Visamessagess Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.FlukeIp">
            <summary>
            FlukeIpmessagess Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Image">
            <summary>
            Imaging Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.CameraImage">
            <summary>
            CameraImaging Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Alma">
            <summary>
            Alma Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.AlmaEthernet">
            <summary>
            Alma Ethernet Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Dftoe">
            <summary>
            DFTOE Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Rest">
            <summary>
            Rest Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Pcap">
            <summary>
            Pcap Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.TimestampTest">
            <summary>
            TimestampTest Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Thrift">
            <summary>
            Socket Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.TextSimulation">
            <summary>
            TextSimulation Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Dlt">
            <summary>
            Autosar DLT Logger
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Vicp">
            <summary>
            Vicp Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.UserData">
            <summary>
            UserData Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Relay">
            <summary>
            Relay Interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Comment">
            <summary>
            Commets
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.PortType.Framegrabber">
            <summary>
            Framegrabber
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.PortType.GetNormalizedString(System.String)">
            <summary>
            Returns the normalized string for portType, i.e. handles portTypes
            in uppercase-letters. Logs a warning if a portType could not be matched
            without ignoring the case, but could be matched with ignored cases.<para></para>
            If it could not be matched at all, the given portType is returned unchanged.
            </summary>
            <param name="portType">The portType to normalize</param>
            <returns>the nomalized string</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.ProtocolCollection">
            <summary>
            Collection of protocols
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ProtocolCollection.#ctor(System.Collections.Generic.IEnumerable{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Constructor
            </summary>
            <param name="protocols">protocols for the collection</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ProtocolCollection.Get``1">
            <summary>
            Access protocol by its type
            </summary>
            <typeparam name="TProtocol">Protocol type (interface)</typeparam>
            <returns>Instance of protocol which implements given type, null if none available</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ProtocolCollection.Get``1(System.String)">
            <summary>
            Access protocol by its type and name
            </summary>
            <typeparam name="TProtocol">Protocol type (interface)</typeparam>
            <param name="name">Protocol name (alias)</param>
            <returns>Instance of protocol with given name which implements given type, null if none available</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.Bus">
            <summary>
            Base implementation for API busses<br/>
            <p>Klassendiagram: <img src="../DevDocu/ClassDiagram/Busses.png"/></p>
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Bus.#ctor(System.String)">
            <summary>
            Bus constructor
            </summary>
            <param name="name">bus name</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.Bus.Name">
            <summary>
            Bus name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Bus.Protocols">
            <summary>
            Public interface for Collection of configured (bus) protocols
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.Bus.protocols">
            <summary>
            Protocol Collection
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Bus.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Configure and initialize bus
            </summary>
            <param name="currentProtocols">collection of protocols for bus (configured in XML-file)</param>
            <returns>true if initialization was successful</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Bus.Dispose">
            <summary>
            Dispose all protocols
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Bus.InitProtocol``1">
            <summary>
            Initialize protocol
            </summary>
            <typeparam name="TProtocol">Type of protocol</typeparam>
            <returns>The protocol or null if no matching protocol is configured</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.Bus.ExtChannelAccess">
            <summary>
            WARNING: Use this function with care! Only if you really need Hardware specific functions. 
            Testplans which uses this function can only run if this specific Hardware is available.
            Gets the channel access (if configured) which belongs to this bus.
            </summary>
            <value>null If not configured, the channelaccess if configured in the testbench.xml</value>
        </member>
        <member name="T:ET.FW.Core.Messaging.FilterMode">
            <summary>
            Filtermode: Pass or Block
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.FilterMode.Block">
            <summary>
            Block messages that fit the pattern 
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.FilterMode.Pass">
            <summary>
            Pass messages that fit the pattern
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.Filter`1">
            <summary>
            Base class for message filters. Derived classes must override Match method to implement filter algorithm.
            </summary>
            <typeparam name="TMessage">type of filtered messages</typeparam>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.#ctor(ET.FW.Core.Messaging.IMessageSource{`0})">
            <summary>
            Constructor, construct filter (connect it to message source)
            </summary>
            <param name="input">message source for filter</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.#ctor(ET.FW.Core.Messaging.IMessageSource{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Messaging.Filter`1"/> class.
            </summary>
            <param name="input">message source for filter</param>
            <param name="autostart">if flag is set, filter is started after construction</param>
            <remarks>You should not set autostart flag, if Start() method is overwritten!</remarks>
        </member>
        <member name="P:ET.FW.Core.Messaging.Filter`1.Input">
            <summary>
            Message source which provides messages to be filtered
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.Start">
            <summary>
            (Re-)start filter.
            Filter connects itself to previously configured message source and starts filtering recveived messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.Stop">
            <summary>
            Disconnect filter from message source, stop message filtering
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Filter`1.Running">
            <summary>
            Running state of filter
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.Match(`0)">
            <summary>
            Match given message (matching messages will be signalled as Output event)
            This method must be used by derived filter classes to implement filter algorithm
            </summary>
            <param name="message">message to match</param>
            <returns>true if message matches the filter</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Filter`1.HandleInput(System.Object,ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Input event handler forwards matching messages to output
            </summary>
            <param name="sender">message source</param>
            <param name="args">event args, containig the message</param>
        </member>
        <member name="T:ET.FW.Core.Messaging.FilterHelper`1">
            <summary>
            Helper class which is used by MessageSource to optimize filtering.
            This class provides one event, which is used for notifying receivers of all filters which 
            </summary>
            <typeparam name="TMessage">type of message to be filtered</typeparam>
        </member>
        <member name="M:ET.FW.Core.Messaging.FilterHelper`1.#ctor(ET.FW.Core.Messaging.MessageSource{`0},ET.FW.Core.Messaging.OptimizingFilter{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Messaging.FilterHelper`1"/> class.
            </summary>
            <param name="source">source of messages to be filtered</param>
            <param name="master">Filter which provides the filter algorithm (Match() method)</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.FilterHelper`1.Shutdown">
            <summary>
            shutdown this helper
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.FilterHelper`1.source">
            <summary>
            Message source which provides messages to be filtered
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.FilterHelper`1.HandleInput(System.Object,ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Input function for messages to be filtered
            </summary>
            <param name="sender">message source</param>
            <param name="e">arguments containig message</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.FilterHelper`1.Master">
            <summary>
            Master filter used as provider for filter algorithm (Match method)
            </summary>
        </member>
        <member name="E:ET.FW.Core.Messaging.FilterHelper`1.Output">
            <summary>
            Output event which signals all outgoing messages 
            </summary>
            <remarks>
            Event is raised decoupled, if event handler class implements IEventDecoupling interface
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Messaging.FilterHelper`1.OnOutput(ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Raise message output event
            </summary>
            <param name="args">output event arguments</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.FilterHelper`1.HasTargets">
            <summary>
            Check if helper has targets which receive matching messages
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.IBus">
            <summary>
            Base interface for bus access in API
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IBus.Protocols">
            <summary>
            Collection of configured (bus) protocols
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IBus.ExtChannelAccess">
            <summary>
            WARNING: Use this function with care! Only if you really need Hardwarespecific functions. 
            Testplans which uses this function can only run if this specific Hardware is available.
            Gets the channel access (if configured) which belongs to this bus.
            </summary>
            <value>null If not configured, the channelaccess if configured in the testbench.xml</value>
        </member>
        <member name="M:ET.FW.Core.Messaging.IBus.Init(System.Collections.Generic.IList{ET.FW.Core.Messaging.IProtocol})">
            <summary>
            Configure and initialize bus
            </summary>
            <param name="protocols">collection of protocols for bus (configured in XML-file)</param>
            <returns>true if initialization was successful</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.ICatalog">
            <summary>
            Interface for message catalogs (based on IMessage)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ICatalog.ID">
            <summary>
            Unique ID of catalog
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ICatalog.IsExternalSource">
            <summary>
            Gets or sets a value indicating whether the Catalog is generated internaly (eg. wihtout a file)
            </summary>
            <value>
              <c>true</c> if file based catalog; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ET.FW.Core.Messaging.ICatalog.Source">
            <summary>
            The catalog source
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ICatalog.Translate(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translates message object to string representation
            </summary>
            <param name="message">message object</param>
            <returns>translation as string</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ICatalog.TranslateMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translates message object to string representation
            </summary>
            <param name="message">message object</param>
            <returns>translation as MessageTranslation</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.RxTx">
            <summary>
            Message type to distinguish between transmitted and received messages
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.Undefined">
            <summary>Undefined RxTx</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.Rx">
            <summary>Receive (Received message)</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.Tx">
            <summary>Transmit (Transmitted message)</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.Status">
            <summary>Event / state message</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.RxError">
            <summary>Receiption Failed</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.TxFailed">
            <summary>Transmission Failed</summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.RxTx.TxNak">
            <summary>Tranmission Not Acknowledged</summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessage">
            <summary>
            Common interface for all ET Framework API message classes
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.UId">
            <summary>
            The unique ID of the IMessage, where unique refers to the uniqueness
            of the ID during one online-session, i.e. also within one trace-structure.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.Payload">
            <summary>
            Access data bytes
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.Timestamp">
            <summary>
            Message timestamp
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.HWTimestamp">
            <summary>
            Orignal timestamp of the Hardware (only set if available)
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.RxTx">
            <summary>
            Received/tranmitted message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.Protocol">
            <summary>
            Assigned protocol
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.Translate">
            <summary>
            Translate binary message to textual representation
            </summary>
            <returns>the translation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.TranslateMessage">
            <summary>
            Translate binary message to textual representation
            </summary>
            <returns>A MessageTranlation which contains the translated text and informations, whether an error occured, when the translation was done.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.IMessage.MessageError">
            <summary>
            Proprty for an Error detected with the message.<para></para>
            MessageError == null means no error has been detected at the time the comparison is made.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.HasError">
            <summary>
            Returns, whether an error has been detected for this Message.
            </summary>
            <returns>TRUE if the message has an Error, FALSE otherwise</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessage.GetCacheKey">
            <summary>
            gets key for caching
            </summary>
            <returns>key for caching</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.Undefined">
            <summary>
            Undefined values
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.Undefined.Time">
            <summary>
            DateTime value used for undefined timestamps
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.Undefined.ID">
            <summary>
            ID value for undefined ID
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.Undefined.Payload">
            <summary>
            Empty payload array for messages without payload, array is used instead of null
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessageFactory">
            <summary>
            Interface for creation of ET Framework messages
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageFactory.CreateMessage``1(ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Create new message
            </summary>
            <typeparam name="TMessage">type of message</typeparam>
            <param name="protocol">protocol which processes the message</param>
            <returns>the newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageFactory.SerializeMessage(ET.FW.Core.Messaging.IMessage,System.IO.BinaryWriter)">
            <summary>
            Write given message to stream
            </summary>
            <param name="message">message to serialize</param>
            <param name="writer">writer to access the stream</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IMessageFactory.DeserializeMessage(System.IO.BinaryReader,ET.FW.Core.Messaging.IProtocol,System.Int32)">
            <summary>
            Read message from stream
            </summary>
            <param name="reader">reader to access the stream</param>
            <param name="protocol">protocol which is assigned to the message</param>
            <param name="length">length of message data in bytes</param>
            <returns>the restored message or null on error</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.IMessageSource`1">
            <summary>
            Interface for objects which provide an output for messages which is implemented as an event
            </summary>
            <typeparam name="TMessage">Type of output message</typeparam>
        </member>
        <member name="E:ET.FW.Core.Messaging.IMessageSource`1.Output">
            <summary>
            Output event signals all outgoing messages 
            </summary>
            <remarks>
            Subscribers of this event should implement event decoupling <see cref="T:ET.FW.Core.Events.IEventDecoupling"/>
            </remarks>
        </member>
        <member name="T:ET.FW.Core.Messaging.IProtocol">
            <summary>
            Common message type independant base interface for protocols
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IProtocol.MessageFactory">
            <summary>
            Message factory for corresponding messages
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.IProtocol.Catalog">
            <summary>
            Optional Catalog for message re-translation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol.TranslateMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translate message content to textual representation
            </summary>
            <param name="message">message to translate</param>
            <returns>Message translation text</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol.TranslateMessageToObject(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translate message content to textual representation
            </summary>
            <param name="message">message to translate</param>
            <returns>Message translation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol.SimulateMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            "Input" function for messages in offline mode
            </summary>
            <param name="message">offline message to be simulates</param>
            <returns>true on success</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.IProtocol.PortType">
            <summary>
            Gets or sets the type of the port. This is used
            for Identify the Hardware. Used by Tracing and Addons.
            </summary>
            <value>The type of the port.</value>
        </member>
        <member name="T:ET.FW.Core.Messaging.IProtocol`1">
            <summary>
            Protocol wrapper for easier use of HAL protocols
            </summary>
            <typeparam name="TMessage">Type of message handled by the protocol</typeparam>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol`1.SendMessage(`0)">
            <summary>
            Send message via protocol
            </summary>
            <param name="message">the message</param>
            <returns>
            Send result, which indicates if message could be sent, further errors are not monitored here
            </returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol`1.CreateMessage">
            <summary>
            Create new empty message for this protocol
            </summary>
            <returns>The newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.IProtocol`1.CreateMessage``1">
            <summary>
            Create new empty message for this protocol,
            </summary>
            <typeparam name="TNewMessage">Type of new message, must be derived from protocol message type</typeparam>
            <returns>The newly created message</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.SendResult">
            <summary>
            Result value for send messages
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.Ok">
            <summary>
            Message is correct and sending is initiated, further errors are not reported here
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.ProtocolNotAvailable">
            <summary>
            Protocol for this message type is not available (maybe it is not configured)
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.MessageInvalid">
            <summary>
            Message contains invalid data
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.CyclicSendingNotSupported">
            <summary>
            cyclic sending is not supported on this bus
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.HalError">
            <summary>
            HAL layer reports error
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.SendResult.SendingNotSupported">
            <summary>
            sending is not supported by this protocol
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.Message">
            <summary>
            Base message implementation
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.Message.UndefinedTime">
            <summary>
            DateTime value used for undefined timestamps
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.UId">
            <summary>
            Unique ID
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.Payload">
            <summary>
            Data bytes
            </summary>
            <remarks>
            Payload is never null, initially and if it is set to null, payload contains an empty array
            </remarks>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.Timestamp">
            <summary>
            Message timestamp corrected
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.HWTimestamp">
            <summary>
            Orignal timestamp of the Hardware
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.RxTx">
            <summary>
            Received/tranmitted message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.Protocol">
            <summary>
            Assigned protocol
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.Translate">
            <summary>
            Translate binary message to textual representation
            </summary>
            <returns>the translation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.TranslateMessage">
            <summary>
            Translate binary message to textual representation<para></para>
            Should be overridden for all messages, where errors can be detected when translating.
            </summary>
            <returns>A MessageTranlation which containts the translated text and informations, whether an error occured, when the translation was done.</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes the message using the specified writer.<para></para>
            Attention: written version is "1" if this message has no error and "2" if
            it has an error. Must be considered, when changing this method!
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.Message.MessageError">
            <summary>
            Was an error detected with this message?
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.HasError">
            <summary>
            Returns, whether an error has been detected for this Message.
            </summary>
            <returns>True if has error</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes the message using the the specified reader.<para></para>
            Attention: written version is "1" if this message has no error and "2" if
            it has an error. Must be considered, when changing this method!
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.Message.GetCacheKey">
            <summary>
            gets key for caching
            </summary>
            <returns>key for caching</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageEventArgs`1">
            <summary>
            Event parameter for message received event
            </summary>
            <typeparam name="TMessage">Type of message</typeparam>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Messaging.MessageEventArgs`1"/> class.
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageEventArgs`1.Message">
            <summary>
            the message
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageEventHandler`1">
            <summary>
            Event handler for message received event
            </summary>
            <typeparam name="TMessage">Type of message</typeparam>
            <param name="sender">Event source</param>
            <param name="e">Event arguments including message object</param>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageFactory">
            <summary>
            Base implementation for ET message factories
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageFactory.ClassAndInterface">
            <summary>
            Message types
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.ClassAndInterface.#ctor(System.Type,System.Type)">
            <summary>
            Constructor.
            </summary>
            <param name="interf">public interface</param>
            <param name="impl">implementation class</param>
        </member>
        <member name="F:ET.FW.Core.Messaging.MessageFactory.ClassAndInterface.Interface">
            <summary>
            Type of public message interface
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.MessageFactory.ClassAndInterface.Implementation">
            <summary>
            Type of message implementation
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.MessageFactory.Types">
            <summary>
            List of all supported types
            </summary>
            <remarks>
            type index + 1 is used as message type field for serialization/deserialization
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.NoFromType(System.Type)">
            <summary>
            Get number of given type
            </summary>
            <param name="type">type to search</param>
            <returns>number of type or 0 if not found</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.TypeFromNo(System.Byte)">
            <summary>
            Return type which is mapped to given number
            </summary>
            <param name="no">type number</param>
            <returns>type or null for invalid number</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.CreateMessage(System.Byte,ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Internal method to create message based on message type number
            </summary>
            <param name="no">message type number</param>
            <param name="protocol">protocol to assign to the message</param>
            <returns>the newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.CreateMessage``1(ET.FW.Core.Messaging.IProtocol)">
            <summary>
            Create new message
            </summary>
            <typeparam name="TMessage">type of message</typeparam>
            <param name="protocol">protocol which processes the message</param>
            <returns>the newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.SerializeMessage(ET.FW.Core.Messaging.IMessage,System.IO.BinaryWriter)">
            <summary>
            Write given message to stream
            </summary>
            <param name="message">message to serialize</param>
            <param name="writer">writer to access the stream</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageFactory.DeserializeMessage(System.IO.BinaryReader,ET.FW.Core.Messaging.IProtocol,System.Int32)">
            <summary>
            Read message from stream
            </summary>
            <param name="reader">reader to access the stream</param>
            <param name="protocol">protocol which is assigned to the message</param>
            <param name="length">length of message data in bytes</param>
            <returns>the restored message or null on error</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.MessageSource`1">
            <summary>
            Base class for objects which provide an output for messages which is implemented as event.
            Output event subsciption issues warning message if target does not support event decoupling
            </summary>
            <typeparam name="TMessage">Type of output message</typeparam>
            <remarks>
            Class implements optimization for registered filters, 
            so that filter algorithm of attached identical filters will only be executed once per message
            </remarks>
        </member>
        <member name="E:ET.FW.Core.Messaging.MessageSource`1.Output">
            <summary>
            Output event which signals all outgoing messages 
            </summary>
            <remarks>
            Event is raised decoupled, if event handler class implements <see cref="T:ET.FW.Core.Events.IEventDecoupling"/>  interface.
            Otherwise event subscription issues a warning message.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageSource`1.OnOutput(`0)">
            <summary>
            Raise message output event
            </summary>
            <remarks>
            Do not override this method for internal message handling, override other OnOutput() method.
            This method is not called if other method is called directly.
            </remarks>
            <param name="message">output message</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageSource`1.OnOutput(ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Raise message output event.
            </summary>
            <remarks>This method may be overriden for internal handling of output messages</remarks>
            <param name="args">output event arguments</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageSource`1.AddTarget(ET.FW.Core.Messaging.MessageEventHandler{`0})">
            <summary>
            Add target for messages
            </summary>
            <param name="handler">delegate of target to receive messages</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.MessageSource`1.RemoveTarget(ET.FW.Core.Messaging.MessageEventHandler{`0})">
            <summary>
            Remove target for messages
            </summary>
            <param name="handler">delegate of target to be disconnected</param>
        </member>
        <member name="T:ET.FW.Core.Messaging.OptimizingFilter`1">
            <summary>
            Specialized filter base class which supports optimization of filter algorithm usage:
            If multiple identical filters are registered to same message source, match() method is executed once only for all filter instances
            </summary>
            <typeparam name="TMessage">type of filtered messages</typeparam>
            <remarks>
            A derived class can only be used to filter messages. It must not be used to modify the incoming messages. 
            Filter algorithm must not have side effects, because it may not be executed for every filter instance.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Messaging.OptimizingFilter`1.#ctor(ET.FW.Core.Messaging.IMessageSource{`0})">
            <summary>
            Constructor, construct filter and connect it to message source
            </summary>
            <param name="input">message source for filter</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.OptimizingFilter`1.#ctor(ET.FW.Core.Messaging.IMessageSource{`0},System.Boolean)">
            <summary>
            Constructor, construct filter and connect it to message source
            </summary>
            <param name="input">message source for filter</param>
            <param name="autostart">if flag is set, filter is started after construction</param>
            <remarks>You should not set autostart flag, if Start() method is overwritten!</remarks>
        </member>
        <member name="P:ET.FW.Core.Messaging.OptimizingFilter`1.Helper">
            <summary>
            Filter helper, used to optimize filtering
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.OptimizingFilter`1.HandleInput(System.Object,ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Input event handler forwards matching messages to output
            </summary>
            <param name="sender">message source</param>
            <param name="args">event args, containig the message</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.OptimizingFilter`1.Equals(System.Object)">
            <summary>
            Check if other object is the same
            </summary>
            <param name="obj">other object to compare</param>
            <returns>true if other object is the same as this</returns>
            <remarks>
            This method is used to find equal filters for optimization. 
            If multiple equal filters are connected to same message source output filter algorith is only executed once for all filters.
            </remarks>
        </member>
        <member name="M:ET.FW.Core.Messaging.OptimizingFilter`1.GetHashCode">
            <summary>
            Calculate hash value
            </summary>
            <returns>Calculated hash</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.Protocol`1">
            <summary>
            Protocol implementation base class
            </summary>
            <typeparam name="TMessage">type of message to be processed by protocol</typeparam>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.TraceTarget">
            <summary>
            Trace target
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.Trace(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Trace message
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.OnOutput(ET.FW.Core.Messaging.MessageEventArgs{`0})">
            <summary>
            Raise message output event.
            </summary>
            <remarks>This method may be overriden for internal handling of output messages</remarks>
            <param name="args">output event arguments</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.SendMessage(`0)">
            <summary>
            Send message via protocol
            </summary>
            <param name="message">the message</param>
            <returns>
            Send result, which indicates if message could be sent, further errors are not monitored here
            </returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.Name">
            <summary>
            Access protocol name
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.Catalog">
            <summary>
            Optional Catalog for message re-translation
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.MessageFactory">
            <summary>
            Factory for message creation
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.Dispose">
            <summary>
            Shutdown protocol
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.CreateMessage">
            <summary>
            Create new empty message for this protocol
            </summary>
            <returns>The newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.CreateMessage``1">
            <summary>
            Create new empty message for this protocol,
            </summary>
            <typeparam name="TNewMessage">type of new message, must be derived from protocol message type</typeparam>
            <returns>the newly created message</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.TranslateMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translate message content to textual representation.
            This implementation calls catalogs Translate method or returns an empty string.
            </summary>
            <param name="message">message to translate</param>
            <returns>message translation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.TranslateMessageToObject(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Translate message content to textual representation
            </summary>
            <param name="message">message to translate</param>
            <returns>message translation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.SimulateMessage(ET.FW.Core.Messaging.IMessage)">
            <summary>
            "Input" function for messages in offline mode
            </summary>
            <param name="message">Offline message to be simulates</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.CheckSendMessage(`0)">
            <summary>
            Check if given message can be sent over this protocol
            </summary>
            <param name="message">Message to send</param>
            <returns>result of check</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.PortType">
            <summary>
            Gets or sets the type of the port. This is used
            for Identify the Hardware. Used by Tracing and Addons.
            </summary>
            <value>The type of the port.</value>
        </member>
        <member name="P:ET.FW.Core.Messaging.Protocol`1.IsCacheable">
            <summary>
            Is cacheable
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.GetPayloadCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Get cache key for payload
            </summary>
            <param name="message">Message with payload to cache</param>
            <returns>Cache key for payload. No caching if key is null or empty</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.GetTranslationCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Get cache key for translation
            </summary>
            <param name="message">Message with translation to cache</param>
            <returns>Cache key for translation. No caching if key is null or empty</returns>
        </member>
        <member name="F:ET.FW.Core.Messaging.Protocol`1.CacheKeyMaxLength">
            <summary>
            Max. length for cache key
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.DefaultPayloadCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Default cache key for payload
            </summary>
            <param name="message">Message with payload to cache</param>
            <returns>Cache key for payload. No caching if key is null or empty</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.Protocol`1.DefaultTranslationCacheKey(ET.FW.Core.Messaging.IMessage)">
            <summary>
            Default cache key for translation
            </summary>
            <param name="message">Message with translation to cache</param>
            <returns>Cache key for translation. No caching if key is null or empty</returns>
        </member>
        <member name="T:ET.FW.Core.Messaging.ResultMessage">
            <summary>
            Message for System result messages
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.ResultMessage.SectionRoot">
            <summary>
            Section Root
            </summary>
        </member>
        <member name="F:ET.FW.Core.Messaging.ResultMessage.PathRoot">
            <summary>
            Path root
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Version">
            <summary>
            Version number of message
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.#ctor">
            <summary>
            The Constructor
            </summary>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.#ctor(System.String,System.String,System.String,System.String,System.String,ET.FW.Core.Common.ParameterCollection)">
            <summary>
            The Constructor
            </summary>
            <param name="path">message path</param>
            <param name="name">message name</param>
            <param name="id">message id</param>
            <param name="source">message source</param>
            <param name="data">message data</param>
            <param name="attributes">message attributes</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.Serialize(System.IO.BinaryWriter)">
            <summary>
            Serializes this message using the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.SerializeString(System.IO.BinaryWriter,System.String)">
            <summary>
            simple function to serialize a string
            </summary>
            <param name="writer">the writer where into the serialization writes</param>
            <param name="text">text to serialize</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.SerializeAttributes(System.IO.BinaryWriter,ET.FW.Core.Common.ParameterCollection)">
            <summary>
            Serializes attributes
            </summary>
            <param name="writer">writer object</param>
            <param name="attributes">attributes parameter</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.Deserialize(System.IO.BinaryReader)">
            <summary>
            Deserializes this message using the specified reader.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.DeserializeString(System.IO.BinaryReader)">
            <summary>
            simple function to deserialize a string
            </summary>
            <param name="reader">reader from where to deserialize</param>
            <returns>deserialised string</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.DeserializeAttributes(System.IO.BinaryReader)">
            <summary>
            Deserializes attributes
            </summary>
            <param name="reader">reader object</param>
            <returns>parameter collection</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.Translate">
            <summary>
            Translate the message
            </summary>
            <returns>the translated text</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.TranslateMessage">
            <summary>
            Translate the message
            </summary>
            <returns>the MessageTranslation</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.CreateXmlNode(System.Xml.XmlElement,System.Boolean)">
            <summary>
            Create Xml Node
            </summary>
            <param name="parent">the parent node</param>
            <param name="withPath">flag withPath</param>
            <returns>the created XmlElement</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.CreateXmlNode(System.Xml.XmlElement)">
            <summary>
            Create Xml node without path attribute
            </summary>
            <param name="parent">the parent element</param>
            <returns>the created element</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.ResultMessage.AddAttribute(System.String,System.String)">
            <summary>
            Add Attribute
            </summary>
            <param name="name">attribute name</param>
            <param name="value">attribute value</param>
            <returns>attributes value</returns>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.PathNodes">
            <summary>
            List of PathNodes
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Name">
            <summary>
            Name of Resultmessage
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Id">
            <summary>
            Id of the Result-Message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Source">
            <summary>
            Source of the Result-Message
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Path">
            <summary>
            Path-Section-Name of the Result-Message-Entry
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Attributes">
            <summary>
            List of additional attributes
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.Data">
            <summary>
            Data property
            </summary>
        </member>
        <member name="P:ET.FW.Core.Messaging.ResultMessage.PathName">
            <summary>
            Path/Name[\@Id=''] property
            </summary>
        </member>
        <member name="T:ET.FW.Core.Messaging.UplinkOnlyProtocol`1">
            <summary>
            Protocol implementation which only supports signalling of uplink messages.
            Sending of messages is not possible.
            </summary>
            <typeparam name="TMessage">Type of IMessage</typeparam>
        </member>
        <member name="M:ET.FW.Core.Messaging.UplinkOnlyProtocol`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Messaging.UplinkOnlyProtocol`1"/> class.
            </summary>
            <param name="name">The name of the Protocol.</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.UplinkOnlyProtocol`1.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Messaging.UplinkOnlyProtocol`1"/> class.
            </summary>
            <param name="name">The name of the Protocol.</param>
            <param name="isCacheable">True to cache payload and Translation</param>
        </member>
        <member name="M:ET.FW.Core.Messaging.UplinkOnlyProtocol`1.SendMessage(`0)">
            <summary>
            Send message, not supported here.
            </summary>
            <param name="message">message to be sent</param>
            <returns>Error: sending not supported</returns>
        </member>
        <member name="M:ET.FW.Core.Messaging.UplinkOnlyProtocol`1.CheckSendMessage(`0)">
            <summary>
            Check if given message can be sent over this protocol
            </summary>
            <param name="msg">Message to send</param>
            <returns>Error: sending not supported</returns>
        </member>
        <member name="T:ET.FW.Core.Settings.EtSettings">
            <summary>
            Settings as XML document
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.VERSION_1_0_0">
            <summary>
            Version 1.0.0
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.CURRENT_VERSION">
            <summary>
            Current Version of EtSettings
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS">
            <summary>
            Nodename for Application - Settings
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_CONTINUE_ON_VARIANT_ABORT">
            <summary>
            Name of the AppSettings.ContinueOnVariantAbort parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_GO_OFFLINE_AFTER_TESTSET">
            <summary>
            Name of the AppSettings.GoOfflineAfterTestSet parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_PAUSE_BETWEEN_VARIANTS">
            <summary>
            Name of the AppSettings.PauseBetweenVariants parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_LONG_RESULT_FILENAME">
            <summary>
            Name of the AppSettings.LongResultFileName parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_MEMORY_MONITORING">
            <summary>
            Name of the AppSettings.MemoryMonitoring parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_COPYING_CATALOGS">
            <summary>
            Name of the AppSettings.CopyingCatalogs parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_LOG_MEM_INFO">
            <summary>
            Name of the AppSettings.LogMemInfo parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_YAM_PATH">
            <summary>
            Name of the AppSettings.YamPath parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_LAST_EXPORT_PATH">
            <summary>
            Name of the AppSettings.YamPath parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_LOG_PATH">
            <summary>
            Name of the AppSettings.LoggingPath parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_Catalogs_PATH">
            <summary>
            Name of the AppSettings.CatalogsPath parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_MRU_TESTSETS">
            <summary>
            Node most recently used testsets
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_TESTSETS_TIMESTAMP_FORMAT">
            <summary>
            Node how testsets timestamp will be formatted
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_MRU_TRACEDBS">
            <summary>
            Node most recently used
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_LASTOPENDIALOGPATHS">
            <summary>
            Node most recently used
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_APPSETTINGS_WAIT_TIME">
            <summary>
            Name of the AppSettings.NightModeWaitTime parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_COLORSYNCRONIZATION">
            <summary>
            Name of the AppSettings.ColorSynchronization parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_COLORSYNCRONIZATION_CHANNELS">
            <summary>
            Name of the ColorSynchronization.Channels parameter
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_CHANNEL">
            <summary>
            Name of the ColorSynchronization.Channel
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_ROOT">
            <summary>
            Node root
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_VERSION">
            <summary>
            Attribute Left
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_GRID">
            <summary>
            Node Grid
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_GRAPH">
            <summary>
            Node Graph
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_YAMGRID">
            <summary>
            Node YamGrid
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_ETGRID">
            <summary>
            Node EtGrid
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_IGRIDLAYOUT">
            <summary>
            Node iGridLayout
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_RULER">
            <summary>
            Node Ruler
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_CHANNELBAR">
            <summary>
            Node ChannelBar
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_SOURCEBUTTON">
            <summary>
            Node SourceButton
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_SOURCEMENU">
            <summary>
            Node SourceMenu
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_PROTOCOLS">
            <summary>
            Node Protocols
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_PROTOCOL">
            <summary>
            Node Protocol
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_AUDIOPROCESSING">
            <summary>
            Node AudioProcessing
            </summary>
            TODO: To be removed!!!
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_NAME">
            <summary>
            Attribute name
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_ISCHECKED">
            <summary>
            Attribute IsChecked
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_COLOR">
            <summary>
            Attribute Color
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_INDEX">
            <summary>
            Attribute Index
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_LEFT">
            <summary>
            Attribute Left
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_LOG">
            <summary>
            Node SystemLog
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_FATAL_DIALOG">
            <summary>
            Node for FatalMessageDialog settings
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_AUTOSCROLL">
            <summary>
            Attribute Autoscroll.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_PANESETTINGS">
            <summary>
            Node for pane settings.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_PANE">
            <summary>
            Node for pane settings.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_HEIGHT">
            <summary>
            Attribute Height.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.ATTR_FREEZE">
            <summary>
            Attribute Freeze.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_GRAPHLINES">
            <summary>
            GraphLines Node.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_GRAPHLINE">
            <summary>
            Graphline Node.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.NODE_SCROLLBAR">
            <summary>
            Graphline Node.
            </summary>
        </member>
        <member name="F:ET.FW.Core.Settings.EtSettings.FILENAME">
            <summary>
            Filename of settings
            </summary>
        </member>
        <member name="P:ET.FW.Core.Settings.EtSettings.Settings">
            <summary>
            ET Settings - The singleton-instance
            </summary>
        </member>
        <member name="P:ET.FW.Core.Settings.EtSettings.SettingsRoot">
            <summary>
            The RootNode of the Singleton-Settings
            </summary>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.Save">
            <summary>
            Saves settings
            </summary>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.Cleanup">
            <summary>
            Cleansup the settings xml document. All active=false filterelements will be removed. All empty parametersets will be removed.
            </summary>
            <remarks>log grid requires also empty parametersets to work correctly</remarks>
        </member>
        <member name="P:ET.FW.Core.Settings.EtSettings.RootNode">
            <summary>
            Gets the root node.
            </summary>
            <value>
            The root node.
            </value>
        </member>
        <member name="P:ET.FW.Core.Settings.EtSettings.Version">
            <summary>
            The current Version of EtSettings.
            null, if no version exists
            </summary>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.FixSettingsForVersion_1_0_0">
            <summary>
            Moves nodes and removes unused nodes on version 1.0.0
            </summary>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.Init(System.String)">
            <summary>
            Inits the specified file name.
            </summary>
            <param name="fileName">Name of the file.</param>
            <exception cref="T:System.InvalidOperationException">You must not reinitialize the singleton-instance of ETSettings.</exception>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.GetMainNode(System.String)">
            <summary>
            Get node with name just below the root node
            </summary>
            <param name="nodeName">Name of child node</param>
            <returns>Node just below the root node that fits the given name</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.GetAssuredMainNode(System.String)">
            <summary>
            Get node with name just below the root node.<para></para>
            Assures, the node is existing.
            </summary>
            <param name="nodeName">Name of child node</param>
            <returns>Node just below the root node that fits the given name</returns>
        </member>
        <member name="P:ET.FW.Core.Settings.EtSettings.NodeAppSettings">
            <summary>
            Gets XmlNode of AppSettings
            </summary>
            <returns>AppSettings XmlNode</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.EtSettings.GetNodeAppSetting(System.String)">
            <summary>
            Gets XmlNode of AppSettings
            </summary>
            <param name="name">Name of AppSetting</param>
            <returns>AppSetting XmlNode</returns>
        </member>
        <member name="T:ET.FW.Core.Settings.XmlDocumentHelper">
            <summary>
            Helpers for handling XmlDocuments.<para></para>
            All methods are implemented as static extension methods accepting null as first (i.e. this-) parameter without
            causing an exception, i.e. it is possible to do the following:<para></para>
            XmlNode node = null;<para></para>
            bool isActive = node.GetChildNode("FirstChild").GetChildNode("FirstChildsKid").GetBoolFromAttribute("IsActive", false);<para></para>
            isActive = false, after this call, which is the given default-value.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetFontFromAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Loads the font from attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The loaded font or null, if none could be loaded</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetColorFromAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Loads the color from attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The loaded color or null, if none could be loaded</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetBoolFromAttribute(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Gets the bool from attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="defaultBool">The default-value which is returned if the attribute does not exist or has no value.</param>
            <returns>
            true or false
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetBoolFromChildNode(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Gets the bool from Child node.
            </summary>
            <param name="node">The parent node.</param>
            <param name="childNodeName">Name of the child node.</param>
            <param name="defaultBool">The default-value which is returned if the attribute does not exist or has no value.</param>
            <returns>
            true or false
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetNonNullValueFromAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the non null value from attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>the value or an empty string</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetNonNullValueFromChildNode(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the non null value from child node..
            </summary>
            <param name="node">The node.</param>
            <param name="childNodeName">Name of the child node.</param>
            <returns>The value or an empty string</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetIntFromAttribute(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Gets the int from attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="defaultValue">The default value which shall be retured if no matching attribute could be found or the value of it could not be interpreted as int.</param>
            <returns>
            the read int-value or the given defaultValue
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the value of the attribute with the given name.<para></para>
            May return null, if no matching attribute exsists or it's value is null
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="defaultValue">The default value which shall be returned if no matching attribute could be found.</param>
            <returns>
            The value of the matching attribute, NULL if no matching attribute exists or it's value is null
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetChildNodeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the value of the child node with the given name.<para></para>
            May return null, if no matching child node exsists or it's value is null.
            </summary>
            <param name="node">The node.</param>
            <param name="childNodeName">Name of the child node.</param>
            <param name="defaultValue">The default value which shall be returned if no matching child node could be found.</param>
            <returns>
            The value of the matching child node, the defaultValue if no matching child node exists or it's value is null.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetChildNodeIntValue(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Determines the int-value of the child node's inner text whose name matches the given one.<para></para>
            </summary>
            <param name="node">The node.</param>
            <param name="childNodeName">Name of the child node.</param>
            <param name="defaultValue">The default value which shall be returned if no matching child node could be found.</param>
            <returns>
            The value of the matching child node, the defaultValue if no matching child node exists or it's value is null or cannot be parsed to int.
            </returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetEnumFromAttribute``1(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the enum from attribute.
            </summary>
            <typeparam name="T">the Enum-Type. If T is not an enum, null is returned.</typeparam>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The parsed enum or null</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The XmlAttribute with the given name or null.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetOrCreateAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the or create attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The existing or created attribute; Null if the passes parameters are invalid.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetChildNodeInnerText(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Sets the given innerTextToSet as InnerText to the child named childNodeName.
            </summary>
            <param name="node">The node</param>
            <param name="childNodeName">name of the child</param>
            <param name="innerTextToSet">the text which shall be set.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Sets the attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="attributeValue">The attribute value.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetAttribute(System.Xml.XmlNode,System.String,System.Drawing.Font)">
            <summary>
            Sets the attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="font">The font.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetAttribute(System.Xml.XmlNode,System.String,System.Nullable{System.Drawing.Color})">
            <summary>
            Sets the attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="color">The color.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetAttribute(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Sets the attribute.
            </summary>
            <param name="node">The node.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="boolValue">if set to <c>true</c> [bool value].</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetChildNode(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the child node with the given nodeName.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <returns>The first ChildNode with the given nodeName or null if none is found</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetChildNodes(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the child nodes.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <returns>the childnodes</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetNamedChildNode(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the named child node.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="nameAttributeValue">The name attribute value.</param>
            <returns>The childnode with the nodeName and the Attribute "Name" equalling nameAttributeValue</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetNamesOfNamedChildren(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the names of named children.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <returns>The contents of the "Name"-Attribute of the matching children.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetOrCreateChildNode(System.Xml.XmlNode,System.String)">
            <summary>
            Gets the or create child node.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <returns>The existant or created node.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.AddNewChildNode(System.Xml.XmlNode,System.String)">
            <summary>
            Add a new node with the given nodeName
            </summary>
            <param name="node">The node</param>
            <param name="nodeName">Name of the node to add</param>
            <returns>The new node or null, if none could be created.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetOwnerDocument(System.Xml.XmlNode)">
            <summary>
            Gets the owner document.
            </summary>
            <param name="node">The node.</param>
            <returns>The OwnerDocument, if available; null otherwise</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.AddChildNodeWithInnerText(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Adds a childNode with the given nodeName and the given innerText to the node.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="innerText">The inner text.</param>
            <returns>The added ChildNode or null, if none could be added.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetOrCreateNamedChildNode(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Gets the or create names child node.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="nameAttributeValue">The name attribute value.</param>
            <returns>the created node or null if none could be created</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.DeleteNamedChildNode(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deletes the child node with the give nodeName having the Name-Attribute equalling the given nameAttributeValue.<para></para>
            If no matching child is found, nothing is done.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="nameAttributeValue">The name attribute value.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.CopyNamedChildNode(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>
            Copies the child node with the give nodeName having the Name-Attribute equalling the given nameAttributeValue.<para></para>
            If no matching child is found, nothing is done.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="nameAttributeValue">The name attribute value.</param>
            <param name="newNameAttributeValue">The new name attribute value.</param>
            <returns>the copied node or null if none could be created</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.RenameNamedChildNode(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>
            Renames the child node with the give nodeName having the Name-Attribute equalling the given nameAttributeValue.<para></para>
            If no matching child is found, nothing is done.
            </summary>
            <param name="node">The node.</param>
            <param name="nodeName">Name of the node.</param>
            <param name="nameAttributeValue">The name attribute value.</param>
            <param name="newNameAttributeValue">The new name attribute value.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.DeleteChildNodes(System.Xml.XmlNode,System.String)">
            <summary>
            Deletes all child nodes with the given nodeName.
            </summary>
            <param name="node">The node whose children to delete.</param>
            <param name="nodeName">Name of the nodes to delete.</param>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.StringToFont(System.String)">
            <summary>
            Transforms the given text to a font.
            </summary>
            <param name="text">Text which shall be transformed to a font</param>
            <returns>The font or null</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.FontToString(System.Drawing.Font)">
            <summary>
            Transforms the given font to a string which can be used to write it to xml
            </summary>
            <param name="font">The font.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.ColorToString(System.Drawing.Color)">
            <summary>
            Creates a string for the given color which can be written to an xml-file
            </summary>
            <param name="color">the color</param>
            <returns>the string</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.StringToColor(System.String)">
            <summary>
            Tries to interpret the given text as argb-value to create a color from it
            </summary>
            <param name="text">the text</param>
            <returns>the corresponding color or null, if none could be determined.</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.GetNodeParameterCollection(System.Xml.XmlNode)">
            <summary>
            Get ParameterCollection of Node
            </summary>
            <param name="node">The node with a parameters child</param>
            <returns>Parameter Collection</returns>
        </member>
        <member name="M:ET.FW.Core.Settings.XmlDocumentHelper.SetNodeParameterCollection(System.Xml.XmlNode,ET.FW.Core.Common.ParameterCollection)">
            <summary>
            Set ParameterCollection of Node
            </summary>
            <param name="node">The node with a parameters child</param>
            <param name="parameters">Parameter Collection</param>
        </member>
        <member name="T:ET.FW.Core.Tracing.LogType">
            <summary>
            Types of logging message
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.LogType.Error">
            <summary>
            Error log
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.LogType.Warning">
            <summary>
            Warning log
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.LogType.Info">
            <summary>
            Info log
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.LogType.Debug">
            <summary>
            Debug log
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.LogType.Fatal">
            <summary>
            Fatal error log
            </summary>
        </member>
        <member name="T:ET.FW.Core.Tracing.ILogger">
            <summary>
            Common interface for different loggers in NTG Framework
            API is subset of log4net.ILog to allow later replacement with log4net interface
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.ILogger.LogSource">
            <summary>
            Log Source name
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Debug(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add debug message to log
            </summary>
            <param name="message">debug text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Debug(System.String)">
            <summary>
            Add debug message to log
            </summary>
            <param name="message">debug text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Info(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add info message to log
            </summary>
            <param name="message">info text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Info(System.String)">
            <summary>
            Add info message to log
            </summary>
            <param name="message">info text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Warn(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add warning message to log
            </summary>
            <param name="message">info text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Warn(System.String)">
            <summary>
            Add warning message to log
            </summary>
            <param name="message">info text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Warn(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add warning message and corresponding exception to log
            </summary>
            <param name="message">info text></param>
            <param name="ex">exception caused by the warning</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Warn(System.String,System.Exception)">
            <summary>
            Add warning message and corresponding exception to log
            </summary>
            <param name="message">info text></param>
            <param name="ex">exception caused by the warning</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Error(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add error message to log
            </summary>
            <param name="message">error text></param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Error(System.String)">
            <summary>
            Add error message to log
            </summary>
            <param name="message">error text></param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Error(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add error message and corresponding exception to log
            </summary>
            <param name="message">error text></param>
            <param name="ex">exception caused by the error</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Error(System.String,System.Exception)">
            <summary>
            Add error message and corresponding exception to log
            </summary>
            <param name="message">error text></param>
            <param name="ex">exception caused by the error</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Fatal(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add fatal message to log
            </summary>
            <param name="message">fatal text></param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Fatal(System.String)">
            <summary>
            Add fatal message to log
            </summary>
            <param name="message">fatal text></param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Fatal(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Add fatal message and corresponding exception to log
            </summary>
            <param name="message">fatal text></param>
            <param name="ex">exception caused by the error</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.Fatal(System.String,System.Exception)">
            <summary>
            Add fatal message and corresponding exception to log
            </summary>
            <param name="message">fatal text></param>
            <param name="ex">exception caused by the error</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.GetAttachmentFilename(System.String,System.String)">
            <summary>
            Get a filename with full path of trace
            </summary>
            <param name="name">The name of file, without path and extension</param>
            <param name="extension">The extension of file</param>
            <returns>filename with full path</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.GetAttachmentFilename(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get a filename with full path of trace
            </summary>
            <param name="name">The name of file, without path and extension</param>
            <param name="extension">The extension of file</param>
            <param name="subPath">The subPath below the Attachment-Directory.</param>
            <param name="suppressTimestamp">If TRUE, no automatically generated Timestamp is added to the file. Use carefully, as no check is performed, whether a file with the given name already exists.</param>
            <returns>filename with full path</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.ILogger.TraceLink(System.String,System.String)">
            <summary>
            Traces file as link.
            </summary>
            <param name="filename">The filename, which already exists in Trace</param>
            <param name="displayName">The display name oder description of the link</param>
        </member>
        <member name="P:ET.FW.Core.Tracing.ILogger.TraceAttachmentPath">
            <summary>
            Path for trace attachments. Null if tracing ist offline
            </summary>
        </member>
        <member name="T:ET.FW.Core.Tracing.ITracing">
            <summary>
            Trace API
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracing.IsOnlineMode">
            <summary>
            Is online mode
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracing.IsWriteMode">
            <summary>
            Is write mode
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracing.LOG(System.String)">
            <summary>
            Gets Logger
            </summary>
            <param name="sourceName">source name of logger</param>
            <returns>the logger</returns>
        </member>
        <member name="T:ET.FW.Core.Tracing.ITracingDispatcher">
            <summary>
            Yaming Dispatcher
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracingDispatcher.PathRoot">
            <summary>
            Gets the path root of tracing.
            </summary>
            <value>The path root.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracingDispatcher.PathConfigurations">
            <summary>
            Gets the path configurations.
            </summary>
            <value>The path configurations.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracingDispatcher.PathCatalogs">
            <summary>
            Gets the path catalogs.
            </summary>
            <value>The path catalogs.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracingDispatcher.PathTraces">
            <summary>
            Gets the path traces.
            </summary>
            <value>The path traces.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.ITracingDispatcher.PathAttachments">
            <summary>
            Gets the path attachments.
            </summary>
            <value>The path attachments.</value>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.AddConfiguration(ET.FW.Core.Common.IFileReadWrapper,System.String)">
            <summary>
            Adds the configuration.
            </summary>
            <param name="fileWrapper">File wrapper</param>
            <param name="configType">Type of the config</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.AddConfiguration(System.String,System.String)">
            <summary>
            Adds the configuration.
            </summary>
            <param name="filename">The filename.</param>
            <param name="configType">Type of the config.</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.AddAttachment(System.String)">
            <summary>
            Adds the attachment.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.AddCatalog(ET.FW.Core.Common.IFileReadWrapper)">
            <summary>
            Adds the catalog
            </summary>
            <param name="fileWrapper">File wrapper</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.AddAttachment(ET.FW.Core.Common.IFileReadWrapper,System.String)">
            <summary>
            Adds the attachment.
            </summary>
            <param name="fileWrapper">File wrapper</param>
            <param name="subpath">Subpath, relative to Attachment-Path</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.CreateAttachmentFilename(System.String,System.String)">
            <summary>
            Creates a unique filename with fullpath for attachment
            </summary>
            <param name="name">The name, only filename without path and extension</param>
            <param name="extension">The file extension</param>
            <returns>Path and filename of attachment</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.ITracingDispatcher.CreateAttachmentFilename(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Creates a unique filename with fullpath for attachment
            </summary>
            <param name="name">The name, only filename without path and extension</param>
            <param name="extension">The file extension</param>
            <param name="subPath">SubPath below Attachment-directory</param>
            <param name="suppressTimestamp">If TRUE, no automatically generated Timestamp is added to the file. Use carefully, as no check is performed, whether a file with the given name already exists.</param>
            <returns>Path and filename of attachment</returns>
        </member>
        <member name="T:ET.FW.Core.Tracing.BaseLogger">
            <summary>
            Logger which handles log messages of one category.
            All messages are passed over to central logging class with additional predefined logging code.
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.BaseLogger.IsInvalid">
            <summary>
            Logger is invalid
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.BaseLogger.LogSource">
            <summary>
            Source name
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.#ctor(System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="logSource">Log source name</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Debug(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs Debug
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Debug(System.String)">
            <summary>
            Logs debug
            </summary>
            <param name="message">Message text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Info(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs info
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Info(System.String)">
            <summary>
            Logs info
            </summary>
            <param name="message">Message text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Warn(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs warning
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Warn(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs warning
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Warn(System.String)">
            <summary>
            Logs warning
            </summary>
            <param name="message">Message text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Warn(System.String,System.Exception)">
            <summary>
            Logs wanring
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Error(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs error
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Error(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs error
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Error(System.String)">
            <summary>
            Logs error
            </summary>
            <param name="message">Message text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Error(System.String,System.Exception)">
            <summary>
            Logs error
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The Exception</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Fatal(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs fatal
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Fatal(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs fatal
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Fatal(System.String)">
            <summary>
            Logs fatal
            </summary>
            <param name="message">Message text</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.Fatal(System.String,System.Exception)">
            <summary>
            Logs fatal
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The Exception</param>
        </member>
        <member name="P:ET.FW.Core.Tracing.BaseLogger.TraceAttachmentPath">
            <summary>
            Path for trace attachments. Null if tracing is not online
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.GetAttachmentFilename(System.String,System.String)">
            <summary>
            Get a filename with full path of trace
            </summary>
            <param name="name">The name of file, without path and extension</param>
            <param name="extension">The extension of file</param>
            <returns>filename with full path</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.GetAttachmentFilename(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get a filename with full path of trace
            </summary>
            <param name="name">The name of file, without path and extension</param>
            <param name="extension">The extension of file</param>
            <param name="subPath">SubPath below Attachment-directory.</param>
            <param name="suppressTimestamp">If TRUE, no automatically generated Timestamp is added to the file. Use carefully, as no check is performed, whether a file with the given name already exists.</param>
            <returns>filename with full path</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.BaseLogger.TraceLink(System.String,System.String)">
            <summary>
            Traces file as link.
            </summary>
            <param name="filename">The filename, which already exists in Trace</param>
            <param name="displayName">The display name oder description of the link</param>
        </member>
        <member name="T:ET.FW.Core.Tracing.Log">
            <summary>
            Static wrapper for loggers of this assembly
            </summary>
            <example>
            The example shows a common call to add a message to log
            <code>
            Log.General.Error("An error occured");
            </code></example>
        </member>
        <member name="P:ET.FW.Core.Tracing.Log.Tracing">
            <summary>
            Logger with code "Tracing"
            </summary>
        </member>
        <member name="T:ET.FW.Core.Tracing.LogEventArgs">
            <summary>
            Log event args
            </summary>
        </member>
        <member name="P:ET.FW.Core.Tracing.LogEventArgs.LogType">
            <summary>
            Gets or sets the type of the log.
            </summary>
            <value>The type of the log.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.LogEventArgs.Timestamp">
            <summary>
            Gets or sets the timestamp.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.LogEventArgs.Source">
            <summary>
            Gets or sets the source.
            </summary>
            <value>The source.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.LogEventArgs.Message">
            <summary>
            Gets or sets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="P:ET.FW.Core.Tracing.LogEventArgs.Exception">
            <summary>
            Gets or sets the exception.
            </summary>
            <value>The exception.</value>
        </member>
        <member name="M:ET.FW.Core.Tracing.LogEventArgs.#ctor(ET.FW.Core.Tracing.LogType,System.DateTime,System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ET.FW.Core.Tracing.LogEventArgs"/> class.
            </summary>
            <param name="logType">Type of the log.</param>
            <param name="timestamp">The timestamp.</param>
            <param name="source">The source.</param>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="T:ET.FW.Core.Tracing.Logger">
            <summary>
            Logger which handles log messages of one category.
            All messages are passed over to central logging class with additional predefined logging code.
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.InitL4NLogger">
            <summary>
            Init Log4Net logger
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.Logger.l4nLogger">
            <summary>
            log4net logger for additional logging via log4net
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.#ctor(System.String)">
            <summary>
            The Constructor
            </summary>
            <param name="logSource">Log source name</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.LogTimestamp(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Gets Timestamp for Log
            </summary>
            <param name="timestamp">The Timestamp</param>
            <param name="hwTimestamp">Hardware timestamp</param>
            <returns>Log timestamp</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.Debug(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs Debug
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.Info(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs info
            </summary>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.Warn(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs warning
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.Error(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs error
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.Fatal(System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs fatal
            </summary>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="P:ET.FW.Core.Tracing.Logger.TraceAttachmentPath">
            <summary>
            Path for trace attachments. Null if tracing is not online
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.GetAttachmentFilename(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Get a filename with full path of trace
            </summary>
            <param name="name">The name of file, without path and extension</param>
            <param name="extension">The extension of file</param>
            <param name="subPath">SubPath below Attachment-directory.</param>
            <param name="suppressTimestamp">If TRUE, no automatically generated Timestamp is added to the file. Use carefully, as no check is performed, whether a file with the given name already exists.</param>
            <returns>filename with full path</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.Logger.TraceLink(System.String,System.String)">
            <summary>
            Traces file as link.
            </summary>
            <param name="filename">The filename, which already exists in Trace</param>
            <param name="displayName">The display name oder description of the link</param>
        </member>
        <member name="T:ET.FW.Core.Tracing.Trace">
            <summary>
            Static wrapper for Tracing
            </summary>
            <example>
            The example shows a common call to add a message to log
            <code>
            Log.General.Error("An error occured");
            </code></example>
        </member>
        <member name="E:ET.FW.Core.Tracing.Trace.LogEvent">
            <summary>
            Occurs when [log event].
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.OnLogEvent(System.Object,ET.FW.Core.Tracing.LogType,System.DateTime,System.String,System.String,System.Exception)">
            <summary>
            Called when [log event].
            </summary>
            <param name="sender">The sender.</param>
            <param name="logType">Type of the log.</param>
            <param name="timestamp">The timestamp.</param>
            <param name="source">The source.</param>
            <param name="message">The message.</param>
            <param name="ex">The ex.</param>
        </member>
        <member name="P:ET.FW.Core.Tracing.Trace.TracingInstances">
            <summary>
            registered Tracing instances
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.Trace.MAIN_TRACING">
            <summary>
            Main tracing instance name
            </summary>
        </member>
        <member name="F:ET.FW.Core.Tracing.Trace.LOG_TRACING">
            <summary>
            Main tracing instance name
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.RegisterTracing(System.String,ET.FW.Core.Tracing.ITracing)">
            <summary>
            Registers named tracing instance
            </summary>
            <param name="name">Name of tracing instance</param>
            <param name="tracing">Tracing instance</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.UnregisterTracing(System.String)">
            <summary>
            Unregisters tracing
            </summary>
            <param name="name">Name of tracing</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.GetTracing(System.String)">
            <summary>
            gets Tracing instance
            </summary>
            <param name="name">name of tracing</param>
            <returns>Tracing instance by name</returns>
        </member>
        <member name="P:ET.FW.Core.Tracing.Trace.Tracing">
            <summary>
            Main Tracing instance
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.LOG(System.String)">
            <summary>
            Get Logger by source name
            </summary>
            <param name="sourceName">source name</param>
            <returns>The Logger</returns>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.GetLogger(ET.FW.Core.Tracing.ILogger@,System.String)">
            <summary>
            Helper method for logger creation and validity checking
            Check provided logger reference. If it is null or invalid the reference is set to newly created logger.
            </summary>
            <param name="logger">Logger instance to handle</param>
            <param name="displayText">Display text for logger (e.g for Source column)</param>
            <returns>Same logger as referenced by parameter logger</returns>
        </member>
        <member name="P:ET.FW.Core.Tracing.Trace.OnlineTracings">
            <summary>
            Online Tracings
            </summary>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.Debug(System.String,System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs Debug
            </summary>
            <param name="source">Log source</param>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.Info(System.String,System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs info
            </summary>
            <param name="source">Log source</param>
            <param name="message">Message text</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.Warn(System.String,System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs warning
            </summary>
            <param name="source">Log source</param>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.Error(System.String,System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs error
            </summary>
            <param name="source">Log source</param>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="M:ET.FW.Core.Tracing.Trace.Fatal(System.String,System.String,System.Exception,System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            Logs fatal
            </summary>
            <param name="source">Log source</param>
            <param name="message">Message text</param>
            <param name="ex">The exception</param>
            <param name="timestamp">timestamp, optional</param>
            <param name="hwTimestamp">HW timestamp, optional</param>
        </member>
        <member name="T:ET.FW.Core.Log">
            <summary>
            Static wrapper for loggers of this assembly
            </summary>
            <example>
            The example shows a common call to add a message to log
            <code>
            Log.General.Error("An error occured");
            </code></example>
        </member>
        <member name="P:ET.FW.Core.Log.Core">
            <summary>
            Logger with code "Core"
            </summary>
        </member>
        <member name="T:ET.FW.Core.States.Checker.AAtomicStateChecker">
            <summary>
            Base-Class for StateCheckers
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.IsStateFulfilled(ET.FW.Core.States.Definition.AAtomicStateDefinition)">
            <summary>
            Checks, whether the given state is currently fulfilled
            </summary>
            <param name="state">The state to check.</param>
            <returns>TRUE if the given state is fulfilled, FALSE otherwise.</returns>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.AcceptsStateDefinition(ET.FW.Core.States.Definition.AAtomicStateDefinition)">
            <summary>
            Returns, whether the given state is accepted by this StateChecker.
            </summary>
            <param name="state">the state whose acceptance to check</param>
            <returns>TRUE if the given state is accepted by this checker, FALSE otherwise</returns>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.AcceptsStateDefinitionType(System.Type)">
            <summary>
            Returns, whether the given StateDefinitionType is accepted by this checker, i.e.
            can be checked by it.
            </summary>
            <param name="stateDefinitionType">the Type whose acceptance to check</param>
            <returns>TRUE if the given type is accepted by this checker, FALSE otherwise</returns>
        </member>
        <member name="P:ET.FW.Core.States.Checker.AAtomicStateChecker.HasStates">
            <summary>
            Returns TRUE if this Checker has at least one registered state.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.RegisterState(ET.FW.Core.States.Definition.AAtomicStateDefinition)">
            <summary>
            Registeres the given state with those being updated with this checker.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.RemoveState(ET.FW.Core.States.Definition.AAtomicStateDefinition)">
            <summary>
            Removes the given state
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.ClearRegisteredStates">
            <summary>
            Clears all reigistered states.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.OnEnvironmentChanged(System.DateTime)">
            <summary>
            Base-method which can be called, after the environment has changed.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.Start">
            <summary>
            Starts this StateChecker, i.e. the detection whether the state has changed.
            </summary>
            <returns>FALSE if the StateCheck is not running after this call, TRUE otherwise, i.e. TRUE
            must also be returned if Start() is called when this checker is already running.</returns>
        </member>
        <member name="M:ET.FW.Core.States.Checker.AAtomicStateChecker.Stop">
            <summary>
            Stops this StateChecker.<para></para>
            All registered StateDefinitions become discarded.
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Checker.AAtomicStateChecker.IsRunning">
            <summary>
            Flag indicating, whether this instance is running
            </summary>
        </member>
        <member name="T:ET.FW.Core.States.Definition.AAtomicStateDefinition">
            <summary>
            Baseclass for atomic State Definitions
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AAtomicStateDefinition.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.AAtomicStateDefinition.StateChecker">
            <summary>
            Reference to the StateChecker responsible for this StateDefinition
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AAtomicStateDefinition.Init(ET.FW.Core.States.Interfaces.IStateService)">
            <summary>
            Initializes this AtomicStateDefionition.<para></para>
            If overridden, base.Init(stateService) should be called.
            </summary>
            <param name="stateService">The stateService.</param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AAtomicStateDefinition.Activate">
            <summary>
            Activates the state
            </summary>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AAtomicStateDefinition.Deactivate">
            <summary>
            Deactivates the State
            </summary>
        </member>
        <member name="E:ET.FW.Core.States.Definition.AAtomicStateDefinition.PresentChangedEvent">
            <summary>
            Event which becomes raised, when IsPresent changed.
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.AAtomicStateDefinition.HasPresentChangedListeners">
            <summary>
            Returns TRUE if at least one Listener is registered on the PresentChangedEvent of this StateDefinition
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AAtomicStateDefinition.RaiseEvent(System.Boolean,System.DateTime)">
            <summary>
            Raises the PresentChangedEvent.
            </summary>
            <param name="newPresent"></param>
            <param name="eventTime"></param>
        </member>
        <member name="T:ET.FW.Core.States.Definition.ABaseStateDefinition">
            <summary>
            Abstract StateDefinition. Base-Class
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.ABaseStateDefinition.Name">
            <summary>
            Name of the State
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.ABaseStateDefinition.IsPresent">
            <summary>
            Returns, whether the state described by this AStateDefinition is currently present or not.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.Activate">
            <summary>
            Activates the StateDefinition, i.e. the PresentChangedEvent is enabled.<para></para>
            If the State is already activated, TRUE is returned and nothing is done.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.Deactivate">
            <summary>
            Deactivates the StateDefinition, i.e. the PresendChangedEvent is disabled.
            </summary>
            <returns></returns>
        </member>
        <member name="E:ET.FW.Core.States.Definition.ABaseStateDefinition.PresentChangedEvent">
            <summary>
            Event which is to be raised, when IsPresent changes
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.ABaseStateDefinition.HasPresentChangedListeners">
            <summary>
            Returns TRUE if at least one Listener is registered on the PresentChangedEvent of this StateDefinition
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.Init(ET.FW.Core.States.Interfaces.IStateService)">
            <summary>
            Initializes the StateDefinition,
            </summary>
            <param name="stateService"></param>
            <returns></returns>
        </member>
        <member name="P:ET.FW.Core.States.Definition.ABaseStateDefinition.LastEventTime">
            <summary>
            Time, when IsPresent last changed. Null if still default-value is set.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.CompareTo(System.Object)">
            <summary>
            Compare for sorting
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.ABaseStateDefinition.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:ET.FW.Core.States.Definition.AndStateDefinition">
            <summary>
            State being present, when all SubStates are present.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AndStateDefinition.SubStatePresentChangedEvent(System.Object,ET.FW.Core.States.PresentChangedEventArgs)">
            <summary>
            Handler being called, when a SubState fired its' PresentChangedEvent
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ET.FW.Core.States.Definition.AStateDefinition">
            <summary>
            Base-Class for complex StateDefinitions
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.AStateDefinition.SubStateDefinitions">
            <summary>
            Sub-State-Definitions
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.AStateDefinition.SubStateNames">
            <summary>
            Names of the SubStates for Serialization
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.Activate">
            <summary>
            Activates the StateDefinition, i.e. the PresentChangedEvent is enabled.
            </summary>
            <returns>TRUE is the instance is active after this method-call, FALSE otherwise</returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.Deactivate">
            <summary>
            Deactivates the StateDefinition, i.e. the PresendChangedEvent is disabled.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.SubStatePresentChangedEvent(System.Object,ET.FW.Core.States.PresentChangedEventArgs)">
            <summary>
            Handler being called, when a SubState fired its' PresentChangedEvent
            </summary>
            <param name="sender">the sender</param>
            <param name="args">the args</param>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.RaiseEvent(ET.FW.Core.States.PresentChangedEventArgs)">
            <summary>
            Raises the PresentChangedEvent with thie given args.
            </summary>
            <param name="eventArgs">the eventargs</param>
        </member>
        <member name="E:ET.FW.Core.States.Definition.AStateDefinition.PresentChangedEvent">
            <summary>
            Event which is to be raised, when IsPresent changes
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Definition.AStateDefinition.HasPresentChangedListeners">
            <summary>
            Returns TRUE if at least one Listener is registered on the PresentChangedEvent of this StateDefinition
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.Init(ET.FW.Core.States.Interfaces.IStateService)">
            <summary>
            Initializes this StateDefionition.<para></para>
            If overridden, base.Init(stateService) should be called.
            </summary>
            <param name="stateService">The stateService.</param>
            <returns>FALSE if an error occurs, when ths state is initialized, TRUE otherwise</returns>
        </member>
        <member name="M:ET.FW.Core.States.Definition.AStateDefinition.ToString">
            <summary>
            ToString
            </summary>
            <returns>A description</returns>
        </member>
        <member name="T:ET.FW.Core.States.Definition.NotStateDefinition">
            <summary>
            State being present, when no SubState is present
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.NotStateDefinition.SubStatePresentChangedEvent(System.Object,ET.FW.Core.States.PresentChangedEventArgs)">
            <summary>
            Handler being called, when a SubState fired its' PresentChangedEvent
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ET.FW.Core.States.Definition.OrStateDefinition">
            <summary>
            State being present, when at least one SubState is present.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Definition.OrStateDefinition.SubStatePresentChangedEvent(System.Object,ET.FW.Core.States.PresentChangedEventArgs)">
            <summary>
            Handler being called, when a SubState fired its' PresentChangedEvent
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ET.FW.Core.States.Interfaces.IStateService">
            <summary>
            Interface defining the methods of a StateService
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Interfaces.IStateService.GetCheckerForStateDefinition(ET.FW.Core.States.Definition.ABaseStateDefinition)">
            <summary>
            Returns the corresponding AtomicStateChecker for the given stateDefinition. <para></para>
            If the stateDefinition is null or not an AAtomicStateDefinition or not checker is registered for the Type,
            null is returned.
            </summary>
            <param name="stateDefinition">The ABaseStateDefinition, for which the StateChecker is requested.</param>
            <returns>The StateChecker for the given stateDefinition, or null, if none could be determined.</returns>
        </member>
        <member name="M:ET.FW.Core.States.Interfaces.IStateService.GetState(System.String)">
            <summary>
            Returns the StateDefinition with the given name<para></para>
            </summary>
            <param name="name">The name of the requested state</param>
            <returns>The stateDefinition with the given name.</returns>
        </member>
        <member name="M:ET.FW.Core.States.Interfaces.IStateService.DeactivateAllStates">
            <summary>
            Deactivates all currently active states.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Interfaces.IStateService.ActivateStates(System.Collections.Generic.List{System.String})">
            <summary>
            Activates all states whose name is contained in the given list
            </summary>
            <param name="stateNames">The names of the states which shall be activated.</param>
        </member>
        <member name="M:ET.FW.Core.States.Interfaces.IStateService.DeactivateStates(System.Collections.Generic.List{System.String})">
            <summary>
            Deactivates all states whose name is contained in the given list
            </summary>
            <param name="stateNames">The names of the states which shall be deactivated.</param>
        </member>
        <member name="T:ET.FW.Core.States.PresentChangedEventHandler">
            <summary>
            Event-Delegate for PresentChangedEvent of AStateDefinition
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ET.FW.Core.States.PresentChangedEventArgs">
            <summary>
            EventArgs for AStateDefinitions when IsPresent changes.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.PresentChangedEventArgs.#ctor(ET.FW.Core.States.Definition.ABaseStateDefinition,System.Boolean,System.DateTime)">
            <summary>
            Constructor
            </summary>
            <param name="stateDef">The StateDefinition creating this EventArgs</param>
            <param name="isPresent">Is stateDef present</param>
            <param name="timeStamp">Timestampe, when the presence-change occured.</param>
        </member>
        <member name="P:ET.FW.Core.States.PresentChangedEventArgs.StateName">
            <summary>
            Name of the State
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.PresentChangedEventArgs.NewIsPresent">
            <summary>
            Flag, whether the state is now present or not
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.PresentChangedEventArgs.StateDefinition">
            <summary>
            Reference to the AStateDefinition
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.PresentChangedEventArgs.TimeStamp">
            <summary>
            Timestamp, when IsPresent changed.
            </summary>
        </member>
        <member name="T:ET.FW.Core.States.Repository.StateDefinitionRepository">
            <summary>
            Repository for all StateDefinitions
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Repository.StateDefinitionRepository.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.Repository.StateDefinitionRepository.StateDefinitions">
            <summary>
            All known State-Definitions
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.Repository.StateDefinitionRepository.GetState(System.String)">
            <summary>
            Returns the StateDefinition with the given name<para></para>
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ET.FW.Core.States.Repository.StateDefinitionRepository.AddState(ET.FW.Core.States.Definition.ABaseStateDefinition)">
            <summary>
            Adds the passed stateDefinition.<para></para>
            Throws an ArgumentException, if null is passed or the name of the passed stateDefinition is null or empty.<para></para>
            Throws an ArgumentException, if a state with the given name is already defined.
            </summary>
            <param name="stateDefinition">The stateDefinition to add.</param>
        </member>
        <member name="T:ET.FW.Core.States.StateTypeDefinition">
            <summary>
            Definition of a StateType, consisting of a StateDefinition-class, the corresponding StateChecker-class
            and the assembly those classes are located in.
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.StateTypeDefinition.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.StateTypeDefinition.Assembly">
            <summary>
            Name of the assembly, where the StateDefinitionClass and the StateCheckerClass are located.
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.StateTypeDefinition.StateDefinitionClass">
            <summary>
            Name of the StateDefinitionClass
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.StateTypeDefinition.StateCheckerClass">
            <summary>
            Name of the StateCheckerClass
            </summary>
        </member>
        <member name="T:ET.FW.Core.States.StateTypeDefinitionContainer">
            <summary>
            Container for StateTypeDefinitions
            </summary>
        </member>
        <member name="M:ET.FW.Core.States.StateTypeDefinitionContainer.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:ET.FW.Core.States.StateTypeDefinitionContainer.StateTypeDefinitions">
            <summary>
            The StateTypeDefinitions
            </summary>
        </member>
        <member name="T:XmlDocumentationExtensions">
            <summary>
            Provides extension methods for reading XML comments from reflected members.
            </summary>
        </member>
        <member name="M:XmlDocumentationExtensions.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:XmlDocumentationExtensions.GetMemberElementName(System.Reflection.MemberInfo)">
            <summary>
            Returns the expected name for a member element in the XML documentation file.
            </summary>
            <param name="member">The reflected member.</param>
            <returns>The name of the member element.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo,System.String)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <param name="pathToXmlFile">Path to the XML documentation file.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.MemberInfo,System.Xml.Linq.XDocument)">
            <summary>
            Returns the XML documentation (summary tag) for the specified member.
            </summary>
            <param name="member">The reflected member.</param>
            <param name="xml">XML documentation.</param>
            <returns>The contents of the summary tag for the member.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo,System.String)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <param name="pathToXmlFile">Path to the XML documentation file.</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
        <member name="M:XmlDocumentationExtensions.GetXmlDocumentation(System.Reflection.ParameterInfo,System.Xml.Linq.XDocument)">
            <summary>
            Returns the XML documentation (returns/param tag) for the specified parameter.
            </summary>
            <param name="parameter">The reflected parameter (or return value).</param>
            <param name="xml">XML documentation.</param>
            <returns>The contents of the returns/param tag for the parameter.</returns>
        </member>
    </members>
</doc>
